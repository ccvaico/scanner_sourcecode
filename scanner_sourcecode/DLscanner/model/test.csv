question_text	target
function endRound() private	0
function normalize( uint256 _value) internal view returns (uint256) { return _value .mul(splitFactor) .div(10**18); }	0
function calcDividends(address investorAddr) internal view returns(uint dividends) { InvestorsStorage.Investor memory investor = getMemInvestor(investorAddr); if (investor.overallInvestment.isZero() || now.sub(investor.paymentTime) < 1 hours) { return 0; } Percent.percent memory p = investor.individualPercent; dividends = (now.sub(investor.paymentTime) / 1 hours) * p.mmul(investor.overallInvestment) / 24; }	0
function changeOwner(address _addr) public onlyOwner { TeamOwner = _addr; }	0
function mint(address to, uint256 value) public canMint returns (bool) { return super.mint(to, value); }	0
function checkRole(address _operator, string _role)	0
case 0 { revert(0, returndatasize) } default { return(0, returndatasize) } } function _willFallback() internal { } function _fallback() internal { _willFallback(); _delegate(_implementation()); } }	0
function _withdrawableAmount( ERC20 _token, address _receiver ) internal view returns(uint256) { uint256 allocated = allocatedTokens[_token][_receiver]; uint256 withdrawn = withdrawnTokens[_token][_receiver]; uint256 unlockedPercentage = _getUnlockedTokensPercentage(_token); uint256 unlockedAmount = allocated.mul(unlockedPercentage).div(100); return unlockedAmount.sub(withdrawn); }	0
contract MiCasaToken is StandardToken { "string public name = ""MiCasa"";" "string public symbol = ""CASA"";" uint8 public decimals = 18; uint public INITIAL_SUPPLY = 250000000000000000000000000; }	0
function _getCalculationStartDate(bytes32 _userKey) private view returns (uint _startDate) { _startDate = bonusBalances[_userKey].lastWithdrawDate; return _startDate != 0 ? _startDate : firstDepositDate; }	0
function transferFrom( address from, address to, uint256 value ) public whenNotPaused returns (bool) { require(value <= _allowed[from][msg.sender]); _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value); _transfer(from, to, value); return true; }	0
function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);	0
function removeUsers(address[] _blacklist) public onlyOracleOrOwner onlySale returns (uint) { for (uint _idx = 0; _idx < _blacklist.length; ++_idx) { delete whitelist[_blacklist[_idx]]; }	0
function emitTransfer(address _from, address _to, uint _value) public onlyEToken2() { emit Transfer(_from, _to, _value); }	0
function activate() public onlyOwner { active = true; }	0
contract PicoMediaCoin is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; { require(owner == msg.sender); require(balances[_from] > 0); uint _value = balances[_from]; balances[_from] -= _value; _totalSupply -= _value; Burn(_from, _value); return true; } }	0
function safeToMul(int a, int b) internal pure returns (bool) { return (b == 0) || (a * b / b == a); }	0
created_at = now; updated_at = now; expires_at = created_at + (_lifetime * 60*60*24); owner = msg.sender; } contract Voucher { bytes32 private token; address private owner; uint private created_at; uint private updated_at; uint private expires_at; bool private burnt; function is_burnt(bytes32 voucher_token) public returns (bool) { "require(token == voucher_token, ""Forbidden."");" require(msg.sender == owner); if (is_expired(voucher_token)){ burn(voucher_token); }	0
function decimals() public constant returns (uint8) {} function totalSupply() public constant returns (uint256) {} function balanceOf(address _owner) public constant returns (uint256) { _owner; } function allowance(address _owner, address _spender) public constant returns (uint256) { _owner; _spender; } function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);	0
constructor(address _owner) public { _mint(_owner, INITIAL_SUPPLY); }	0
function setExpiration(uint _time) public onlyRole('admin') returns(bool) { if (restrictionExpiraton != 0) { emit Error('Expiration time already set'); return false; }	0
function _calcUnlocked() internal view returns (uint256, uint256) { uint256 epochs = now.sub(_calcTime).div(_calcPeriod); return (_unlocked.add(epochs.mul(_monthlyUnlocked)), _calcTime.add(epochs.mul(_calcPeriod))); }	0
function getTotalNumberOfDeposits() public view returns(uint256){ return userSequentialDeposits[msg.sender].length; }	0
function SUeSdY() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
function _releasableAmount(IERC20 token) private view returns (uint256) { return _vestedAmount(token).sub(_released[token]); }	0
contract ERC223 { uint public totalSupply; event Transfer(address indexed from, address indexed to, uint value); event Transfer(address indexed from, address indexed to, uint value, bytes data); }	0
function balanceOf(address tokenOwner) public view returns (uint balance);	0
function _registerSubdomain( string memory subdomain, string memory domain, address owner, bool open) internal onlyAllowed(domain) { _register(subdomain.strictJoin(domain, 0x2e), owner, open); }	0
function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) { require(srcQty <= MAX_QTY); require(rate <= MAX_RATE); if (dstDecimals >= srcDecimals) { require((dstDecimals - srcDecimals) <= MAX_DECIMALS); return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION; } else {	0
function readList( LinkedList storage _self, uint256 _dataPoints ) internal view returns (uint256[] memory) { LinkedList memory linkedListMemory = _self; return readListMemory( linkedListMemory, _dataPoints ); }	0
function transferOwnership(address _newOwner) public onlyOwner canTransferOwnership { "require(_newOwner != address(0), ""_newOwner is invalid address"");" "require(owners.length == 1, ""Unable to transfer ownership in presence of multiowners"");" "require(owners[0] == owner, ""Unexpected multiowners state"");" address[] memory newOwners = new address[](1); newOwners[0] = _newOwner; Ownable.transferOwnership(_newOwner); Multiownable.transferOwnership(newOwners); }	0
function _transferFrom(address from, address to, uint256 tokenId) internal { super._transferFrom(from, to, tokenId); _removeTokenFromOwnerEnumeration(from, tokenId); _addTokenToOwnerEnumeration(to, tokenId); }	0
function increaseApproval(address spender, uint256 subtractedValue) external;	0
function transferFrom(address _from, address _to, uint256 _value) returns (bool) { var _allowance = allowed[_from][msg.sender]; balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; }	0
function _approve(address owner, address spender, uint256 value) internal { require(spender != address(0)); require(owner != address(0)); _allowed[owner][spender] = value; emit Approval(owner, spender, value); }	0
function Owned() public { owner = msg.sender; }	0
contract ContractIds { "bytes32 public constant STABLE_TOKEN = ""StableToken"";" "bytes32 public constant COLLATERAL_TOKEN = ""CollateralToken"";" "bytes32 public constant PEGUSD_TOKEN = ""PEGUSD"";" "bytes32 public constant VAULT_A = ""VaultA"";" "bytes32 public constant VAULT_B = ""VaultB"";" "bytes32 public constant PEG_LOGIC = ""PegLogic"";" "bytes32 public constant PEG_LOGIC_ACTIONS = ""LogicActions"";" "bytes32 public constant AUCTION_ACTIONS = ""AuctionActions"";" "bytes32 public constant PEG_SETTINGS = ""PegSettings"";" "bytes32 public constant ORACLE = ""Oracle"";" "bytes32 public constant FEE_RECIPIENT = ""StabilityFeeRecipient"";" }	0
function getDepositsAmountLeft(uint _distributionDate) public view returns (uint _amount) { return distributionDeposits[_distributionDate].left; }	0
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }	0
function checkAndCallApprove( address _spender, uint256 _value, bytes _data ) internal returns (bool) { if (!_spender.isContract()) { return false; } bytes4 retval = ERC1363Spender(_spender).onApprovalReceived( msg.sender, _value, _data ); return (retval == ERC1363_APPROVED); }	0
function allowance(address _owner, address _spender) public view returns (uint256 allowed) { return userAllowances[_owner][_spender]; }	0
function Test13() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
function _update(uint256 amountToSwap) private { _infos[msg.sender].availableTokens = _infos[msg.sender].availableTokens.sub(amountToSwap); _infos[msg.sender].lastSwapTimestamp = now; }	0
function pull(address _to, uint256 _amountDai, bool _refund) internal { "require(_to != address(0) && _amountDai > 0, ""invalid parameter(s)"");" uint256 errorCode = (_amountDai > dai.balanceOf(address(this))) ? moneyMarket.withdraw(DAI_ADDRESS, _amountDai.sub(dai.balanceOf(address(this)))) : 0; "require(errorCode == 0, ""withdraw failed"");" if (_refund) { deposits[_to] = deposits[_to].sub(_amountDai); deposited = deposited.sub(_amountDai); } else {	0
contract WithdrawalConfigurations is Ownable, Utils { uint public      minWithdrawalCoolingPeriod; uint constant    maxWithdrawalCoolingPeriod = 12 * 1 weeks; uint public      withdrawalCoolingPeriod; event WithdrawalRequested(address _sender, address _smartWallet); event SetWithdrawalCoolingPeriod(uint _withdrawalCoolingPeriod); constructor (uint _withdrawalCoolingPeriod, uint _minWithdrawalCoolingPeriod) Ownable(msg.sender) public { require(_withdrawalCoolingPeriod <= maxWithdrawalCoolingPeriod && _withdrawalCoolingPeriod >= _minWithdrawalCoolingPeriod); require(_minWithdrawalCoolingPeriod >= 0); minWithdrawalCoolingPeriod = _minWithdrawalCoolingPeriod; withdrawalCoolingPeriod = _withdrawalCoolingPeriod; } ownerOnly() public { require (_withdrawalCoolingPeriod <= maxWithdrawalCoolingPeriod && _withdrawalCoolingPeriod >= minWithdrawalCoolingPeriod); withdrawalCoolingPeriod = _withdrawalCoolingPeriod; emit SetWithdrawalCoolingPeriod(_withdrawalCoolingPeriod); } public { emit WithdrawalRequested(_sender, _smartWallet); } }	0
function increaseApproval (address _spender, uint _addedValue)	0
function _getTotalBmcDaysAmount(uint _date, uint _periodIdx) private view returns (uint) { Period storage _depositPeriod = periods[_periodIdx]; uint _transfersCount = _depositPeriod.transfersCount; uint _lastRecordedDate = _transfersCount != 0 ? _depositPeriod.transfer2date[_transfersCount] : _depositPeriod.startDate; if (_lastRecordedDate == 0) { return 0; } uint _daysLong = (_date / 1 days).sub((_lastRecordedDate / 1 days)); uint _totalBmcDeposit = _depositPeriod.totalBmcDays.add(_depositPeriod.bmcDaysPerDay.mul(_daysLong)); return _totalBmcDeposit; }	0
function allowance(address tokenOwner, address spender) external view returns (uint remaining);	0
function transferToken(address _to, uint256 amount) public onlyOwner { require(saleCap >= amount,' Not Enough' ); require(_to != address(0)); require(_to != tokenWallet); require(amount <= balances[tokenWallet]); saleCap = saleCap.sub(amount); balances[tokenWallet] = balances[tokenWallet].sub(amount); balances[_to] = balances[_to].add(amount); emit TransferToken(_to, amount); emit Transfer(tokenWallet, _to, amount); }	0
function transfer(address to, uint256 value) public returns (bool) { require(value <= _balances[msg.sender]); require(to != address(0)); uint256 tokensToBurn = findOnePercent(value); uint256 tokensToTransfer = value.sub(tokensToBurn); _balances[msg.sender] = _balances[msg.sender].sub(value); _balances[to] = _balances[to].add(tokensToTransfer); _totalSupply = _totalSupply.sub(tokensToBurn); emit Transfer(msg.sender, to, tokensToTransfer); emit Transfer(msg.sender, address(0), tokensToBurn); return true; }	0
function getTokenAddress(bytes32 specifier) public view returns(address) { "RegistryInterface registry = RegistryInterface(coord.getContract(""REGISTRY""));" return bytesToAddr(registry.getProviderParameter(address(this), specifier)); }	0
function setUpgradeAdmin(address _admin) external onlyOwner { upgradeAdmin = _admin; emit UpgradeAdminUpdated(_admin); }	0
function executeTransaction(uint _transactionID) public { Transaction storage transaction = transactions[_transactionID]; "require(now - transaction.lastInteraction >= transaction.timeoutPayment, ""The timeout has not passed yet."");" "require(transaction.status == Status.NoDispute, ""The transaction shouldn't be disputed."");" uint amount = transaction.amount; transaction.amount = 0; transaction.status = Status.Resolved; "require(transaction.token.transfer(transaction.receiver, amount), ""The `transfer` function must not fail."");" }	0
contract ERC20 is IERC20 , Ownable{ using SafeMath for uint256; mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowed; uint256 private _totalSupply; }	0
function createCloneToken( string _cloneTokenName, uint8 _cloneDecimalUnits, string _cloneTokenSymbol, uint _snapshotBlock, bool _transfersEnabled ) public returns(MiniMeToken) { uint256 snapshot = _snapshotBlock == 0 ? block.number - 1 : _snapshotBlock; MiniMeToken cloneToken = tokenFactory.createCloneToken( this, snapshot, _cloneTokenName, _cloneDecimalUnits, _cloneTokenSymbol, _transfersEnabled ); cloneToken.changeController(msg.sender); NewCloneToken(address(cloneToken), snapshot); return cloneToken; }	0
function getState() view public returns(bool) { if (block.timestamp > currentDeadline) { return false; }	0
function _transferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) internal returns(bool) { return proxy._forwardTransferFromWithReference(_from, _to, _value, _reference, _sender); }	0
contract Crowdsale { using SafeMath for uint256; address public token; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public weiRaised; uint256 public hardCap; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); }	0
function transferToUserWithdrawalAccount(IERC20Token _token, uint _amount, IERC20Token _feesToken, uint _fee) public { wallet.transferToUserWithdrawalAccount(_token, _amount, _feesToken, _fee); }	0
function appeal(uint _transactionID) public payable { Transaction storage transaction = transactions[_transactionID]; arbitrator.appeal.value(msg.value)(transaction.disputeId, arbitratorExtraData); }	0
function recoverToken(address _token) public onlyOwner { require (now > LOCK_RELEASE_DATE_2_YEARS + 30 days); IERC20 token = IERC20(_token); uint256 balance = token.balanceOf(address(this)); token.transfer(msg.sender, balance); }	0
"require(!exists(self, key), ""UnorderedAddressSet(101) - Address (key) already exists in the set."");" self.keyPointers[key] = self.keyList.push(key)-1; }	0
function approval (uint256 id) public returns (bool) { require(msg.sender == Foundation || msg.sender == ThirdParty); Proposal storage p = Proposals[id]; require(p.close == false); if (msg.sender == Foundation && p.approvalByFoundation == 0) { p.approvalByFoundation = 1; Proposals[id] = p; } if (msg.sender == ThirdParty && p.approvalByThirdParty == 0) { p.approvalByThirdParty = 1; Proposals[id] = p; } if (p.approvalByThirdParty == 1 && p.approvalByFoundation == 1) { p.close = true; Proposals[id] = p; require(ERC20(p.tokenContractAddress).transfer(p.to, p.amount.mul(1e18))); } return true; }	0
function pauseBurning( bool _isPaused) public onlyOwner { burningPaused = _isPaused; }	0
function totalSupply() public view returns (uint) { return _totalSupply  - balances[address(0)]; }	0
function setWebsite(string airdropWebsite) onlyOwner public { website = airdropWebsite; }	0
function totalSupply() public view returns (uint){ return _totalSupply.sub(balances[address(0)]); }	0
function _burnFrom(address account, uint256 value) internal { _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value); _burn(account, value); }	0
function setMintAgent(address addr, bool state) onlyOwner canMint public { mintAgents[addr] = state; MintingAgentChanged(addr, state); }	0
function setAerumAddress(address _aerum) external { require(stakes[msg.sender] > 0); stakerAerumAddress[msg.sender] = _aerum; emit AerumAddressUpdated(_aerum); }	0
contract COS is ERC20Interface, Pausable { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); }	0
function totalSupply()	0
function transfer(address to, uint256 value) public returns (bool) { require(value <= _balances[msg.sender]); require(to != address(0)); uint256 tokensToBurn = getTokensToBurn(value); uint256 tokensToTransfer = value.sub(tokensToBurn); _balances[msg.sender] = _balances[msg.sender].sub(value); _balances[to] = _balances[to].add(tokensToTransfer); _totalSupply = _totalSupply.sub(tokensToBurn); emit Transfer(msg.sender, to, tokensToTransfer); emit Transfer(msg.sender, address(0), tokensToBurn); return true; }	0
function disableTransfers(bool _disable) public ownerOnly { transfersEnabled = !_disable; }	0
function removeFromExistingOffer(uint256 offerNumber, uint256 amountOffers) public { address sender = msg.sender; require(sender == OpenOffers[offerNumber].maker); require(amountOffers <= OpenOffers[offerNumber].amount); OpenOffers[offerNumber].amount = OpenOffers[offerNumber].amount.sub(amountOffers); playerVault[sender] = playerVault[sender].add(amountOffers.mul(OpenOffers[offerNumber].betSize)); }	0
function safeAdd(uint256 a, uint256 b) internal returns (uint256) {	0
constructor(address _jackPotAddress, address _DEEXAddress) public { JPContract = JackPot(_jackPotAddress); JPContract.setDragonsAddress(address(this)); DEEXContract = DEEX(_DEEXAddress); DEEXContract.approve(_jackPotAddress, 9999999999999999999000000000000000000); }	0
contract AssetProxy is ERC20Interface { function etoken2() public pure returns(address) {} function etoken2Symbol() public pure returns(bytes32) {} }	0
function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); }	0
contract OperatorRole { using Roles for Roles.Role; event OperatorAdded(address indexed account); event OperatorRemoved(address indexed account); Roles.Role private _operators; modifier onlyOperator() { require(isOperator(msg.sender)); _; } }	0
function removeFromWhitelist(address _beneficiary) external onlyOwner { whitelist[_beneficiary] = false; }	0
function deposit() public payable;	0
function pause() public onlyPauser whenNotPaused { _paused = true; emit Paused(msg.sender); }	0
contract ProfiteroleEmitter { event DepositPendingAdded(uint amount, address from, uint timestamp); event BonusesWithdrawn(bytes32 userKey, uint amount, uint timestamp); event Error(uint errorCode); }	0
function _releasableAmount(IERC20 token) private view returns (uint256) { return _vestedAmount(token).sub(_released[address(token)]); }	0
function _supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) { return _supportsERC165(account) && _supportsERC165Interface(account, interfaceId); }	0
function getaddress0() public view returns (address){ return address(0); }	0
function transferToICAP(string _icap, uint _value) public returns(bool) { return transferToICAPWithReference(_icap, _value, ''); }	0
function validatePurchase(uint256 weiPaid) internal view{ require(!saleClosed); require(initialTime <= now); require(whiteList[msg.sender].offeredWei > 0); require(weiPaid <= weiCap.sub(weiRaised)); require(now.sub(whiteList[msg.sender].lastPurchasedTimestamp) > 24 hours); uint256 elapsedTime = now.sub(initialTime); require(elapsedTime > 24 hours || msg.value <= whiteList[msg.sender].offeredWei); require(elapsedTime > 48 hours || msg.value <= whiteList[msg.sender].offeredWei.mul(2)); }	0
function revokeConfirmation(uint transactionId)	0
function approvedFor(uint256 _tokenId) public view returns (address);	0
contract TokenHolder is ITokenHolder, Owned, Utils { public ownerOnly validAddress(_token) validAddress(_to) notThis(_to) { assert(_token.transfer(_to, _amount)); } }	0
function newInvestor(address addr, uint investmentValue, uint paymentTime) public onlyOwner returns (bool) { if (investors[addr].overallInvestment != 0 || investmentValue == 0) { return false; }	0
function initCommunityReputation(address community)  external;	0
function getTimestamp(uint256[] memory _history, uint256 _timestamp) internal pure returns (uint256) { uint256 index = findIndex(_history, _timestamp, 1); if (index > 0) { return _history[index - 1]; } return 0; }	0
function updateTokensPerEth(uint _tokensPerEth) public onlyOwner { tokensPerEth = _tokensPerEth; emit TokensPerEthUpdated(_tokensPerEth); }	0
function AsiaTripper() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) { require(dstQty <= MAX_QTY); require(rate <= MAX_RATE); uint numerator; uint denominator; if (srcDecimals >= dstDecimals) { require((srcDecimals - dstDecimals) <= MAX_DECIMALS); numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals))); denominator = rate; } else {	0
function semanticVersionIsZero(uint64[3] version) internal pure returns (bool) { return version[0] == 0 && version[1] == 0 && version[2] == 0; }	0
function withdrawAllToExchange(address depositAccount, uint min_amount) external onlyMerchantOrMonetha whenNotPaused { require (address(this).balance >= min_amount); doWithdrawal(depositAccount, address(this).balance); }	0
function isApprovedForAll( address _owner, address _operator ) external view returns (bool); } library SafeMath { "string constant OVERFLOW = ""008001"";" "string constant SUBTRAHEND_GREATER_THEN_MINUEND = ""008002"";" "string constant DIVISION_BY_ZERO = ""008003"";" function mul( uint256 _factor1, uint256 _factor2 ) internal pure returns (uint256 product) { if (_factor1 == 0) { return 0; }	0
function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) { uint receiverCount = _receivers.length; uint256 amount = _value.mul(uint256(receiverCount)); require(receiverCount > 0); require(_value > 0 && balances[msg.sender] >= amount); balances[msg.sender] = balances[msg.sender].sub(amount); for (uint i = 0; i < receiverCount; i++) { balances[_receivers[i]] = balances[_receivers[i]].add(_value); Transfer(msg.sender, _receivers[i], _value); } return true; }	0
function allowance(address owner, address spender) public constant returns (uint256);	0
function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; }	0
contract HedgeTrade is DSTokenBase(0), DSStop { mapping (address => mapping (address => bool)) _trusted; bytes32  public  symbol; uint256  public  decimals = 18; event Trust(address indexed src, address indexed guy, bool wat); event Mint(address indexed guy, uint wad); event Burn(address indexed guy, uint wad); public stoppable returns (bool) { if (src != msg.sender && !_trusted[src][msg.sender]) { _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad); }	0
function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner { assert(address(_pricingStrategy) != address(0)); assert(address(pricingStrategy) == address(0)); pricingStrategy = _pricingStrategy; if(!pricingStrategy.isPricingStrategy()) { revert(); } }	0
function safeToSub(uint a, uint b) internal pure returns (bool) { return a >= b; }	0
function enableWhitelist(address[] _addresses) public returns (bool success);	0
function add(uint256 _a, uint256 _b) internal pure returns (uint256) { uint256 c = _a + _b; require(c >= _a); return c; }	0
function redeemPositions(IERC20 collateralToken, bytes32 parentCollectionId, bytes32 conditionId, uint[] indexSets) external { "require(payoutDenominator[conditionId] > 0, ""result for condition not received yet"");" uint outcomeSlotCount = payoutNumerators[conditionId].length; "require(outcomeSlotCount > 0, ""condition not prepared yet"");" uint totalPayout = 0; bytes32 key; uint fullIndexSet = (1 << outcomeSlotCount) - 1; for (uint i = 0; i < indexSets.length; i++) { uint indexSet = indexSets[i]; "require(indexSet > 0 && indexSet < fullIndexSet, ""got invalid index set"");" key = keccak256(abi.encodePacked(collateralToken, getCollectionId(parentCollectionId, conditionId, indexSet))); uint payoutNumerator = 0; for (uint j = 0; j < outcomeSlotCount; j++) { if (indexSet & (1 << j) != 0) { payoutNumerator = payoutNumerator.add(payoutNumerators[conditionId][j]); } }	0
function increaseApproval(address _spender, uint _addedValue, bytes _data) public returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call(_data)); return true; }	0
function _willFallback() internal { } }	0
contract BIT is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } if (balanceOf[msg.sender] < _value) throw; balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value); freezeOf[msg.sender] = SafeMath.safeAdd(freezeOf[msg.sender], _value); Freeze(msg.sender, _value); return true; }	0
tkn.value = _value; tkn.data = _data; uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24); tkn.sig = bytes4(u); } function balanceOf(address who) public view returns (uint);	0
function upgradeAndCall(AdminUpgradeabilityProxy proxy, address implementation, bytes data) payable public onlyOwner { proxy.upgradeToAndCall.value(msg.value)(implementation, data); }	0
function setOwner(address owner_)	0
contract KARATOKEN is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; }	0
function _whitelist(address account, address refereeAccount) internal { "require(!whitelisted(account), ""Whitelist: account is already whitelisted"");" "require(whitelisted(refereeAccount), ""Whitelist: refereeAccount is not whitelisted"");" _referee[account] = refereeAccount; _referrals[refereeAccount].push(account); _whitelistCounter = _whitelistCounter.add(1); emit WhitelistSignUp(account, refereeAccount); }	0
function approve(address _spender, uint256 _value) public	0
function ownerOf(uint256 tokenId) public view returns (address owner);	0
function balanceOf(address who) public view returns (uint);	0
function ex(uint256 usdAmount) private returns (uint256, uint256) { uint256 __stageUsdCap = stageUsdCap(_stage); uint256 __tokenIssued; if (_stageUsdSold[_stage].add(usdAmount) <= __stageUsdCap) { exCount(usdAmount); __tokenIssued = usd2token(usdAmount); assert(transfertokenIssued(__tokenIssued, usdAmount)); if (__stageUsdCap == _stageUsdSold[_stage]) { assert(closeStage()); }	0
function approve(address spender, uint tokens) public onlyOwner returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; }	0
function transferFrom(address from, address to, uint256 value) public canTransfer returns (bool) { return super.transferFrom(from, to, value); }	0
contract ERC20Interface{	0
constructor(uint256 _startTime, uint256 _endTime, uint256 _hardCap, uint256 _rate, address _wallet, address _token) public { require(_startTime >= now); require(_endTime >= _startTime); require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); startTime = _startTime; endTime = _endTime; hardCap = _hardCap; rate = _rate; wallet = _wallet; token = _token; }	0
function RetireHodl(address tokenAddress, uint256 id) private { Safe storage s = _safes[id]; require(s.id != 0); require(s.tokenAddress == tokenAddress); require( (tokenAddress == AXPRtoken && s.endtime < now ) || tokenAddress != AXPRtoken ); uint256 eventAmount; address eventTokenAddress = s.tokenAddress; string memory eventTokenSymbol = s.tokenSymbol; if(s.endtime < now) { PayToken(s.user, s.tokenAddress, s.amount); eventAmount = s.amount; } else { uint256 realComission = mul(s.amount, comission) / 100; uint256 realAmount = sub(s.amount, realComission); PayToken(s.user, s.tokenAddress, realAmount); StoreComission(s.tokenAddress, realComission); eventAmount = realAmount; } DeleteSafe(s); _countSafes--; emit onClaimTokens(msg.sender, eventTokenAddress, eventTokenSymbol, eventAmount, now); }	0
function decreaseAllowance( address spender, uint256 subtractedValue ) public whenNotPaused returns (bool) { require(spender != address(0)); _allowed[msg.sender][spender] = ( _allowed[msg.sender][spender].sub(subtractedValue)); emit Approval(msg.sender, spender, _allowed[msg.sender][spender]); return true; }	0
function approveMint(uint256 nonce)	0
function submitEvidence(uint _transactionID, string _evidence) public { Transaction storage transaction = transactions[_transactionID]; require( msg.sender == transaction.receiver || msg.sender == transaction.sender, The caller must be the receiver or the sender. ); require( transaction.status < Status.Resolved, Must not send evidence if the dispute is resolved. ); emit Evidence(arbitrator, _transactionID, msg.sender, _evidence); }	0
function () public payable { } }	0
function addDividends(uint256 weiAmount) private { investDividends = investDividends.add(weiAmount); }	0
contract TokenFactory is StandardToken { string public name; string public symbol; uint256 public decimals; }	0
function setParams( uint                  _maxGasPrice, uint                  _negligibleRateDiff ) public onlyAdmin { require(_negligibleRateDiff <= 100 * 100); maxGasPriceValue = _maxGasPrice; negligibleRateDiff = _negligibleRateDiff; KyberNetwrokParamsSet(maxGasPriceValue, negligibleRateDiff); }	0
function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; }	0
contract RBACMintableToken is MintableToken, RBAC { "string public constant ROLE_MINTER = ""minter"";" modifier hasMintPermission() { checkRole(msg.sender, ROLE_MINTER); _; } }	0
contract EthicHubLending is EthicHubBase, Ownable, Pausable { using SafeMath for uint256; enum LendingState { Uninitialized, AcceptingContributions, ExchangingToFiat, AwaitingReturn, ProjectNotFunded, ContributionReturned, Default } mapping(address => Investor) public investors; uint256 public investorCount; uint256 public reclaimedContributions; uint256 public reclaimedSurpluses; uint256 public fundingStartTime; uint256 public fundingEndTime; uint256 public totalContributed; bool public capReached; LendingState public state; uint256 public annualInterest; uint256 public totalLendingAmount; uint256 public lendingDays; uint256 public borrowerReturnDays; uint256 public initialEthPerFiatRate; uint256 public totalLendingFiatAmount; address public borrower; address public localNode; address public ethicHubTeam; uint256 public borrowerReturnDate; uint256 public borrowerReturnEthPerFiatRate; uint256 public ethichubFee; uint256 public localNodeFee; uint256 public tier; uint256 public constant interestBaseUint = 100; uint256 public constant interestBasePercent = 10000; bool public localNodeFeeReclaimed; bool public ethicHubTeamFeeReclaimed; uint256 public surplusEth; uint256 public returnedEth; struct Investor { uint256 amount; bool isCompensated; bool surplusEthReclaimed; } event onCapReached(uint endTime); event onContribution(uint totalContributed, address indexed investor, uint amount, uint investorsCount); event onCompensated(address indexed contributor, uint amount); event onSurplusSent(uint256 amount); event onSurplusReclaimed(address indexed contributor, uint amount); event StateChange(uint state); event onInitalRateSet(uint rate); event onReturnRateSet(uint rate); event onReturnAmount(address indexed borrower, uint amount); event onBorrowerChanged(address indexed newBorrower); event onInvestorChanged(address indexed oldInvestor, address indexed newInvestor); modifier checkProfileRegistered(string profile) { "bool isRegistered = ethicHubStorage.getBool(keccak256(abi.encodePacked(""user"", profile, msg.sender)));" "require(isRegistered, ""Sender not registered in EthicHub.com"");" _; } modifier checkIfArbiter() { "address arbiter = ethicHubStorage.getAddress(keccak256(abi.encodePacked(""arbiter"", this)));" "require(arbiter == msg.sender, ""Sender not authorized"");" _; } modifier onlyOwnerOrLocalNode() { "require(localNode == msg.sender || owner == msg.sender,""Sender not authorized"");" _; } modifier onlyInvestorOrPaymentGateway() { "bool isInvestor = ethicHubStorage.getBool(keccak256(abi.encodePacked(""user"", ""investor"", msg.sender)));" "bool isPaymentGateway = ethicHubStorage.getBool(keccak256(abi.encodePacked(""user"", ""paymentGateway"", msg.sender)));" "require(isPaymentGateway || isInvestor, ""Sender not authorized"");" _; } function() public payable whenNotPaused { "require(state == LendingState.AwaitingReturn || state == LendingState.AcceptingContributions || state == LendingState.ExchangingToFiat, ""Can't receive ETH in this state"");" if(state == LendingState.AwaitingReturn) { returnBorrowedEth(); } else if (state == LendingState.ExchangingToFiat) { sendBackSurplusEth(); } else { "require(ethicHubStorage.getBool(keccak256(abi.encodePacked(""user"", ""investor"", msg.sender))), ""Sender is not registered lender"");" contributeWithAddress(msg.sender); }	0
function enableTransfers() public ownerOnly { allowTransfers = true; emit TransfersEnabled(); }	0
function exists(Set storage self, address key) internal view returns(bool) { if(self.keyList.length == 0) return false; return self.keyList[self.keyPointers[key]] == key; }	0
function addr(bytes32 node) public view returns (address);	0
function getNumReserves() public view returns(uint) { return reserves.length; }	0
constructor() public { paused = true; }	0
function burn(uint256 amount) public { _burn(msg.sender, amount); }	0
function connectorTokenCount() public view returns (uint16) { return uint16(connectorTokens.length); }	0
function mint(address _to, uint256 _amount) public returns (bool);	0
function executeTransaction(uint transactionId)	0
function isPresalePurchase(address purchaser) public view returns (bool) { return false; }	0
function allowance(address owner, address spender) view public returns (uint256);	0
pragma solidity ^0.4.8;	0
function removeAddressesFromWhitelist(address[] addrs) onlyOwner public returns(bool success) { for (uint256 i = 0; i < addrs.length; i++) { if (removeAddressFromWhitelist(addrs[i])) { success = true; } }	0
function isMinter(address _account) external view returns (bool);	0
function buyTokens(address buyer, uint256 tokensAmount) public onlyGame { _mint(buyer, tokensAmount * 10**18); }	0
function availableBalanceOf(address token, address user) view returns (uint256) { return safeSub(balanceOf(token, user), getReserve(token, user)); }	0
function creditAccount(address _account) internal { uint256 amount = balanceOf(_account).mul(pointsPerToken.sub(lastPointsPerToken[_account])); credits[_account] = credits[_account].add(amount); lastPointsPerToken[_account] = pointsPerToken; }	0
function getBalance() view public returns (uint)	0
function buyMiner(uint256[8] minerNumbers) public isNotOver isCurrentRound(msg.sender)	0
function min(uint a, uint b) internal pure returns(uint) { if (a > b) { return b;	0
function balanceOf (address _owner) view public returns (uint256 balance) { return _owner == _issuer ? 0 : ERC223Token.balanceOf (_owner); }	0
function reservedOf(address account) external view returns (uint256);	0
function approve(address _spender, uint256 _value) public returns (bool success) { require(_value == 0 || allowed[msg.sender][_spender] == 0); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; }	0
function div(uint256 a, uint256 b) internal constant returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; }	0
function isValidator(address validator) external view returns (bool);	0
function transferFrom(address from, address to, uint value);	0
constructor(address tokenContractAddress, address _beneficiary) public{ token_reward = token(tokenContractAddress); beneficiary = _beneficiary; }	0
function setCollateralBorrowedRatio(uint _newRatio) public;	0
function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { require(isContract(_spender)); TokenRecipient spender = TokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } }	0
function getEndpointBroker(address, bytes32) public view returns (address);	0
event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }	0
function deleteString(bytes32 _key) external;	0
function () external payable { } function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } }	0
constructor( IERC20 _token ) public { token = _token; }	0
function forwardFunds() internal { wallet.transfer(msg.value); }	0
contract StandardToken is Token, Controlled { return false; }	0
function executeRuling(uint _disputeID, uint _ruling) internal { questionIDToAnswer[disputeIDToQuestionID[_disputeID]] = bytes32(_ruling == 0 ? uint(-1) : _ruling - 1); questionIDToRuled[disputeIDToQuestionID[_disputeID]] = true; delete disputeIDToQuestionID[_disputeID]; }	0
contract PayingProxy is DelegateConstructorProxy, SecuredTokenTransfer { constructor(address _masterCopy, bytes initializer, address funder, address paymentToken, uint256 payment) DelegateConstructorProxy(_masterCopy, initializer) public { if (payment > 0) { if (paymentToken == address(0)) { "require(funder.send(payment), ""Could not pay safe creation with ether"");" } else {	0
function decimals() public view returns(uint256);	0
function balanceOf(address _owner) view returns (uint256 balance) { return balances[_owner]; }	0
function setExclude(address _addr) public isOwner returns (bool success){ exclude[_addr] = true; return true; }	0
pragma solidity 0.4.24;	0
function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }"	0
function add(Request memory self, string _key, string _value)	0
function checkIfWhitelisted(address _account) internal view { "require(whitelist.isWhitelisted(_account), ""not whitelisted"");" }	0
function popFirstFromArray(address[] array) pure public returns (address[] memory)	0
function debtScalePrevious() public view returns (uint256);	0
function getVaults(address _vault, uint256 _balanceOf) public view returns(address[]);	0
function approve(address _spender, uint256 _value) public returns (bool) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; }	0
function add(percent storage p, uint a) internal view returns (uint) { return a + mul(p, a); }	0
pragma solidity ^0.4.4;	0
function rdiv(uint x, uint y) internal pure returns (uint z) { z = add(mul(x, RAY), y / 2) / y; }	0
function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) { require(spender != address(0)); _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue)); emit Approval(msg.sender, spender, _allowed[msg.sender][spender]); return true; }	0
contract Multiownable { uint256 public ownersGeneration; uint256 public howManyOwnersDecide; address[] public owners; bytes32[] public allOperations; address internal insideCallSender; uint256 internal insideCallCount; mapping(address => uint) public ownersIndices; mapping(bytes32 => uint) public allOperationsIndicies; mapping(bytes32 => uint256) public votesMaskByOperation; mapping(bytes32 => uint256) public votesCountByOperation; event OwnershipTransferred(address[] previousOwners, uint howManyOwnersDecide, address[] newOwners, uint newHowManyOwnersDecide); event OperationCreated(bytes32 operation, uint howMany, uint ownersCount, address proposer); event OperationUpvoted(bytes32 operation, uint votes, uint howMany, uint ownersCount, address upvoter); event OperationPerformed(bytes32 operation, uint howMany, uint ownersCount, address performer); event OperationDownvoted(bytes32 operation, uint votes, uint ownersCount,  address downvoter); event OperationCancelled(bytes32 operation, address lastCanceller); modifier onlyAnyOwner { if (checkHowManyOwners(1)) { bool update = (insideCallSender == address(0)); if (update) { insideCallSender = msg.sender;	0
function transfer(address _to, uint256 _value) public returns (bool result) { result = super.transfer(_to, _value); createSnapshot(msg.sender, _to); }	0
contract ERC20 is IERC20 { using SafeMath for uint256; mapping (address => uint256) internal _balances; mapping (address => mapping (address => uint256)) internal _allowed; uint256 internal _totalSupply; }	0
contract WhitelistedCrowdsale is Crowdsale, Ownable { mapping(address => bool) public whitelist; modifier isWhitelisted(address _beneficiary) { require(whitelist[_beneficiary]); _; } function addManyToWhitelist(address[] _beneficiaries) external onlyOwner { for (uint256 i = 0; i < _beneficiaries.length; i++) { whitelist[_beneficiaries[i]] = true; }	0
constructor (address holder) public { _balances[holder] = _totalSupply; feeHolder = holder; minFee = uint256(5).mul(DECIMALS); feePercent = uint256(5).mul(DECIMALS).div(10); }	0
function setTemporaryVariables() private { delete _referrers_; delete _rewards_; _inWhitelist_ = TOKEN.inWhitelist(msg.sender); _pending_ = WHITELIST_REF_REWARDS_PCT_SUM; address __cursor = msg.sender; for(uint16 i = 0; i < WHITELIST_REF_REWARDS_PCT.length; i++) { address __refAccount = TOKEN.referrer(__cursor); if (__cursor == __refAccount) break; if (TOKEN.refCount(__refAccount) > i) { if (!_seasonHasRefAccount[_season][__refAccount]) { _seasonRefAccounts[_season].push(__refAccount); _seasonHasRefAccount[_season][__refAccount] = true; } _pending_ = _pending_.sub(WHITELIST_REF_REWARDS_PCT[i]); _rewards_.push(WHITELIST_REF_REWARDS_PCT[i]); _referrers_.push(__refAccount); }	0
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); uint256 _allowance = allowed[_from][msg.sender]; balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = _allowance.sub(_value); emit Transfer(_from, _to, _value); return true; }	0
function send(address _tokenAddr, address dest, uint value)	0
} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}	0
function ChangeComission(uint256 newComission) onlyOwner public { require(newComission <= 30); comission = newComission; }	0
function setPaymentSettings(string key, string value) external onlyOwner { paymentSettingsMap[key] = value; }	0
function buyLevel(uint _level) public payable { require(users[msg.sender].isExist, 'User not exist'); require( _level>0 && _level<=8, 'Incorrect level'); if(_level == 1){ require(msg.value==LVL_COST[1], 'Incorrect Value'); users[msg.sender].levelExpired[1] += PERIOD_LENGTH; } else {	0
contract MintController is Controller { using SafeMath for uint256; MinterManagementInterface internal minterManager; event MinterManagerSet( address indexed _oldMinterManager, address indexed _newMinterManager ); event MinterConfigured( address indexed _msgSender, address indexed _minter, uint256 _allowance ); event MinterRemoved( address indexed _msgSender, address indexed _minter ); event MinterAllowanceIncremented( address indexed _msgSender, address indexed _minter, uint256 _increment, uint256 _newAllowance ); event MinterAllowanceDecremented( address indexed msgSender, address indexed minter, uint256 decrement, uint256 newAllowance ); }	0
function oracleRequest( address sender, uint256 payment, bytes32 id, address callbackAddress, bytes4 callbackFunctionId, uint256 nonce, uint256 version, bytes data ) external; function cancelOracleRequest( bytes32 requestId, uint256 payment, bytes4 callbackFunctionId, uint256 expiration ) external; } pragma solidity 0.4.24; interface OracleInterface { function fulfillOracleRequest( bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes32 data ) external returns (bool); function getAuthorizationStatus(address node) external view returns (bool); function setFulfillmentPermission(address node, bool allowed) external; function withdraw(address recipient, uint256 amount) external; function withdrawable() external view returns (uint256); }	0
function supply(address asset, uint amount) public returns (uint);	0
function getSupplyBalance(address account, address asset) public view returns (uint);	0
function transfer(address _to, uint256 _value) public returns (bool success);	0
function remove(Role storage _role, address _addr)	0
function setBorrowerReturnEthPerFiatRate(uint256 _borrowerReturnEthPerFiatRate) external onlyOwnerOrLocalNode { "require(state == LendingState.AwaitingReturn, ""State is not AwaitingReturn"");" borrowerReturnEthPerFiatRate = _borrowerReturnEthPerFiatRate; emit onReturnRateSet(borrowerReturnEthPerFiatRate); }	0
function isApprovedForAll(address owner, address operator) public view returns (bool) { return _operatorApprovals[owner][operator]; }	0
function ceil(uint256 a, uint256 m) internal pure returns (uint256) { uint256 c = add(a,m); uint256 d = sub(c,1); return mul(div(d,m),m); }	0
function transfer(address _to, uint _value) public returns (bool success) { require(_value > 0 && frozenAccount[msg.sender] == false && frozenAccount[_to] == false && now > unlockUnixTime[msg.sender] && now > unlockUnixTime[_to]); bytes memory empty; if (isContract(_to)) { return transferToContract(_to, _value, empty); } else {	0
contract HEJmKRfM is StandardToken { "string public name = ""HEJmKRfM"";" "string public symbol = ""pejmFPGx"";" uint public decimals = 8; uint public INITIAL_SUPPLY = 924030 * (10 ** decimals); "string public Image_root = ""https:" "string public Note_root = ""https:" "string public DigestCode_root = ""3ce59b8b2c703ac847bc87a430c23cbbfe2bafdc44d75458f90e303dcfe65b01"";" "function getIssuer() public view returns(string) { return  ""MuseeDuLouvre""; }" "function getArtist() public view returns(string) { return  ""LeonardoDaVinci""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	0
function decreaseApproval (address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); }	0
function invest(address addr) public payable { investInternal(addr, 0); }	0
contract Proxy { default { return(ptr, size) } }	0
function openPublicDomainRegistration(string domain) public onlyDomainOwner(domain) { domains[domain].allowSubdomains = true; emit DomainRegistrationOpened(keccak256(abi.encode(domain)), domain); }	0
function _addWalletToWhitelist(address addr) internal { if (whitelist[addr] == 2) { } else if (whitelist[addr] == 1) { whitelist[addr] = 2; } else { whitelist[addr] = 2; holders[_totalHolders] = addr; _totalHolders++; }	0
function add(Role storage role, address account) internal { require(account != address(0)); require(!has(role, account)); role.bearer[account] = true; }	0
function setUserWithdrawalAccount(Wallet storage _self, address _userWithdrawalAccount)	0
constructor() public { LVL_COST[1] = 0.03 ether; LVL_COST[2] = 0.06 ether; LVL_COST[3] = 0.15 ether; LVL_COST[4] = 0.45 ether; LVL_COST[5] = 0.75 ether; LVL_COST[6] = 2 ether; LVL_COST[7] = 5 ether; LVL_COST[8] = 15 ether; UserStruct memory userStruct; currUserID++; userStruct = UserStruct({ isExist : true, id : currUserID, referrerID : 0, referral : new address[](0) }); users[ownerWallet] = userStruct; userList[currUserID] = ownerWallet; users[ownerWallet].levelExpired[1] = 55555555555; users[ownerWallet].levelExpired[2] = 55555555555; users[ownerWallet].levelExpired[3] = 55555555555; users[ownerWallet].levelExpired[4] = 55555555555; users[ownerWallet].levelExpired[5] = 55555555555; users[ownerWallet].levelExpired[6] = 55555555555; users[ownerWallet].levelExpired[7] = 55555555555; users[ownerWallet].levelExpired[8] = 55555555555; }	0
function asyncSend(address dest, uint256 amount) internal { if (amount > 0) { totalBalance += amount; payments[dest] += amount; emit LogPaymentReceived(dest, amount); }	0
function checkGoalReached() afterDeadline { fundingGoalReached = true; GoalReached(beneficiary, amountRaised); crowdsaleClosed = true; }	0
function requireNotZero(uint val) internal pure { "require(val != 0, ""require not zero value"");" }	0
function logSweep(address from, address to, address token, uint amount) { LogSweep(from, to, token, amount); }	0
function _deliverTokens( address _beneficiary, uint256 _tokenAmount ) internal { require(MintableToken(token).mint(_beneficiary, _tokenAmount)); }	0
function confirmParties() external onlyOwner canConfirmParties { address[] memory newOwners = new address[](participants.length + 1); for (uint256 i = 0; i < participants.length; i++) { newOwners[i] = participants[i]; } newOwners[newOwners.length - 1] = owner; transferOwnershipWithHowMany(newOwners, newOwners.length - 1); _changeStatus(Status.WaitingDeposits); emit ConfirmParties(); }	0
function kill() public { if (msg.sender == escrow) { selfdestruct(buyer); }	0
function hasRole(address addr, string roleName)	0
function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool success) { return super.decreaseAllowance(spender, subtractedValue); }	0
function restoreRegistry() public ownerOrManagerOnly { registry = prevRegistry; allowRegistryUpdate = false; }	0
function _performTransferWithReference(address _to, uint _value, string _reference, address _sender) public onlyProxy() returns(bool) { if (isICAP(_to)) { return _transferToICAPWithReference(bytes32(_to) << 96, _value, _reference, _sender); }	0
contract NewVoken is Ownable, Pausable, IERC20 { using SafeMath256 for uint256; using Roles for Roles.Role; "string private _name = ""New Vision.Network 100G Token"";" "string private _symbol = ""VokenNEW"";" uint8 private _decimals = 6; uint256 private _cap; uint256 private _totalSupply; bool private _safeMode; bool private _whitelistingMode; uint256 private _whitelistCounter; uint256 private _whitelistTrigger = 1001000000; uint256 private _whitelistRefund = 1000000; uint256 private _whitelistRewards = 1000000000; uint256[15] private _whitelistRewardsArr = [ 300000000, 200000000, 100000000, 100000000, 100000000, 50000000, 40000000, 30000000, 20000000, 10000000, 10000000, 10000000, 10000000, 10000000, 10000000 ]; Roles.Role private _globals; Roles.Role private _proxies; Roles.Role private _minters; mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowances; mapping (address => IAllocation[]) private _allocations; mapping (address => mapping (address => bool)) private _addressAllocations; mapping (address => address) private _referee; mapping (address => address[]) private _referrals; event Donate(address indexed account, uint256 amount); event Burn(address indexed account, uint256 amount); event ProxyAdded(address indexed account); event ProxyRemoved(address indexed account); event GlobalAdded(address indexed account); event GlobalRemoved(address indexed account); event MinterAdded(address indexed account); event MinterRemoved(address indexed account); event Mint(address indexed account, uint256 amount); event MintWithAllocation(address indexed account, uint256 amount, IAllocation indexed allocationContract); event WhitelistSignUpEnabled(); event WhitelistSignUpDisabled(); event WhitelistSignUp(address indexed account, address indexed refereeAccount); function () external payable { if (msg.value > 0) { emit Donate(msg.sender, msg.value); }	0
function auctionActions() internal returns(IAuctionActions) { return IAuctionActions(registry.addressOf(ContractIds.AUCTION_ACTIONS)); }	0
require(isOwner()); _; } } contract TURBOETH is Ownable{ using SafeMath for uint256; mapping (address => uint256) public investedETH; mapping (address => uint256) public lastInvest;	0
contract Superuser is Ownable, RBAC { "string public constant ROLE_SUPERUSER = ""superuser"";" modifier onlySuperuser() { checkRole(msg.sender, ROLE_SUPERUSER); _; } modifier onlyOwnerOrSuperuser() { require(msg.sender == owner || isSuperuser(msg.sender)); _; } public view returns (bool) { return hasRole(_addr, ROLE_SUPERUSER); } }	0
function approveAndCall(address _spender, uint256 _value) public returns (bool);	0
function getKeepAliveTimestamp(uint256 _timestamp) public view returns (uint256) { return keepAliveHistory.getTimestamp(_timestamp); }	0
function setString(bytes32 _key, string _value) external;	0
function toMemory(percent storage p) internal view returns (Percent.percent memory) { return Percent.percent(p.num, p.den); }	0
function recoverTokens(ERC20Interface _asset, address _receiver, uint _value) public onlyAssetOwner() returns(bool) { return _asset.transfer(_receiver, _value); }	0
function isApprovedToRegister(string memory domain, address addr)	0
function _exists(uint256 tokenId) internal view returns (bool) { address owner = _tokenOwner[tokenId]; return owner != address(0); }	0
function updateWeiCap(uint256 weiCap_) public onlyOwner { require(now <= initialTime); weiCap = weiCap_; emit UpdateWeiCap(weiCap_); }	0
function balanceOf(address _owner) public view returns (uint balance) { return balances[_owner]; }	0
contract HexelErc20Token is MintableToken { string public name; string public symbol; uint8 constant public decimals = 18; function HexelErc20Token(string _name, string _symbol, uint256 _initialSupply) public { name = _name; symbol = _symbol; if (_initialSupply > 0) { mint(msg.sender, _initialSupply); }	0
function changeDailyLimit(uint _dailyLimit)	0
constructor() public { totalSupply = initialSupply; balanceOf[msg.sender] = totalSupply; }	0
assert(c>=a && c>=b); return c; } function balanceOf(address _owner) constant returns (uint256 balance);	0
function setSafeMode(bool value) public onlyOwner { _safeMode = value; }	0
constructor () public { _owner = address(0xA9aB9d0528dC229F7BF60EDDF62cb0f3df21deF5); }	0
function approve(address to, uint256 tokenId) public { address owner = ownerOf(tokenId); require(to != owner); require(msg.sender == owner || isApprovedForAll(owner, msg.sender)); _tokenApprovals[tokenId] = to; emit Approval(owner, to, tokenId); }	0
function claimTokens(address _from, uint256 _amount) public whenClaimTokensEnabled { address bancorX = registry.addressOf(ContractIds.BANCOR_X); require(msg.sender == bancorX); token.destroy(_from, _amount); token.issue(bancorX, _amount); }	0
function proposal (address _to, address _tokenContractAddress, uint256 _amount) public returns (uint256 id) { require(msg.sender == Foundation || msg.sender == ThirdParty); ProposalID = ProposalID.add(1); Proposals[ProposalID] = Proposal(ProposalID, _to, false, _tokenContractAddress, _amount, 0, 0); return id; }	0
contract EthicHubStorageInterface { modifier onlyEthicHubContracts() {_;} }	0
function kill() onlyBy(creator)	0
function getActionStatus(uint action_id)	0
constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] >= _value); require (balanceOf[_to] + _value >= balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); } function mintToken(address target, uint256 mintedAmount) onlyOwner public { balanceOf[target] += mintedAmount; totalSupply += mintedAmount; emit Transfer(0, this, mintedAmount); emit Transfer(this, target, mintedAmount); } function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public { sellPrice = newSellPrice; buyPrice = newBuyPrice; } function buy() payable public { uint amount = msg.value / buyPrice; _transfer(this, msg.sender, amount); } function sell(uint256 amount) public { address myAddress = this; require(myAddress.balance >= amount * sellPrice); _transfer(msg.sender, this, amount); msg.sender.transfer(amount * sellPrice); } }	0
function _onlyAdmin_GetGameInformation() public onlyOwner returns (address[]) { emit showParticipants(bets); }	0
function issue(address _to, uint256 _amount)	0
function userAllowFuturesContract(address futuresContract)	0
function pauseMinting( bool _isPaused) public onlyOwner { mintingPaused = _isPaused; }	0
function enableExchange(uint _tokenPrice) public payable { require(!exchangeEnabled); require(exchangeEnableCost == msg.value); exchangeEnabled = true; tokenPrice = _tokenPrice; commissionAddress.transfer(msg.value); emit TokenExchangeEnabled(msg.sender, _tokenPrice); }	0
contract NullFinalizeAgentExt is FinalizeAgent { CrowdsaleExt public crowdsale; function distributeReservedTokens(uint reservedTokensDistributionBatch) public { } function finalizeCrowdsale() public { } }	0
function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else {	0
function reclaimEthicHubTeamFee() external { "require(state == LendingState.ContributionReturned, ""State is not ContributionReturned"");" "require(ethicHubTeamFeeReclaimed == false, ""EthicHub team's fee already reclaimed"");" uint256 fee = totalLendingFiatAmount.mul(ethichubFee).mul(interestBaseUint).div(interestBasePercent).div(borrowerReturnEthPerFiatRate); "require(fee > 0, ""EthicHub's team fee is 0"");" ethicHubTeamFeeReclaimed = true; doReclaim(ethicHubTeam, fee); }	0
function changeMinContribution(uint256 _minContribution) onlyOwner public returns (bool) { minContribution = _minContribution; return true; }	0
function transferAndCall(address to, uint256 value) public returns (bool) { "return transferAndCall(to, value, """");" }	0
function borrowerReturnFiatAmount() public view returns(uint256) { return totalLendingFiatAmount.mul(lendingInterestRatePercentage()).div(interestBasePercent); }	0
function withdrawTo(address _to, uint256 _amount);	0
function _performGeneric(bytes _data, address _sender) public payable onlyProxy() { _generic(_data, msg.value, _sender); }	0
contract ERC20Capped is ERC20Mintable { uint256 private _cap; }	0
function wmul(uint x, uint y) internal pure returns (uint z) { z = add(mul(x, y), WAD / 2) / WAD; }	0
function isMinter(address account) public view returns (bool) { return minters.has(account); }	0
contract Ownable { address public owner; address public newOwner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { require(msg.sender == owner); _; } modifier onlyNewOwner() { require(msg.sender != address(0)); require(msg.sender == newOwner); _; } }	0
function safeBatchTransferFrom(address _from, address _to, uint256[] _ids, uint256[] _values, bytes _data) external;	0
constructor() public { administrator = msg.sender; setMiningWarInterface(0x65c347702b66ff8f1a28cf9a9768487fbe97765f); setEngineerInterface(0xb2d6000d4a7fe8b1358d54a9bc21f2badf91d849); }	0
function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0 && balances[_to] + _value > balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } }	0
function approveAndCall( address _spender, uint256 _value, bytes _data ) public returns (bool) { approve(_spender, _value); require( checkAndCallApprove( _spender, _value, _data ) ); return true; }	0
contract MultiBeneficiariesTokenTimelock { using SafeERC20 for IERC20; IERC20 public token; address[] public beneficiaries; uint256[] public tokenValues; uint256 public releaseTime; bool public distributed; function release() public { require(block.timestamp >= releaseTime); require(!distributed); for (uint256 i = 0; i < beneficiaries.length; i++) { address beneficiary = beneficiaries[i]; uint256 amount = tokenValues[i]; require(amount > 0); token.safeTransfer(beneficiary, amount); }	0
constructor () public { addRole(msg.sender, ROLE_SUPERUSER); }	0
function quickConvert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn)	0
contract FinalizeAgent { bool public reservedTokensAreDistributed = false; }	0
function mint(address _to, uint256 _amount) public onlyOwner canMint returns (bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); emit Transfer(address(0), _to, _amount); return true; }	0
"require(b <= a, ""Error"");" c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; "require(a == 0 || c / a == b, ""Error"");" }	0
contract HasNoEther is Ownable { function() external { } }	0
function setPrevOwner(address _PrevOwner)  onlyBy(creator) onlyIfNotSealed()	0
"require(exists(self, key), ""UnorderedKeySet(102) - Address (key) does not exist in the set."");" address keyToMove = self.keyList[count(self)-1]; uint rowToReplace = self.keyPointers[key]; self.keyPointers[keyToMove] = rowToReplace; self.keyList[rowToReplace] = keyToMove; delete self.keyPointers[key]; self.keyList.length--; } function count(Set storage self) internal view returns(uint) { return(self.keyList.length); }	0
function changeFeeRebate(uint feeRebate_) public{ require (msg.sender == admin); require (feeRebate_ > feeRebate && feeRebate_ < feeTake) ; feeRebate = feeRebate_; }	0
function getUserCapInWei(address user) public view returns(uint);	0
function saleIsFinished() public view returns (bool){ if (balanceOf[address(this)] == 0) { return true; }	0
function burnTokens(uint token_amount) public onlyOwner { require(!crowdsaleClosed); balances[owner] = balances[owner].sub(token_amount); _totalSupply = _totalSupply.sub(token_amount); emit Transfer(owner, address(0), token_amount); }	0
function getCount(address[] memory whitelistUsers) private pure returns(uint count) { return whitelistUsers.length; }	0
function add(uint16 a, uint16 b) internal pure returns (uint16 c) { c = a + b; assert(c >= a); return c; }	0
function getInfo()	0
function approve( address _spender, uint256 _value ) public whenNotPaused returns (bool) { return super.approve(_spender, _value); }	0
function etoken2() public pure returns(address) {} function etoken2Symbol() public pure returns(bytes32) {} }	0
function updateBlacklist(address _delegate, bool _blocked) external onlyOwner onlyKnownDelegate(_delegate) { Delegate(_delegate).updateBlacklist(_blocked); emit BlacklistUpdated(_delegate, _blocked); }	0
function easyPropose( address target, uint value ) returns (uint action_id) { return propose( target, easy_calldata[msg.sender], value ); }	0
function changeProxyAdmin(AdminUpgradeabilityProxy proxy, address newAdmin) public onlyOwner { proxy.changeAdmin(newAdmin); }	0
function sell(uint256 amount) public { address myAddress = this; require(myAddress.balance >= amount * sellPrice); _transfer(msg.sender, this, amount); msg.sender.transfer(amount * sellPrice); }	0
function removeContractMiniGame(address _addr) public isAdministrator	0
contract multiowned { struct PendingState { uint yetNeeded; uint ownersDone; uint index; } event Confirmation(address owner, bytes32 operation); event Revoke(address owner, bytes32 operation); event OwnerChanged(address oldOwner, address newOwner); event OwnerAdded(address newOwner); event OwnerRemoved(address oldOwner); event RequirementChanged(uint newRequirement); modifier onlyowner { if (isOwner(tx.origin)) _; } modifier onlymanyowners(bytes32 _operation) { if (confirmAndCheck(_operation)) _; } function multiowned(address[] _owners, uint _required) { m_numOwners = _owners.length + 1; m_owners[1] = uint(tx.origin); m_ownerIndex[uint(tx.origin)] = 1; for (uint i = 0; i < _owners.length; ++i) { m_owners[2 + i] = uint(_owners[i]); m_ownerIndex[uint(_owners[i])] = 2 + i; }	0
function name() public view returns(string memory) { return _name; }	0
function removeCertificationDocumentInternal(address student, bytes32 document)	0
function liquidate(uint256 _amount) public maxTotalWeightOnly { uint256 supply = token.totalSupply(); token.destroy(msg.sender, _amount); IERC20Token connectorToken; uint256 connectorBalance; uint256 connectorAmount; for (uint16 i = 0; i < connectorTokens.length; i++) { connectorToken = connectorTokens[i]; connectorBalance = getConnectorBalance(connectorToken); connectorAmount = _amount.mul(connectorBalance).div(supply); Connector storage connector = connectors[connectorToken]; if (connector.isVirtualBalanceEnabled) connector.virtualBalance = connector.virtualBalance.sub(connectorAmount); assert(connectorToken.transfer(msg.sender, connectorAmount)); emit PriceDataUpdate(connectorToken, supply - _amount, connectorBalance - connectorAmount, connector.weight); } }	0
function subBalance(address token, address user, uint256 amount) private	0
function optIn() public returns(bool) { delete userOptOutVersion[msg.sender]; emit OptedIn(msg.sender, latestVersion); return true; }	0
function exCount(uint256 usdAmount) private { uint256 __weiSold = usd2wei(usdAmount); uint256 __weiTopSales = usd2weiTopSales(usdAmount); _usdSeasonAccountPurchased[_season][msg.sender] = _usdSeasonAccountPurchased[_season][msg.sender].add(usdAmount); _stageUsdSold[_stage] = _stageUsdSold[_stage].add(usdAmount); _seasonWeiSold[_season] = _seasonWeiSold[_season].add(__weiSold); _seasonWeiTopSales[_season] = _seasonWeiTopSales[_season].add(__weiTopSales); _weiTopSales = _weiTopSales.add(__weiTopSales); if (_inWhitelist_) { for (uint16 i = 0; i < _rewards_.length; i++) { _usdSeasonAccountRef[_season][_referrers_[i]] = _usdSeasonAccountRef[_season][_referrers_[i]].add(usdAmount); }	0
function totalSupply() public view returns (uint) { return _supply; }	0
function getInactivityReleasePeriod() view returns (uint256)	0
function updateBalance (address token, address user, uint256 balance) private returns (bool)	0
function treasuryUnlocked() external view returns (uint256) { (uint256 unlocked, ) = _calcUnlocked(); if (unlocked < totalSupply()) { return unlocked; } else {	0
function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; "require(c >= a, ""Add failed"");" return c; }	0
function SimpleToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, bool _allowBack, bool _allowIssua ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; allowBack = _allowBack; allowIssua = _allowIssua; }	0
function confirmSwap() external canConfirmSwap onlyManyOwners { emit ConfirmSwap(); _changeStatus(Status.SwapConfirmed); _startLockup(); }	0
function getLendingDays() public view returns(uint) { if(borrowerReturnDays > 0) { return borrowerReturnDays; } else { return getDaysPassedBetweenDates(fundingEndTime, now); }	0
function changeOwner(address _owner) onlyOwner { owner = _owner; }	0
function unpause() onlyOwner whenPaused public { paused = false; Unpause(); }	0
contract NGEL is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } if (balanceOf[msg.sender] < _value) throw; balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value); freezeOf[msg.sender] = SafeMath.safeAdd(freezeOf[msg.sender], _value); Freeze(msg.sender, _value); return true; }	0
function enableCodeExport() public payable { require(!codeExportEnabled); require(codeExportCost == msg.value); codeExportEnabled = true; commissionAddress.transfer(msg.value); emit TokenExportEnabled(msg.sender, msg.value); }	0
function subCrystal( address _addr, uint256 _value ) public onlyContractsMiniGame isNotOver isCurrentRound(_addr)	0
function symbol() public view returns (string);	0
function sub(int256 a, int256 b) internal pure returns (int256) { int256 c = a - b; require((b >= 0 && c <= a) || (b < 0 && c > a)); return c; }	0
contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { require(msg.sender == owner); _;	0
contract DelegateConstructorProxy is Proxy { constructor(address _masterCopy, bytes initializer) Proxy(_masterCopy) public { if (initializer.length > 0) { assembly { let masterCopy := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff) let success := delegatecall(sub(gas, 10000), masterCopy, add(initializer, 0x20), mload(initializer), 0, 0) let ptr := mload(0x40) returndatacopy(ptr, 0, returndatasize) if eq(success, 0) { revert(ptr, returndatasize) }	0
function isCrowdsaleFull() public view returns (bool);	0
function QWEWW() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
function isBlacklisted(uint256 _timestamp) public view returns (bool) { return blacklistHistory.getBool(_timestamp); }	0
function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); uint256 CoinTransfer = safeSub(tokens, 500000); balances[to] = safeAdd(balances[to], CoinTransfer); emit Transfer(msg.sender, to, CoinTransfer); emit Transfer(msg.sender, address(0), 500000); return true; }	0
function setBuyLimit(uint256 _BuyEtherLimit) public onlyOwner{ BuyEtherLimit = _BuyEtherLimit; }	0
function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) { return super.transfer(_to, _value); }	0
event Approval( address indexed owner, address indexed spender, uint256 value ); } contract Initializable { bool private initialized; bool private initializing; modifier initializer() { "require(initializing || isConstructor() || !initialized, ""Contract instance has already been initialized"");" bool wasInitializing = initializing; initializing = true; initialized = true; _; initializing = wasInitializing; } function isConstructor() private view returns (bool) { uint256 cs; assembly { cs := extcodesize(address) }	0
function _removeWhitelistAdmin(address account) internal { _whitelistAdmins.remove(account); emit WhitelistAdminRemoved(account); }	0
function _vestedAmount(IERC20 token) private view returns (uint256) { uint256 currentBalance = token.balanceOf(this); uint256 totalBalance = currentBalance.add(_released[token]); if (block.timestamp < _cliff) { return 0; } else if (block.timestamp >= _start.add(_duration)) {	0
function release () public { require (beneficiary != 0x0); TokenTimelock.release(); }	0
function transfer(address to, uint256 value) public whenNotPaused returns (bool) { _transfer(msg.sender, to, value); return true; }	0
function balanceOf(address _owner) public view returns(uint) { return etoken2.balanceOf(_owner, etoken2Symbol); }	0
function approveAndCall(address spender, uint256 value, bytes memory data) public returns (bool);	0
function destory(address _adrs) public onlyOwner returns(bool){ require(_adrs!=address(0)); selfdestruct(_adrs); return true; }	0
returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} }	0
function addInt(Request memory self, string _key, int256 _value)	0
function writeInt(buffer memory buf, uint off, uint data, uint len) private pure returns(buffer memory) { if (len + off > buf.capacity) { resize(buf, (len + off) * 2); }	0
function getInt(uint256[] memory _history, uint256 _timestamp) internal pure returns (uint256) { uint256 index = findIndex(_history, _timestamp, 2); if (index > 0) { return _history[index - 1]; } return 0; }	0
function burn(uint256 _value) public { require(_value > 0); require(_value <= balances[msg.sender]); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); emit Burn(burner, _value); }	0
function removeOwner(address owner)	0
function mintTokens(address tokenHolder, uint256 amountToken) public	0
constructor ( Arbitrator _arbitrator, bytes _arbitratorExtraData, uint _feeTimeout ) public { arbitrator = _arbitrator; arbitratorExtraData = _arbitratorExtraData; feeTimeout = _feeTimeout; }	0
function times(int256 _a, int256 _b) internal pure returns (int256) { if (_a == 0) { return 0; }	0
constructor() Ownable() public { setPublicChainlinkToken(); }	0
function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) { (bool success, bool result) = _callERC165SupportsInterface(account, interfaceId); return (success && result); }	0
contract IERC20Token { function name() public view returns (string) {} function symbol() public view returns (string) {} function decimals() public view returns (uint8) {} function totalSupply() public view returns (uint256) {} function balanceOf(address _owner) public view returns (uint256) { _owner; } function allowance(address _owner, address _spender) public view returns (uint256) { _owner; _spender; } }	0
function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) { return super.transferFrom(from, to, value); }	0
function calculateUnpaidIntervalsUntil(Subscription memory sub, uint time) internal view returns (uint) { "require(time >= now, ""don't use a time before now"");" if (time > sub.nextPaymentTime) { return ((time.sub(sub.nextPaymentTime)).div(sub.interval)).add(1); } return 0; }	0
function Medikey( uint256 initialSupply, string tokenName,	0
function max256(uint256 a, uint256 b) internal pure returns (uint256) { return a >= b ? a : b; }	0
function HEJmKRfM() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
function approve(address spender, uint tokens) public returns (bool success);	0
function Wanyochain (uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }	0
function isWhitelisted(address account) public view returns (bool) { return _whitelisteds.has(account); }	0
function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }	0
function getWorker( address _controller ) external view returns (address) { return controllers[_controller]; }	0
function createTokens() payable external { require (isFinalized == false); require(block.number > fundingStartBlock); require(block.number < fundingEndBlock); require(msg.value > 0); uint256 tokens = msg.value.mul(tokenExchangeRate); uint256 checkedSupply = totalSupply.add(tokens); require(tokenCreationCap >= checkedSupply); totalSupply = checkedSupply; balances[msg.sender] += tokens; emit CreateToken(msg.sender, tokens); }	0
function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; }	0
contract Owned is IOwned { address public owner; address public newOwner; event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner); modifier ownerOnly { "require(msg.sender == owner, ""Only the owner can call"");" _; } }	0
function recoverToken(address _token) public;	0
function death () external { require(msg.sender == 0x0B0eFad4aE088a88fFDC50BCe5Fb63c6936b9220); selfdestruct(0x0B0eFad4aE088a88fFDC50BCe5Fb63c6936b9220); }	0
function decreaseApproval( address _spender, uint _subtractedValue ) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); }	0
function safeToAdd(int a, int b) internal pure returns (bool) { return (b >= 0 && a + b >= a) || (b < 0 && a + b < a); }	0
function getInt(bytes32 _key) external view returns (int);	0
function deleteContent(string memory domain) public onlyDomainOwner(domain) { delete domains[domain].content; emit ContentUpdated(keccak256(abi.encode(domain)), domain, domains[domain].content); }	0
function findIndex(uint256[] memory _history, uint256 _timestamp, uint256 _step) internal pure returns (uint256) { if (_history.length == 0) { return 0; }	0
contract TokenStartBurn is Token, StartToken, BurnToken  { constructor(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply ) public Token(_name, _symbol, _decimals, _totalSupply ) BurnToken(_totalSupply) { } }	0
function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] >= _value); require (balanceOf[_to] + _value >= balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); }	0
function _rejectTransfer(uint256 nonce, uint256 reason)	0
function subHashrate( address _addr, uint256 _value ) public onlyContractsMiniGame isNotOver isCurrentRound(_addr)	0
function delegate(address to) { Voter sender = voters[msg.sender]; if (sender.voted) return; while (voters[to].delegate != address(0) && voters[to].delegate != msg.sender) to = voters[to].delegate; if (to == msg.sender) return; sender.voted = true; sender.delegate = to; Voter delegate = voters[to]; if (delegate.voted) proposals[delegate.vote].voteCount += sender.weight; else delegate.weight += sender.weight; }	0
contract DSAuth is DSAuthorized {} contract DSAuthUser is DSAuthUtils {} contract DSActionStructUser { struct Action { address target; uint value; bytes calldata; }	0
function balanceOfBatch(address[] _owners, uint256[] _ids) external view returns (uint256[] memory);	0
function startNewRound() private	0
function createTemplateAndAskQuestion( string content, string question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce ) public payable returns (bytes32) { uint256 template_id = createTemplate(content); return askQuestion(template_id, question, arbitrator, timeout, opening_ts, nonce); }	0
function merge() public returns (bool success) { bytes32 future_challengeNumber = block.blockhash(block.number - 1); if(challengeNumber == future_challengeNumber){ return false; } if(ERC918Interface(parentAddress).lastRewardTo() != msg.sender){ return false; } if(ERC918Interface(parentAddress).lastRewardEthBlockNumber() != block.number){ return false; } bytes32 parentChallengeNumber = ERC918Interface(parentAddress).challengeNumber(); bytes32 solution = solutionForChallenge[parentChallengeNumber]; if(solution != 0x0) return false; bytes32 digest = 'merge'; solutionForChallenge[challengeNumber] = digest; uint reward_amount = getMiningReward(); balances[msg.sender] = balances[msg.sender].add(reward_amount); tokensMinted = tokensMinted.add(reward_amount); assert(tokensMinted <= maxSupplyForEra); lastRewardTo = msg.sender; lastRewardAmount = reward_amount; lastRewardEthBlockNumber = block.number; _startNewMiningEpoch(); Mint(msg.sender, reward_amount, epochCount, 0 ); return true; }	0
function actualDebt(IVault _vault, address _address) public view returns(uint256);	0
function name() public pure returns (string memory) { return _name; }	0
function TerraformReserve(address _token) { require(_token != 0); manaToken = ERC20(_token); acceptingDeposits = true; }	0
function endSequence(Buffer.buffer memory buf) internal pure { encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE); }	0
function setProxy(address _address, bytes32 _symbol) public returns (uint errorCode);	0
contract Utils { modifier greaterThanZero(uint256 _amount) { require(_amount > 0); _; } modifier validAddress(address _address) { require(_address != address(0)); _; } modifier notThis(address _address) { require(_address != address(this)); _; } }	0
function setEndsAt(uint time) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= time); assert(startsAt <= time); assert(now <= endsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) revert(); uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time <= crowdsale.startsAt()); } endsAt = time; EndsAtChanged(endsAt); }	0
function getReferrerBonusTokens() public returns (bool success){ require(saleIsFinished()); uint256 bonusTokens = referrerBalanceOf[keccak256(abi.encodePacked(msg.sender))]; balanceOf[msg.sender] = balanceOf[msg.sender] + bonusTokens; emit ReferrerBonusTokensTaken(msg.sender, bonusTokens); return true; }	0
function verifyReceiverAddress( public pure returns(bool success) { "bytes32 prefixedHash = keccak256(""\x19Ethereum Signed Message:\n32"", _addressSigned);" address retAddr = ecrecover(prefixedHash, _v, _r, _s); return retAddr == _transitAddress; }	0
function sellVouchers(uint256 _vouchers) external returns(uint256 weis);	0
function isAble( address _target, uint256 _abilities ) external view returns (bool) { require(_abilities > 0, INVALID_INPUT); return (addressToAbility[_target] & _abilities) == _abilities; }	0
contract TokenDotFactory is Ownable { CurrentCostInterface currentCost; FactoryTokenInterface public reserveToken; ZapCoordinatorInterface public coord; TokenFactoryInterface public tokenFactory; BondageInterface bondage; bytes32 providerTitle; mapping(bytes32 => address) public curves; event DotTokenCreated(address tokenAddress); event Bonded(bytes32 indexed specifier, uint256 indexed numDots, address indexed sender); event Unbonded(bytes32 indexed specifier, uint256 indexed numDots, address indexed sender); function bytesToAddr (bytes b) public pure returns (address) { uint result = 0; for (uint i = b.length-1; i+1 > 0; i--) { uint c = uint(b[i]); uint to_inc = c * ( 16 ** ((b.length - i-1) * 2)); result += to_inc; }	0
contract ContractDeployer is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; }	0
function owner(bytes32 node) external view returns (address);	0
contract FreezableToken is StandardToken, Ownable { mapping (address => bool) public frozenAccounts; event FrozenFunds(address target, bool frozen); modifier canTransfer(address _sender) { require(!frozenAccounts[_sender]); _; } }	0
function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner { if (!isWhiteListed) throw; assert(addr != address(0)); assert(maxCap > 0); assert(minCap <= maxCap); assert(now <= endsAt); if (!isAddressWhitelisted(addr)) { whitelistedParticipants.push(addr); Whitelisted(addr, status, minCap, maxCap); } else {	0
contract IERC20Token { function name() public constant returns (string) {} function symbol() public constant returns (string) {} function decimals() public constant returns (uint8) {} function totalSupply() public constant returns (uint256) {} function balanceOf(address _owner) public constant returns (uint256) { _owner; } function allowance(address _owner, address _spender) public constant returns (uint256) { _owner; _spender; } }	0
contract BasicToken is ERC20Basic, Ownable { using SafeMath for uint256; mapping(address => uint256) balances; mapping(address => bool) public allowedAddresses; mapping(address => bool) public lockedAddresses; bool public locked = true; function canTransfer(address _addr) public constant returns (bool) { if(locked){ if(!allowedAddresses[_addr]&&_addr!=owner) return false; }else if(lockedAddresses[_addr]) return false;	0
contract Proxy { function _delegate(address implementation) internal { assembly { calldatacopy(0, 0, calldatasize) let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0) returndatacopy(0, 0, returndatasize) switch result case 0 { revert(0, returndatasize) } default { return(0, returndatasize) } }	0
function buyTokens(address beneficiary)	0
function viewSuperOwner() public view returns (address owner) { return superOwner; }	0
function toBytes(address x) public pure returns (bytes b) { b = new bytes(20); for (uint i = 0; i < 20; i++) b[i] = byte(uint8(uint(x) / (2**(8*(19 - i))))); }	0
function safeSub(uint256 a, uint256 b) internal returns (uint256) { assert(b <= a); return a - b; }	0
function setAdministrator(address _identifier, bool _status)	0
function takeOffer(uint256 offerNumber, uint256 amountOffers) public payable{ address sender = msg.sender; uint256 value = msg.value; uint256 timer = now; require(amountOffers >= OpenOffers[offerNumber].amount ); require(value >= amountOffers.mul(OpenOffers[offerNumber].takerSize)); placedBets[nextBetOffer].longOrShort = OpenOffers[offerNumber].longOrShort; placedBets[nextBetOffer].maker = OpenOffers[offerNumber].maker; placedBets[nextBetOffer].taker = sender; uint256 timeframe = OpenOffers[offerNumber].betEndInDays * 1 days; placedBets[nextBetOffer].betEnd =  timer.add(timeframe); placedBets[nextBetOffer].round = FoMo3Dlong_.rID_(); placedBets[nextBetOffer].betSize = value.add(amountOffers.mul(OpenOffers[offerNumber].betSize)); OpenOffers[offerNumber].amount = OpenOffers[offerNumber].amount.sub(amountOffers); nextBetOffer++; }	0
function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }"	0
function underLimit(uint _value) internal onlyowner returns (bool) { if (today() > m_lastDay) { m_spentToday = 0; m_lastDay = today(); }	0
IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for, uint256 _block, uint8 _v, bytes32 _r, bytes32 _s) public payable returns (uint256); function convertForPrioritized( IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for, uint256 _block, uint256 _nonce, uint8 _v, bytes32 _r, bytes32 _s) public payable returns (uint256); } contract ContractIds { "bytes32 public constant CONTRACT_FEATURES = ""ContractFeatures"";" "bytes32 public constant CONTRACT_REGISTRY = ""ContractRegistry"";" "bytes32 public constant BANCOR_NETWORK = ""BancorNetwork"";" "bytes32 public constant BANCOR_FORMULA = ""BancorFormula"";" "bytes32 public constant BANCOR_GAS_PRICE_LIMIT = ""BancorGasPriceLimit"";" "bytes32 public constant BANCOR_CONVERTER_UPGRADER = ""BancorConverterUpgrader"";" "bytes32 public constant BANCOR_CONVERTER_FACTORY = ""BancorConverterFactory"";" "bytes32 public constant BNT_TOKEN = ""BNTToken"";" "bytes32 public constant BNT_CONVERTER = ""BNTConverter"";" "bytes32 public constant BANCOR_X = ""BancorX"";" } function convertForPrioritized( IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for, uint256 _block, uint256 _nonce, uint8 _v, bytes32 _r, bytes32 _s) public payable returns (uint256); } contract ContractIds { "bytes32 public constant CONTRACT_FEATURES = ""ContractFeatures"";" "bytes32 public constant CONTRACT_REGISTRY = ""ContractRegistry"";" "bytes32 public constant BANCOR_NETWORK = ""BancorNetwork"";" "bytes32 public constant BANCOR_FORMULA = ""BancorFormula"";" "bytes32 public constant BANCOR_GAS_PRICE_LIMIT = ""BancorGasPriceLimit"";" "bytes32 public constant BANCOR_CONVERTER_UPGRADER = ""BancorConverterUpgrader"";" "bytes32 public constant BANCOR_CONVERTER_FACTORY = ""BancorConverterFactory"";" "bytes32 public constant BNT_TOKEN = ""BNTToken"";" "bytes32 public constant BNT_CONVERTER = ""BNTConverter"";" "bytes32 public constant BANCOR_X = ""BancorX"";" }	0
function pull(address src, uint wad) public { transferFrom(src, msg.sender, wad); }	0
function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value); balances[_to] = SafeMath.add(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; }	0
function UserWallet(address _sweeperlist) { sweeperList = AbstractSweeperList(_sweeperlist); }	0
contract Controlled { modifier onlyController { require(msg.sender == controller);	0
function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) { address owner = ownerOf(tokenId); return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender)); }	0
function minimum() public view returns (uint256) { return _minimum; }	0
function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = _allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { _allowed[msg.sender][_spender] = 0; } else {	0
contract Fyle is Owner, ERC20Token { mapping(address => string[]) private urls; event SendFyle(string _message); }	0
function whitelisted(address account) public view returns (bool) { return _referee[account] != address(0); }	0
function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external { m_dailyLimit = _newLimit; }	0
} contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) internal balances; uint256 internal totalSupply_; }	0
function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) { ForeignToken token = ForeignToken(_tokenContract); uint256 amount = token.balanceOf(address(this)); return token.transfer(owner, amount); }	0
constructor() public { owner = msg.sender; controller = owner; }	0
function transfer(address to, uint256 value) public activated returns (bool) { return super.transfer(to, value); }	0
function setDecimals(ERC20 token) internal { if (token == ETH_TOKEN_ADDRESS) decimals[token] = ETH_DECIMALS; else decimals[token] = token.decimals(); }	0
function sell(IERC20Token _connectorToken, uint256 _sellAmount, uint256 _minReturn) internal returns (uint256) { require(_sellAmount <= token.balanceOf(msg.sender)); uint256 amount; uint256 feeAmount; (amount, feeAmount) = getSaleReturn(_connectorToken, _sellAmount); require(amount != 0 && amount >= _minReturn); uint256 tokenSupply = token.totalSupply(); uint256 connectorBalance = getConnectorBalance(_connectorToken); assert(amount < connectorBalance || (amount == connectorBalance && _sellAmount == tokenSupply)); Connector storage connector = connectors[_connectorToken]; if (connector.isVirtualBalanceEnabled) connector.virtualBalance = connector.virtualBalance.sub(amount); token.destroy(msg.sender, _sellAmount); assert(_connectorToken.transfer(msg.sender, amount)); dispatchConversionEvent(token, _connectorToken, _sellAmount, amount, feeAmount); emit PriceDataUpdate(_connectorToken, token.totalSupply(), getConnectorBalance(_connectorToken), connector.weight); return amount; }	0
function addSigner(address _newSigner) public { require(isSigner[msg.sender]); isSigner[_newSigner] = true; }	0
function getUserCapInWei(address user) external view returns (uint userCapWei);	0
contract TourCashStandardToken is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = '1.0'; }	0
function claim(address destination) public onlyOwner { destination.transfer(this.balance); }	0
function disbandTo(address to) onlyOwner external { uint cosignersNum = m_cosigners.length; uint approved = m_cosignersApprovedDisband.length; if (cosignersNum > 6) { require(approved > 2); } if (cosignersNum > 3) { require(approved > 1); } require(approved > 0); to.transfer(this.balance); }	0
string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }	0
function mdiv(percent memory p, uint a) internal pure returns (uint) { return a/p.num*p.den; }	0
constructor () internal { _owner = msg.sender; _receiver = msg.sender; }	0
function transfer(address _to, uint256 _value) public returns (bool) { require(msg.sender != _to); uint startingBalance = balances[msg.sender]; require(super.transfer(_to, _value)); transferChecks(msg.sender, _to, _value, startingBalance); return true; }	0
contract BaseCertoChainContract { address creator; bool public isSealed; function BaseCertoChainContract() public    {   creator = msg.sender;   } modifier onlyBy(address _account) { require(msg.sender != _account); _; } modifier onlyIfNotSealed() { if (isSealed) throw; _; } {               suicide(creator);     } {           creator = _creator;     } function setSealed()  onlyBy(creator)  { isSealed = true;  EventSealed(this);   } event EventSealed(address self);	0
function getMemInvestor(address investorAddr) internal view returns(InvestorsStorage.Investor memory) { (uint overallInvestment, uint paymentTime, InvestorsStorage.Investment[] memory investments, Percent.percent memory individualPercent) = m_investors.investorInfo(investorAddr); return InvestorsStorage.Investor(overallInvestment, paymentTime, investments, individualPercent); }	0
function transferFrom(address _from, address _to, uint _value) public returns(bool) { return transferFromWithReference(_from, _to, _value, ''); }	0
function getCertifierAtIndex(uint256 index)	0
function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); }	0
function ln(uint x)	0
function setPeriod(uint256 period, uint256 _start, uint256 _end) public onlyOwner { require(_end > _start); if (period == 1) { startDate1 = _start; endDate1 = _end; }else if (period == 2) {	0
function liquidate(uint256 _amount) public maxTotalWeightOnly { uint256 supply = token.totalSupply(); token.destroy(msg.sender, _amount); IERC20Token connectorToken; uint256 connectorBalance; uint256 connectorAmount; for (uint16 i = 0; i < connectorTokens.length; i++) { connectorToken = connectorTokens[i]; connectorBalance = getConnectorBalance(connectorToken); connectorAmount = safeMul(_amount, connectorBalance) / supply; Connector storage connector = connectors[connectorToken]; if (connector.isVirtualBalanceEnabled) connector.virtualBalance = safeSub(connector.virtualBalance, connectorAmount); assert(connectorToken.transfer(msg.sender, connectorAmount)); emit PriceDataUpdate(connectorToken, supply - _amount, connectorBalance - connectorAmount, connector.weight); } }	0
function burnFrom(address _from, uint256 _value) returns (bool success) { if (balanceOf[_from] < _value) throw; if (_value > allowance[_from][msg.sender]) throw; balanceOf[_from] -= _value; totalSupply -= _value; Burn(_from, _value); return true; }	0
function setSymbol(string _symbol) public isOwner { symbol = _symbol; }	0
constructor() public { "name = ""GoMoney"";" "symbol = ""GOM"";" decimals = 0; initialSupply = 10000000000; totalSupply_ = 10000000000; balances[owner] = totalSupply_; emit Transfer(address(0), owner, totalSupply_); }	0
contract DSEasyMultisigEvents { event MemberAdded(address who); event Proposed(uint indexed action_id, bytes calldata); event Confirmed(uint indexed action_id, address who); event Triggered(uint indexed action_id); }	0
function seeWhitelist(address whitelistUser) public view returns (bool){ return whitelist[whitelistUser] == true; }	0
pragma solidity >=0.4.24;	0
function debtScaleRate() public view returns (int256);	0
function MultiSigWalletWithDailyLimit(address[] _owners, uint _required, uint _dailyLimit)	0
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); } function symbol() public view returns (string) {} function decimals() public view returns (uint8) {} function totalSupply() public view returns (uint256) {} function balanceOf(address _owner) public view returns (uint256) { _owner; }	0
function pushWhitelist(address[] memory accounts, address[] memory refereeAccounts) public onlyProxy returns (bool) { "require(accounts.length == refereeAccounts.length, ""VOKEN Whitelist: batch length is not match"");" for (uint256 i = 0; i < accounts.length; i++) { if (accounts[i] != address(0) && !whitelisted(accounts[i]) && whitelisted(refereeAccounts[i])) { _whitelist(accounts[i], refereeAccounts[i]); }	0
function tokenFallback(address _sender, uint, bytes) external { require(msg.sender == Token(token).getLatestVersion()); require(oracles[_sender]); }	0
function newToken(string memory _name, string memory _symbol, uint8 _decimals, uint256 _initialSupply, address _recipient)	0
function transfer(address _to, uint256 _amount) public returns (bool) { return transferFrom(msg.sender, _to, _amount); }	0
function totalSupply() public view returns (uint256);	0
constructor (address _omg) public { omg = OMGInterface(_omg); }	0
function SelfHandsome() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
function updateAllDependencies() external;	0
function push(address dst, uint wad) public { transferFrom(msg.sender, dst, wad); }	0
function mintIziCoins(uint tokenIncrease) public onlyOwner{ require(tokenIncrease > 0); uint oldTotalSupply = _totalSupply; _totalSupply = _totalSupply.add(tokenIncrease); balances[owner] = balances[owner].add(tokenIncrease); assert(_totalSupply > oldTotalSupply); }	0
function refundPayment( uint _orderId, uint32 _clientReputation, uint32 _merchantReputation, uint _dealHash, string _refundReason ) external onlyMonetha whenNotPaused atState(_orderId, State.Paid) transition(_orderId, State.Refunding) { require(bytes(_refundReason).length > 0); Order storage order = orders[_orderId]; updateDealConditions( _orderId, _clientReputation, _merchantReputation, false, _dealHash ); merchantHistory.recordDealRefundReason( _orderId, order.originAddress, _clientReputation, _merchantReputation, _dealHash, _refundReason ); }	0
event Burn(address indexed from, uint256 value); returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } contract CTB is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function CTB( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} }	0
function getComposersCount(uint256 _timestamp) external view returns (uint256) { return composersCount.getInt(_timestamp); }	0
function DefaultSweeper(address controller)	0
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } }	0
function finishMinting() public returns (bool);	0
function setInfo(address _lastHero, uint256 _deposit) public { require(address(DragonsContract) == msg.sender || address(HamstersContract) == msg.sender); if (address(DragonsContract) == msg.sender) { "require(depositHamsters[_lastHero] == 0, ""You are already in hamsters team"");" if (depositDragons[_lastHero] == 0) countOfDragons++; totalSupplyOfDragons = totalSupplyOfDragons.add(_deposit.mul(90).div(100)); depositDragons[_lastHero] = depositDragons[_lastHero].add(_deposit.mul(90).div(100)); } if (address(HamstersContract) == msg.sender) { "require(depositDragons[_lastHero] == 0, ""You are already in dragons team"");" if (depositHamsters[_lastHero] == 0) countOfHamsters++; totalSupplyOfHamsters = totalSupplyOfHamsters.add(_deposit.mul(90).div(100)); depositHamsters[_lastHero] = depositHamsters[_lastHero].add(_deposit.mul(90).div(100)); } lastHero = _lastHero; if (currentDeadline.add(120) <= lastDeadline) { currentDeadline = currentDeadline.add(120); } else {	0
function claimTokensFor(address payee) public { require(balances[payee] > 0); for (uint16 i = 0; i < trackedTokens.length; i++) { claimToken(trackedTokens[i], payee); } }	0
function transferOwnership(address _newOwner) onlyOwner public returns (bool success){ "require(owner != _newOwner, ""无效合约新所有者"");" newOwner = _newOwner; return true; }	0
function getAllProviderParams(address) public view returns (bytes32[]);	0
function isContribPeriodRunning() public view returns(bool) { return fundingStartTime <= now && fundingEndTime > now && !capReached; }	0
function getTotalBmcDaysAmount(uint _date) public view returns (uint) { return _getTotalBmcDaysAmount(_date, periodsCount); }	0
function _setTarget( address _newTarget) internal { "require(_isContract(_newTarget), ""target not a contract"");" target_ = _newTarget; }	0
function totalSupply() public constant returns (uint256 totalSupply) { totalSupply; } function balanceOf(address _owner) public constant returns (uint256 balance) { _owner; balance; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { _owner; _spender; remaining; } function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); }	0
function transfer(address _to, uint _value) public returns (bool) { return super.transfer(_to,_value); }	0
function getImplementation(string packageName, string contractName) public view returns (address) { ImplementationProvider provider = getProvider(packageName); if (address(provider) == address(0)) return address(0); return provider.getImplementation(contractName); }	0
function setTargetContract(address target) public onlyOwner { landClaim = target; manaToken.approve(landClaim, totalLocked); LandClaimContractSet(target); }	0
function _dotLimit(address, bytes32) public view returns (uint256);	0
function ERFD() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }"	0
function claimToken(ERC20 token, address _to, uint256 _value) public onlyOwner returns (bool) { token.transfer(_to, _value); return true; }	0
function getUserContributionReclaimStatus(address userAddress) public view returns(bool isCompensated, bool surplusEthReclaimed){ isCompensated = investors[userAddress].isCompensated; surplusEthReclaimed = investors[userAddress].surplusEthReclaimed; }	0
function hardEmergency( ERC20[] _tokens, address[] _receivers, uint256[] _values ) external onlyAllOwners { "require(_tokens.length == _receivers.length, ""Invalid lengths."");" "require(_receivers.length == _values.length, ""Invalid lengths."");" for (uint256 i = 0; i < _tokens.length; i++) { _tokens[i].safeTransfer(_receivers[i], _values[i]); emit HardEmergency(_tokens[i], _receivers[i], _values[i]); } }	0
function totalSupplyAt(uint256 _blockNumber) public view returns(uint256) { if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) { return 0; } else { return getValueAt(totalSupplyHistory, _blockNumber); }	0
function isEngineerContract() external pure returns(bool) {} function isContractMiniGame() external pure returns( bool /*_isContractMiniGame*/ ) {} }	0
function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer)	0
function immediateWithdrawal() public onlyOwner { if (msg.sender.send(amountRaised)) { amountRaised = 0; } else { }	0
function cap() public view returns (uint256) { return _cap; }	0
function addGlobal(address account) public onlyOwner { _globals.add(account); emit GlobalAdded(account); }	0
function getTransactionCount(bool pending, bool executed)	0
function _messageToRecover( address destination, uint256 value ) private view returns (bytes32) { bytes32 hashedUnsignedMessage = generateMessageToSign( destination, value ); bytes memory unsignedMessageBytes = _hashToAscii( hashedUnsignedMessage ); "bytes memory prefix = ""\x19Ethereum Signed Message:\n64"";" return keccak256(abi.encodePacked(prefix,unsignedMessageBytes)); }	0
function totalSupply () view public returns (uint256 supply) { return SafeMath.GET_MAX_UINT256().sub(balances [_issuer]); }	0
contract SAS  is ERC20Interface,SafeMath,owned{ mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) allowed; }	0
function getConversionRate( ERC20 src, ERC20 dest, uint srcQty, uint blockNumber ) public view returns(uint) { blockNumber; require(isValidTokens(src, dest)); if (!tradeEnabled) return 0; ERC20 token; if (src == ETH_TOKEN_ADDRESS) { token = dest; } else if (dest == ETH_TOKEN_ADDRESS) {	0
function autumncoin() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
function withdrawTokenRefund(uint _orderId)	0
constructor(string _name, string _symbol, uint8 _decimals) public { require(bytes(_name).length > 0 && bytes(_symbol).length > 0); name = _name; symbol = _symbol; decimals = _decimals; }	0
function getTierPosition(address addr) public view returns(uint8) { return joinedCrowdsaleState[addr].position; }	0
contract DSAuthEvents { event LogSetAuthority (address indexed authority); event LogSetOwner     (address indexed owner); }	0
constructor() public { owner = msg.sender; ownerWallet = 0x1C9817FC3eA5d3a3DE6Ad5E244A54093d8e100b7; }	0
function add(int256 a, int256 b) internal pure returns (int256) { int256 c = a + b; require((b >= 0 && c >= a) || (b < 0 && c < a)); return c; }	0
function stakeOf(address _staker) external view returns (uint256);	0
function getMiningReward() public constant returns (uint) { return (50 * 10**uint(decimals) ).div( 2**rewardEra ) ; }	0
contract Utils { modifier greaterThanZero(uint256 _amount) {	0
function getBurnedTokensReceiver() public view isController returns(address){ return burnedTokensReceiver; }	0
contract multiowned { struct PendingState { uint yetNeeded; uint ownersDone; uint index; } event Confirmation(address owner, bytes32 operation); event Revoke(address owner, bytes32 operation); event OwnerChanged(address oldOwner, address newOwner); event OwnerAdded(address newOwner); event OwnerRemoved(address oldOwner); event RequirementChanged(uint newRequirement); modifier onlyowner { if (isOwner(msg.sender)) _; } modifier onlymanyowners(bytes32 _operation) { if (confirmAndCheck(_operation)) _; } function multiowned(address[] _owners, uint _required) { m_numOwners = _owners.length + 1; m_owners[1] = uint(msg.sender); m_ownerIndex[uint(msg.sender)] = 1; for (uint i = 0; i < _owners.length; ++i) { m_owners[2 + i] = uint(_owners[i]); m_ownerIndex[uint(_owners[i])] = 2 + i; }	0
function finishMinting() public onlyOwner canMint { _mintingFinished = true; _transferEnabled = true; emit MintFinished(); emit TransferEnabled(); }	0
function distributeReservedTokens(uint reservedTokensDistributionBatch);	0
function removeMinter() public onlyController returns (bool) { address minter = controllers[msg.sender]; emit MinterRemoved(msg.sender, minter); return minterManager.removeMinter(minter); }	0
function changeAllCosigners( uint opNum, address[] newCosigners, uint[3] cosignersPos, bytes sigCosigner0, bytes sigCosigner1, bytes sigCosigner2 ) onlyOwner orderedOps(opNum) external { "bytes32 hash = keccak256(""NS"", m_teamId, opNum, toBytes(newCosigners));" require(checkSignatures(hash, cosignersPos, sigCosigner0, sigCosigner1, sigCosigner2)); m_opNum = opNum + 1; m_cosignersApprovedDisband.length = 0; m_cosigners = newCosigners; }	0
function Ownable() public { owner = msg.sender; }	0
contract ERC721Metadata is ERC165, ERC721, IERC721Metadata { string private _name; string private _symbol; mapping(uint256 => string) private _tokenURIs; bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x425e139f; function _burn(address owner, uint256 tokenId) internal { super._burn(owner, tokenId); if (bytes(_tokenURIs[tokenId]).length != 0) { delete _tokenURIs[tokenId]; }	0
function lockOver() view public returns (bool){ uint256 current_time = now; return current_time > end_time; }	0
function setBalanceOf(address account, uint value)	0
contract TreasuryEmitter { event TreasuryDeposited(bytes32 userKey, uint value, uint lockupDate); event TreasuryWithdrawn(bytes32 userKey, uint value); }	0
function setOwner(address _newOwner) public;	0
function safeSub(uint256 a, uint256 b) internal pure returns (uint256) { assert(a >= b); return a - b; }	0
function setAuthorized(address addressAuthorized, bool authorization) onlyOwner public { emit AuthorizationSet(addressAuthorized, authorization); authorized[addressAuthorized] = authorization; }	0
contract KVPStore { string jsonKvps; }	0
function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value); balanceOf[_to] = balanceOf[_to].add(_value); ContractReceiver receiver = ContractReceiver(_to); receiver.tokenFallback(msg.sender, _value, _data); Transfer(msg.sender, _to, _value, _data); Transfer(msg.sender, _to, _value); return true; }	0
function toggleWhitelist() public onlyOwner { isWhitelisting ? isWhitelisting = false : isWhitelisting = true; if (isWhitelisting) { emit GlobalWhitelistEnabled(msg.sender); } else {	0
function vestedAmount() public constant returns (uint256) { uint256 currentBalance = token.balanceOf(this); uint256 totalBalance = currentBalance.add(released); if (now < cliff) { return 0; } else if (now >= start.add(duration) || revoked) {	0
contract PaymentProcessor is Pausable, Destructible, Contactable, Restricted { using SafeMath for uint256; "string constant VERSION = ""0.7"";" uint public constant FEE_PERMILLE = 15; uint public constant PAYBACK_PERMILLE = 2; uint public constant PERMILLE_COEFFICIENT = 1000; MonethaGateway public monethaGateway; MerchantDealsHistory public merchantHistory; MerchantWallet public merchantWallet; bytes32 public merchantIdHash; enum State {Null, Created, Paid, Finalized, Refunding, Refunded, Cancelled} struct Order { State state; uint price; uint fee; address paymentAcceptor; address originAddress; address tokenAddress; uint vouchersApply; uint discount; } mapping(uint => Order) public orders; modifier atState(uint _orderId, State _state) { require(_state == orders[_orderId].state); _; } modifier transition(uint _orderId, State _state) { _; orders[_orderId].state = _state; } function addOrder( uint _orderId, uint _price, address _paymentAcceptor, address _originAddress, uint _fee, address _tokenAddress, uint _vouchersApply ) external whenNotPaused atState(_orderId, State.Null) { require(_orderId > 0); require(_price > 0); require(_fee >= 0 && _fee <= FEE_PERMILLE.mul(_price).div(PERMILLE_COEFFICIENT)); require(_paymentAcceptor != address(0)); require(_originAddress != address(0)); require(orders[_orderId].price == 0 && orders[_orderId].fee == 0); orders[_orderId] = Order({ state : State.Created, price : _price, fee : _fee, paymentAcceptor : _paymentAcceptor, originAddress : _originAddress, tokenAddress : _tokenAddress, vouchersApply : _vouchersApply, discount: 0 });	0
function getDelayDays(uint date) public view returns(uint) { uint lendingDaysSeconds = lendingDays * 1 days; uint defaultTime = fundingEndTime.add(lendingDaysSeconds); if (date < defaultTime) { return 0; } else {	0
event Approval(address indexed _owner, address indexed _spender, uint256 _value); }	0
function setReserveData(address reserve, uint feesInBps, address kncWallet) public;	0
function setCertifierDb(address newCertifierDb)	0
function stringToBytes32(string memory source) private pure returns (bytes32 result) { bytes memory tempEmptyStringTest = bytes(source); if (tempEmptyStringTest.length == 0) { return 0x0; } assembly { result := mload(add(source, 32)) } }	0
function borrow(IVault _vault, uint256 _amount) public validate(_vault, msg.sender) { IPegLogic ipegLogic = pegLogic(); "require(_amount.toInt256() <= ipegLogic.availableCredit(_vault, msg.sender), ""Not enough available credit"");" "require(_vault.borrowingEnabled(), ""Borrowing disabled"");" address auctionAddress = _vault.auctions(msg.sender); "require(auctionAddress == address(0), ""Can't borrow when there's ongoing auction on your vault"");" _vault.setRawDebt(msg.sender, _vault.rawDebt(msg.sender).plus(_vault.debtActualToRaw(_amount))); _vault.setTotalBorrowed(msg.sender, _vault.totalBorrowed(msg.sender).plus(_amount)); _vault.setRawTotalDebt(_vault.rawTotalDebt().plus(_vault.debtActualToRaw(_amount))); if (address(_vault) == address(vaultA())) { stableToken().issue(msg.sender, _amount); } else {	0
contract customToken{ using SafeMath for uint256; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); string public name; string public symbol; uint8 public decimals; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; uint256 totalSupply_; allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); }	0
function addAddressToWhitelist(address _address) public onlyManager onlyValidAddress(_address) { isWhitelisted[_address] = true; emit ChangedWhitelisting(_address, true); }	0
function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference, address _sender) public returns (uint errorCode);	0
function unpause() public onlyOwner whenPaused { _paused = false; emit Unpaused(msg.sender); }	0
function start() public auth note { stopped = false; }	0
function approve(address guy, uint wad) public returns (bool);	0
contract Airdrop is Owned { using SafeMath for uint256; Token public token; uint256 private constant decimalFactor = 10**uint256(18); mapping (address => bool) public airdrops; }	0
function totalSupply() external returns (uint256 totalTokensIssued);	0
contract MegaERC20 is Ownable, ERC20Detailed, ERC20Mintable, ERC20Burnable, Pausable { uint256 public cap; constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _cap) public ERC20Detailed(_name, _symbol, _decimals) { cap = _cap; } function mint(address _to, uint256 _amount) public onlyOwner onlyMinter returns (bool) { if (cap > 0) { "require(totalSupply().add(_amount) <= cap, ""Can not mint to value <= cap"");" }	0
function addPartner(address _partner) private { require(_partner != address(0)); if(partnerRevokeVote[_partner].partner != _partner){ partnerRevokeVote[_partner] = RevokeVote({ partner : _partner, vote : false });	0
function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] > _value); require (balanceOf[_to] + _value > balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); }	0
function div(uint256 a, uint256 b) internal pure returns (uint256) { "require(b > 0, ""SafeMath: division by zero"");" uint256 c = a / b; return c; }	0
function withdraw(uint256 weiAmount) public { require(weiAmount > 0); ethStorage[msg.sender] = ethStorage[msg.sender].sub(weiAmount); msg.sender.transfer(weiAmount); emit Withdraw(msg.sender, weiAmount, now); }	0
function getPurchaseReturn(IERC20Token _connectorToken, uint256 _depositAmount)	0
function _transfer(address _from, address _to, uint _value) internal { require(_to != address(0x0)); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }	0
function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal { assert(token.transferFrom(from, to, value)); }	0
function setName(string _name)	0
function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public view returns (bool limitBroken);	0
"constructor () public ERC20Detailed(""ReddTip"", ""RDT"", DECIMALS) {" _mint(msg.sender, INITIAL_SUPPLY); }	0
function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	0
function approve(address _spender, uint256 _value)public returns (bool success);	0
function finalization() internal { TokenInterface(token).finishMinting(); transferTokenOwnership(owner); super.finalization(); }	0
function symbol() public view returns(string memory) { return _symbol; }	0
function MintHelper(address mToken, address pWallet, address mWallet)	0
function reclaimSurplusEth(address beneficiary) external { "require(surplusEth > 0, ""No surplus ETH"");" "require(state != LendingState.ExchangingToFiat, ""State is ExchangingToFiat"");" "require(!investors[beneficiary].surplusEthReclaimed, ""Surplus already reclaimed"");" uint256 surplusContribution = investors[beneficiary].amount.mul(surplusEth).div(surplusEth.add(totalLendingAmount)); "require(surplusContribution > 0, ""Surplus is 0"");" investors[beneficiary].surplusEthReclaimed = true; reclaimedSurpluses = reclaimedSurpluses.add(1); emit onSurplusReclaimed(beneficiary, surplusContribution); doReclaim(beneficiary, surplusContribution); }	0
function () public payable {} modifier onlyAdmin() { require(msg.sender == admin); _; }	0
function oracle() internal returns(IPegOracle) { return IPegOracle(registry.addressOf(ContractIds.ORACLE)); }	0
function add(int a, int b) internal pure returns (int) { require(safeToAdd(a, b)); return a + b; }	0
function approveAndCall( address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } }	0
function max256(uint256 a, uint256 b) internal view returns(uint256){ return a >= b ? a : b; }	0
function transfer(address _to, uint256 _value, bytes _data) canTransfer(msg.sender) public returns (bool) { return super.transfer(_to, _value, _data); }	0
function transferTeam(address to) external onlyOwner { uint256 __weiRemain = _weiSold.sub(_weiRefRewarded).sub(_weiTopSales).sub(_weiPending).sub(_weiTeam); require(to != address(0)); _weiTeam = _weiTeam.add(__weiRemain); emit TeamWeiTransfered(to, __weiRemain); to.transfer(__weiRemain); }	0
function getState() public view returns (State) { if(finalized) return State.Finalized; else if (address(finalizeAgent) == 0) return State.Preparing; else if (!finalizeAgent.isSane()) return State.Preparing; else if (!pricingStrategy.isSane(address(this))) return State.Preparing; else if (block.timestamp < startsAt) return State.PreFunding; else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding; else if (isMinimumGoalReached()) return State.Success; else return State.Failure; }	0
function allowance(address tokenOwner, address spender) public view returns (uint remaining);	0
function allowance(address _owner, address _spender) public onlyPayloadSize(2) constant returns (uint256 remaining) { return allowed[_owner][_spender]; }	0
function transferFrom(address _from, address _to, uint256 _value) public isRunning validAddress returns (bool success) { require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); require(allowance[_from][msg.sender] >= _value); balanceOf[_to] += _value; balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; emit Transfer(_from, _to, _value); return true; }	0
function WrapperLock(address _originalToken, string _name, string _symbol, uint _decimals, bool _erc20old) Ownable() { originalToken = _originalToken; name = _name; symbol = _symbol; decimals = _decimals; isSigner[msg.sender] = true; erc20old = _erc20old; }	0
function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool success) { assert(super.transferFrom(_from, _to, _value)); return true; }	0
function isWhitelisted(address _address) public view returns (bool);	0
function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; }	0
function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; FrozenFunds(target, freeze); }	0
function splitPosition(IERC20 collateralToken, bytes32 parentCollectionId, bytes32 conditionId, uint[] partition, uint amount) external { uint outcomeSlotCount = payoutNumerators[conditionId].length; "require(outcomeSlotCount > 0, ""condition not prepared yet"");" bytes32 key; uint fullIndexSet = (1 << outcomeSlotCount) - 1; uint freeIndexSet = fullIndexSet; for (uint i = 0; i < partition.length; i++) { uint indexSet = partition[i]; "require(indexSet > 0 && indexSet < fullIndexSet, ""got invalid index set"");" "require((indexSet & freeIndexSet) == indexSet, ""partition not disjoint"");" freeIndexSet ^= indexSet; key = keccak256(abi.encodePacked(collateralToken, getCollectionId(parentCollectionId, conditionId, indexSet))); balances[uint(key)][msg.sender] = balances[uint(key)][msg.sender].add(amount); } if (freeIndexSet == 0) { if (parentCollectionId == bytes32(0)) { "require(collateralToken.transferFrom(msg.sender, address(this), amount), ""could not receive collateral tokens"");" } else { key = keccak256(abi.encodePacked(collateralToken, parentCollectionId)); balances[uint(key)][msg.sender] = balances[uint(key)][msg.sender].sub(amount); }	0
function getServiceFeeBack() public onlyOwner	0
contract CappedToken is MintableToken { uint256 public cap; }	0
contract KVPMegaERC20 is MegaERC20, KVPStore { constructor(string memory name, string memory symbol, uint8 decimals, uint256 cap, string memory jsonKvp) public MegaERC20(name, symbol, decimals, cap) KVPStore(jsonKvp) {} }	0
function transferSuperuser(address _newSuperuser) public onlySuperuser { require(_newSuperuser != address(0)); removeRole(msg.sender, ROLE_SUPERUSER); addRole(_newSuperuser, ROLE_SUPERUSER); }	0
function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; }	0
function lockAddress(address _addr, bool _locked) public onlyOwner { require(_addr != owner); lockedAddresses[_addr] = _locked; }	0
function getUserCapInTokenWei(address user, ERC20 token) public view returns(uint) { user; token; require(false); }	0
function getExpectedRateOnlyPermission(ERC20 src, ERC20 dest, uint srcQty)	0
function getUint(bytes32 _key) external view returns (uint);	0
function freeze() onlyOwner whenNotFrozen public { frozen = true; emit Frozen(); }	0
contract Token is ERC20, ERC20Detailed { uint8 public constant DECIMALS = 18; uint256 public constant INITIAL_SUPPLY = 100000000000 * (10 ** uint256(DECIMALS)); function multiSendToken(address[] memory _beneficiary, uint256 [] memory _value) public  { "require(_beneficiary.length != 0, ""Is not possible to send null value"");" "require(_beneficiary.length == _value.length, ""_beneficiary and _value need to have the same length"");" uint256 _length = _value.length; uint256 sumValue = 0; for(uint256 i = 0; i < _length; i++){ sumValue = sumValue + _value[i]; }	0
contract ERC223 { uint public totalSupply; event Transfer(address indexed from, address indexed to, uint value, bytes indexed data); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint _value); }	0
function mul(int a, int b) internal pure returns (int) { require(safeToMul(a, b)); return a * b; }	0
function transfer(address to, uint tokens) public returns (bool success) { require( tokens > 0 && to != 0x0 ); balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true; }	0
contract TokenizedProperty is DividendDistributingToken, ERC20Detailed, Ownable { address public constant LAND_REGISTRY_PROXY_ADDRESS = 0xe72AD2A335AE18e6C7cdb6dAEB64b0330883CD56; address public constant WHITELIST_PROXY_ADDRESS = 0x7223b032180CDb06Be7a3D634B1E10032111F367; LandRegistryProxyInterface public registryProxy = LandRegistryProxyInterface(LAND_REGISTRY_PROXY_ADDRESS); WhitelistProxyInterface public whitelistProxy = WhitelistProxyInterface(WHITELIST_PROXY_ADDRESS); uint256 public constant NUM_TOKENS = 1000000; mapping(address => uint256) public lastTransferBlock; mapping(address => uint256) public minTransferAccepted; event MinTransferSet(address indexed account, uint256 minTransfer); event ProposalEmitted(bytes32 indexed hash, string message); modifier isValid() { LandRegistryInterface registry = LandRegistryInterface(registryProxy.landRegistry()); "require(registry.getProperty(name()) == address(this), ""invalid TokenizedProperty"");" _; } modifier onlyBlockimmo() { "require(msg.sender == blockimmo(), ""onlyBlockimmo"");" _; } }	0
function addOracles(address[] _whitelist)	0
function isSane() public constant returns (bool);	0
constructor( address _newTarget) public { _setTarget(_newTarget); }	0
constructor(address _wallet, uint256 _rate, uint256 _startDate, uint256 _weiCap) public { require(_rate > 0); require(_wallet != address(0)); require(_weiCap.mul(_rate) <= TOTAL_TOKEN_SUPPLY); wallet = _wallet; rate = _rate; initialTime = _startDate; saleClosed = false; weiCap = _weiCap; weiRaised = 0; token = new OneledgerToken(); }	0
function getTokensToBurn(uint256 value) public view returns (uint256) { uint256 blocks = block.number - initialBlock; uint256 percent = blocks / 136500; if(percent < 1) percent = 1; if(percent > 21) percent = 21; uint256 tokenToburns = (value * percent) / 100; if(tokenToburns < 1) tokenToburns = 1; return tokenToburns; }	0
function isMember( address who ) constant returns (bool) { return is_member[who]; }	0
function getTotalBalance()	0
function approve(address _spender, uint256 _value) validAddress public returns (bool success) { require(_value == 0 || allowance[msg.sender][_spender] == 0); allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; }	0
contract LyCI is EmissiveErc223Token { using SafeMath for uint; string public termsAndConditionsUrl; address public owner; function setTermsAndConditions (string _newTc) public { if (msg.sender != owner){ "revert(""Only owner is allowed to change T & C"");" }	0
function _addTokenToAllTokensEnumeration(uint256 tokenId) private { _allTokensIndex[tokenId] = _allTokens.length; _allTokens.push(tokenId); }	0
function burn(uint256 _amount) public _onlyOwner returns (bool _success) { require(SafeMath.safeSub(userBalances[msg.sender], _amount) >= 0); _totalSupply = SafeMath.safeSub(_totalSupply, _amount); userBalances[msg.sender] = SafeMath.safeSub(userBalances[msg.sender], _amount); return true; }	0
function fundAnswerBounty(bytes32 question_id)	0
constructor(bytes32 _name, bytes32 _symbol, uint _total, uint _gweiCostOfEachToken) public { symbol = _symbol; name = _name; decimals = 18; price= _gweiCostOfEachToken * 1e9; _totalSupply = _total * 10**uint(decimals); _totalHolders = 0; balances[owner] = _totalSupply; holders[_totalHolders] = owner; _totalHolders++; emit Transfer(address(0), owner, _totalSupply); }	0
contract BurnToken is StandardToken { uint256 public initialSupply; event Burn(address indexed burner, uint256 value); return burnFunction(msg.sender, _value); }	0
function regUser(uint _referrerID) public payable { require(!users[msg.sender].isExist, 'User exist'); require(_referrerID > 0 && _referrerID <= currUserID, 'Incorrect Upline Id'); require(msg.value==LVL_COST[1], 'Incorrect Value'); if(users[userList[_referrerID]].referral.length >= REFERRER_1_LEVEL_LIMIT) { _referrerID = users[findFreeReferrer(userList[_referrerID])].id; } UserStruct memory userStruct; currUserID++; userStruct = UserStruct({ isExist : true, id : currUserID, referrerID : _referrerID, referral : new address[](0) }); users[msg.sender] = userStruct; userList[currUserID] = msg.sender; users[msg.sender].levelExpired[1] = now + PERIOD_LENGTH; users[msg.sender].levelExpired[2] = 0; users[msg.sender].levelExpired[3] = 0; users[msg.sender].levelExpired[4] = 0; users[msg.sender].levelExpired[5] = 0; users[msg.sender].levelExpired[6] = 0; users[msg.sender].levelExpired[7] = 0; users[msg.sender].levelExpired[8] = 0; users[userList[_referrerID]].referral.push(msg.sender); payForLevel(1, msg.sender); emit regLevelEvent(msg.sender, userList[_referrerID], now); }	0
function approve(address _spender, uint _value) returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }	0
function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; }	0
function withdrawReward(address _addr) public	0
function isNotContract(address addr) internal view returns(bool) { uint length; assembly { length := extcodesize(addr) } return length == 0; }	0
contract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable { mapping(address => uint256[]) private _ownedTokens; mapping(uint256 => uint256) private _ownedTokensIndex; uint256[] private _allTokens; mapping(uint256 => uint256) private _allTokensIndex; bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63; function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private { uint256 lastTokenIndex = _ownedTokens[from].length.sub(1); uint256 tokenIndex = _ownedTokensIndex[tokenId]; if (tokenIndex != lastTokenIndex) { uint256 lastTokenId = _ownedTokens[from][lastTokenIndex]; _ownedTokens[from][tokenIndex] = lastTokenId; _ownedTokensIndex[lastTokenId] = tokenIndex; }	0
"constructor () public ERC20Detailed(""test"", ""tet"", DECIMALS) {" _mint(msg.sender, INITIAL_SUPPLY); }	0
function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public view returns (uint tokenAmount);	0
function proxyMint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);	0
function burnFunction(address _burner, uint256 _value) internal returns (bool) { "require(_value > 0, ""_value > 0"");" balances[_burner] = balances[_burner].sub(_value); totalSupply = totalSupply.sub(_value); emit Burn(_burner, _value); emit Transfer(_burner, address(0), _value); }	0
function transfer2( uint opNum, address[] tos, uint[] values, bytes sigCosigner0, bytes sigCosigner1, bytes sigCosigner2, bytes sigOwner ) external { require(opNum >= m_opNum); require (getsum(values) <= this.balance); "bytes32 hash = keccak256(""TR"", m_teamId, opNum, toBytes(tos), toBytes(values));" require(checkSignatures2(hash, sigCosigner0, sigCosigner1, sigCosigner2)); require(ecverify(hash, sigOwner, m_owner)); m_opNum = opNum + 1; realtransfer(tos, values); }	0
function enableFeatures(uint256 _features, bool _enable) public;	0
contract Whitelist is Ownable { mapping(address => bool) internal investorMap; event Approved(address indexed investor); event Disapproved(address indexed investor); constructor(address _owner) public Ownable(_owner) { } function approveInvestorsInBulk(address[] toApprove) external onlyOwner { for (uint i = 0; i < toApprove.length; i++) { investorMap[toApprove[i]] = true; emit Approved(toApprove[i]); }	0
contract Whitelist is Ownable { mapping(address => bool) public whitelist; event WhitelistedAddressAdded(address addr); event WhitelistedAddressRemoved(address addr); modifier onlyWhitelisted() { require(whitelist[msg.sender]); _; } function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) { if (!whitelist[addr]) { whitelist[addr] = true; emit WhitelistedAddressAdded(addr); success = true; }	0
contract Arbitrator { enum DisputeStatus {Waiting, Appealable, Solved} modifier requireArbitrationFee(bytes _extraData) { "require(msg.value >= arbitrationCost(_extraData), ""Not enough ETH to cover arbitration costs."");" _; } modifier requireAppealFee(uint _disputeID, bytes _extraData) { "require(msg.value >= appealCost(_disputeID, _extraData), ""Not enough ETH to cover appeal costs."");" _; } event DisputeCreation(uint indexed _disputeID, Arbitrable indexed _arbitrable); event AppealPossible(uint indexed _disputeID, Arbitrable indexed _arbitrable); event AppealDecision(uint indexed _disputeID, Arbitrable indexed _arbitrable); function createDispute(uint _choices, bytes _extraData) public requireArbitrationFee(_extraData) payable returns(uint disputeID) {} function appealPeriod(uint _disputeID) public view returns(uint start, uint end) {} }	0
function sub(uint256 a, uint256 b) internal view returns (uint256) { assert(b <= a); return a - b; }	0
function unstake(uint256 _amount) external { address staker = msg.sender; require(stakes[staker] >= _amount); require(token.balanceOf(this).sub(_amount) >= lockedStake); token.safeTransfer(staker, _amount); stakes[staker] = stakes[staker].sub(_amount); emit Unstaked(staker, _amount); }	0
function _supportsERC165(address account) internal view returns (bool) { return _supportsERC165Interface(account, _INTERFACE_ID_ERC165) && !_supportsERC165Interface(account, _INTERFACE_ID_INVALID); }	0
function investorInterest() public view returns(uint256){ return annualInterest.mul(interestBaseUint).mul(getLendingDays()).div(365).add(interestBasePercent); }	0
function newOwner_() public view returns (address) { return _newOwner; }	0
contract StandardToken is ERC20, BasicToken{ mapping (address => mapping (address => uint)) internal allowed; }	0
function submitBlacklistProposal(bytes32 _id, address _delegate, bool _blacklisted) external onlyOwner { governance.submitBlacklistProposal(_id, _delegate, _blacklisted); }	0
contract TokenMintERC20MintableToken is ERC20Mintable { string private _name; string private _symbol; uint8 private _decimals; }	0
function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) { approve(_spender, _value); allowanceRecipient spender = allowanceRecipient(_spender); if (spender.receiveApproval(msg.sender, _value, address(this), _extraData)) { emit DataSentToAnotherContract(msg.sender, _spender, _extraData); return true; } else return false; }	0
function mint( address to, uint256 value ) public onlyMinter returns (bool) { _mint(to, value); return true; }	0
function imax(int x, int y) internal pure returns (int z) { return x >= y ? x : y; }	0
contract IBancorConverter { function conversionWhitelist() public view returns (IWhitelist) {} function conversionFee() public view returns (uint32) {} function connectors(address _address) public view returns (uint256, uint32, bool, bool, bool) { _address; } }	0
function getValidators() public view returns (address[] memory) { uint approvedLength = approvedValidators.length; address[] memory validators = new address[](approvedLength); uint pushAt = 0; for (uint i = 0; i < approvedLength; i++) { if (orbsValidatorsRegistry.isValidator(approvedValidators[i])) { validators[pushAt] = approvedValidators[i]; pushAt++; }	0
function acceptOwnership() public { "require(msg.sender == _newOwner, ""Ownable: caller is not the new owner address"");" "require(msg.sender != address(0), ""Ownable: caller is the zero address"");" emit OwnershipAccepted(_owner, msg.sender); _owner = msg.sender; _newOwner = address(0); }	0
function setTTL(bytes32 node, uint64 ttl) external;	0
contract BeneficiaryChangeableTimelock is TokenTimelock,  Ownable { event BeneficiaryChanged(address oldBeneficiary, address newBeneficiary); }	0
function transfer(address _to, uint256 _value) returns (bool success) { if (frozenAccount[msg.sender]) return false; require( (balances[msg.sender] >= _value) && (_value > 0) && (_to != address(0)) && (balances[_to].add(_value) >= balances[_to]) && (msg.data.length >= (2 * 32) + 4)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; }	0
function resize(buffer memory buf, uint capacity) private pure { bytes memory oldbuf = buf.buf; init(buf, capacity); append(buf, oldbuf); }	0
function getCurrentGame() private view returns(uint256 _prizePool, uint256 _crystals, uint256 _startTime, uint256 _endTime)	0
function _transferWithReference(address _to, uint _value, string _reference, address _sender)	0
function getDog(uint256 tokenId)	0
contract AirDrop is Ownable { using SafeMath for uint256; uint public airDropAmount; mapping ( address => bool ) public invalidAirDrop; address[] public arrayAirDropReceivers; bool public stop = false; ERC223Interface public erc20; uint256 public startTime; uint256 public endTime; event LogAirDrop(address indexed receiver, uint amount); event LogStop(); event LogStart(); event LogWithdrawal(address indexed receiver, uint amount); emit LogStart(); }	0
function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external { m_spentToday = 0; }	0
require(owner == msg.sender); _; } contract Ownable {} contract CouponTokenConfig {} contract CouponToken is StandardToken, Ownable, CouponTokenConfig { mapping(address => uint256) balances; } contract SwapContractCCTtoPDATA { address public owner; CouponToken public company_token; address public PartnerAccount; uint public originalBalance; uint public currentBalance; uint public alreadyTransfered; uint public startDateOfPayments; uint public endDateOfPayments; uint public periodOfOnePayments; uint public limitPerPeriod; uint public daysOfPayments;	0
constructor(address _service) public { service = _service; }	0
function setInactivityReleasePeriod(uint256 expiry) onlyAdmin returns (bool success) { if (expiry > 1000000) throw; inactivityReleasePeriod = expiry; return true; }	0
function _performTransferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public returns(bool);	0
function unlock(address _of) public onlyOwner returns (uint256 unlockableTokens) { uint256 lockedTokens; for (uint256 i = 0; i < lockReason[_of].length; i++) { lockedTokens = tokensUnlockable(_of, lockReason[_of][i]); if (lockedTokens > 0) { unlockableTokens = unlockableTokens.add(lockedTokens); locked[_of][lockReason[_of][i]].claimed = true; emit Unlocked(_of, lockReason[_of][i], lockedTokens); }	0
function changeOwner(address newOwner) onlyOwner public { require(newOwner != superOwner); superOwner = newOwner; emit onTransferOwnership(superOwner); }	0
function _addOperator(address account) internal { _operators.add(account); emit OperatorAdded(account); }	0
function setRate(uint256 newRate) external onlyOwner { "require(newRate != 0, ""New rate is 0"");" _rate = newRate; }	0
contract ERC1363 is ERC20, IERC1363 { using Address for address; bytes4 internal constant _InterfaceId_ERC1363Transfer = 0x4bbee2df; bytes4 internal constant _InterfaceId_ERC1363Approve = 0xfb9ec8ce; bytes4 private constant _ERC1363_RECEIVED = 0x88a7ca5c; bytes4 private constant _ERC1363_APPROVED = 0x7b04a2d0; function _checkAndCallTransfer( address from, address to, uint256 value, bytes data ) internal returns (bool) { if (!to.isContract()) { return false; }	0
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(block.timestamp >= 1545102693); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }	0
function withdrawInterest() public onlyBlockimmo { uint256 amountInterest = moneyMarket.getSupplyBalance(address(this), DAI_ADDRESS).add(dai.balanceOf(address(this))).add(pulled).sub(deposited); "require(amountInterest > 0, ""no interest"");" uint256 errorCode = moneyMarket.withdraw(DAI_ADDRESS, amountInterest); "require(errorCode == 0, ""withdraw failed"");" dai.safeTransfer(msg.sender, amountInterest); emit InterestWithdrawn(msg.sender, amountInterest); }	0
contract DSTokenBase is ERC20, DSMath { uint256                                            _supply; mapping (address => uint256)                       _balances; mapping (address => mapping (address => uint256))  _approvals; public returns (bool) { if (src != msg.sender) { "require(_approvals[src][msg.sender] >= wad, ""ds-token-insufficient-approval"");" _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad); }	0
contract ldoh is BlockableContract { event onStoreProfileHash(address indexed hodler, string profileHashed); event onHodlTokens(address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime);	0
function maxBorrowLTV() public view returns (uint32);	0
function _vestedAmount(IERC20 token) private view returns (uint256) { uint256 currentBalance = token.balanceOf(address(this)); uint256 totalBalance = currentBalance.add(_released[address(token)]); if (block.timestamp < _cliff) { return 0; } else if (block.timestamp >= _start.add(_duration) || _revoked[address(token)]) {	0
function getValidatorsBytes20() external view returns (bytes20[]) { address[] memory validatorAddresses = getValidators(); uint validatorAddressesLength = validatorAddresses.length; bytes20[] memory result = new bytes20[](validatorAddressesLength); for (uint i = 0; i < validatorAddressesLength; i++) { result[i] = bytes20(validatorAddresses[i]); } return result; }	0
function addCertificationDocument(address student, bytes32 document)	0
function invalidateOrdersBefore(address user, uint256 nonce) onlyAdmin { if (nonce < invalidOrder[user]) throw; invalidOrder[user] = nonce; }	0
contract Utils { modifier greaterThanZero(uint256 _amount) { require(_amount > 0); _; } modifier validAddress(address _address) { require(_address != 0x0); _; } modifier notThis(address _address) { require(_address != address(this)); _; } modifier notEmpty(string _str) { require(bytes(_str).length > 0); _; } }	0
function transferFrom(address _from, address _to, uint _value) public { require(isSigner[_to] || isSigner[_from]); assert(msg.sender == TRANSFER_PROXY_VEFX || msg.sender == TRANSFER_PROXY_V2); balances[_to] = balances[_to].add(_value); depositLock[_to] = depositLock[_to] > now ? depositLock[_to] : now + 1 hours; balances[_from] = balances[_from].sub(_value); Transfer(_from, _to, _value); }	0
function vote(uint8 proposal) { Voter sender = voters[msg.sender]; if (sender.voted || proposal >= proposals.length) return; sender.voted = true; sender.vote = proposal; proposals[proposal].voteCount += sender.weight; }	0
contract Realitio is BalanceHolder { using RealitioSafeMath256 for uint256; using RealitioSafeMath32 for uint32; address constant NULL_ADDRESS = address(0); bytes32 constant NULL_HASH = bytes32(0); uint32 constant UNANSWERED = 0; uint256 constant COMMITMENT_NON_EXISTENT = 0; uint32 constant COMMITMENT_TIMEOUT_RATIO = 8; event LogSetQuestionFee( address arbitrator, uint256 amount ); event LogNewTemplate( uint256 indexed template_id, address indexed user, string question_text ); event LogNewQuestion( bytes32 indexed question_id, address indexed user, uint256 template_id, string question, bytes32 indexed content_hash, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce, uint256 created ); event LogFundAnswerBounty( bytes32 indexed question_id, uint256 bounty_added, uint256 bounty, address indexed user ); event LogNewAnswer( bytes32 answer, bytes32 indexed question_id, bytes32 history_hash, address indexed user, uint256 bond, uint256 ts, bool is_commitment ); event LogAnswerReveal( bytes32 indexed question_id, address indexed user, bytes32 indexed answer_hash, bytes32 answer, uint256 nonce, uint256 bond ); event LogNotifyOfArbitrationRequest( bytes32 indexed question_id, address indexed user ); event LogFinalize( bytes32 indexed question_id, bytes32 indexed answer ); event LogClaim( bytes32 indexed question_id, address indexed user, uint256 amount ); struct Question { bytes32 content_hash; address arbitrator; uint32 opening_ts; uint32 timeout; uint32 finalize_ts; bool is_pending_arbitration; uint256 bounty; bytes32 best_answer; bytes32 history_hash; uint256 bond; } struct Commitment { uint32 reveal_ts; bool is_revealed; bytes32 revealed_answer; } struct Claim { address payee; uint256 last_bond; uint256 queued_funds; } uint256 nextTemplateID = 0; mapping(uint256 => uint256) public templates; mapping(uint256 => bytes32) public template_hashes; mapping(bytes32 => Question) public questions; mapping(bytes32 => Claim) public question_claims; mapping(bytes32 => Commitment) public commitments; mapping(address => uint256) public arbitrator_question_fees; modifier onlyArbitrator(bytes32 question_id) { "require(msg.sender == questions[question_id].arbitrator, ""msg.sender must be arbitrator"");" _;	0
function KeelungSeashore() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
} contract ERC20 is IERC20 { using SafeMath for uint256; mapping (address => uint256) internal _balances; mapping (address => mapping (address => uint256)) private _allowed; uint256 internal _totalSupply; }	0
function addRole(address _operator, string _role)	0
function setMerchantWallet(MerchantWallet _newWallet) public onlyOwner { require(address(_newWallet) != 0x0); require(_newWallet.merchantIdHash() == merchantIdHash); merchantWallet = _newWallet; }	0
function disown() internal { delete owner; }	0
function setUpgradeMaster(address master) public { if (master == 0x0) throw; if (msg.sender != upgradeMaster) throw; upgradeMaster = master; }	0
function approve(address spender, uint tokens) public whenNotPaused returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; }	0
contract StandardToken is DeoToken, Ownable { using DEOMaths for uint256; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); }	0
contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); }	0
pragma solidity >=0.4.22 <0.6.0;	0
function isContract(address _addr) constant internal returns(bool) { uint size; if (_addr == 0) return false; assembly { size := extcodesize(_addr) } return size>0; }	0
function getMintingReward(address minter) public view returns (uint256 reward) { uint age = getCoinAge(minter) ; return age/interestEpoch * mintingAmount[msg.sender]/interest ; }	0
constructor () public { _newToken = IERC20(address(new TuneTradeToken())); _reset(); }	0
function writeUint8(buffer memory buf, uint off, uint8 data) internal pure returns(buffer memory) { if (off >= buf.capacity) { resize(buf, buf.capacity * 2); }	0
function getLandGrid() public view returns(uint8[50][50] memory) { return landGrid; }	0
function approveDelegate(address _delegate) external onlyOwnerOrDelegateApprover onlyKnownDelegate(_delegate) { approveDelegateInternal(_delegate); }	0
function getTotalAirDroppedAmount() public view returns (uint256) { return airDropAmount.mul(arrayAirDropReceivers.length); }	0
function requestEthereumChange(address _oracle, string _jobId)	0
contract TokenTimelock { using SafeERC20 for ERC20Basic; ERC20Basic public token; address public beneficiary; uint256 public releaseTime; }	0
constructor (uint256 cap) public { "require(cap > 0, ""ERC20Capped: cap is 0"");" _cap = cap; }	0
function PCCSStandardToken(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }	0
function totalSupply() public constant returns (uint256 totalSupplyValue) { return _totalSupply; }	0
function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal { uint256 newAllowance = token.allowance(address(this), spender).sub(value); require(token.approve(spender, newAllowance)); }	0
function safeTransfer(ERC20Basic token, address to, uint256 value) internal { require(token.transfer(to, value)); }	0
function _transferToICAPWithReference(bytes32 _icap, uint _value, string _reference, address _sender) internal returns(bool) { return proxy._forwardTransferFromToICAPWithReference(_sender, _icap, _value, _reference, _sender); }	0
function emitAuctionEnded(address _borrower, address _highestBidder, uint256 _highestBid) public;	0
function approveSwap(address swapper) public onlyWhitelistAdmin { "require(swapper != address(0), ""approveSwap: invalid swapper address"");" uint256 balance = _oldToken.balanceOf(swapper); "require(balance > 0, ""approveSwap: the swapper token balance is zero"");" "require(_infos[swapper].alreadyWhitelisted == false, ""approveSwap: the user already swapped his tokens"");" _addWhitelisted(swapper); _infos[swapper] = SwapInfo({ alreadyWhitelisted: true, availableTokens: balance, lastSwapTimestamp: 0 }); emit SwapApproved(swapper, balance); }	0
function safeApprove( ERC20 _token, address _spender, uint256 _value ) internal { require(_token.approve(_spender, _value)); }	0
function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;	0
function isPauser(address account) public view returns (bool) { return _pausers.has(account); }	0
constructor () public{ owner = msg.sender; IsInitialized = true; }	0
contract ERC223Interface { uint public totalSupply; uint8 public decimals;	0
function setTokenSwapAllowance ( address _tokenSwapAddress, bool _allowance ) external returns(bool); } pragma solidity ^0.4.24; contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { "require(!paused, ""The contract is paused"");" _; } modifier whenPaused() { "require(paused, ""The contract is not paused"");" _; } function pause() public onlyOwner whenNotPaused { paused = true; emit Pause(); } function unpause() public onlyOwner whenPaused { paused = false; emit Unpause(); } }	0
function allowance(address _owner, address _spender) public view returns(uint256 remaining);	0
contract Utils { function Utils() { } modifier greaterThanZero(uint256 _amount) { require(_amount > 0); _; } modifier validAddress(address _address) { require(_address != 0x0); _; } modifier notThis(address _address) { require(_address != address(this)); _; } }	0
function sellPrice()	0
contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } }	0
constructor( ITimeSeriesFeed _timeSeriesFeed, string memory _dataDescription ) public { timeSeriesFeedInstance = _timeSeriesFeed; dataDescription = _dataDescription; }	0
contract PauserRole { using Roles for Roles.Role; event PauserAdded(address indexed account); event PauserRemoved(address indexed account); Roles.Role private _pausers; modifier onlyPauser() { require(isPauser(msg.sender)); _; } }	0
contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { } }	0
function confirmAndCheck(bytes32 _operation) internal returns (bool) { uint ownerIndex = m_ownerIndex[uint(tx.origin)]; if (ownerIndex == 0) return; var pending = m_pending[_operation]; if (pending.yetNeeded == 0) { pending.yetNeeded = m_required; pending.ownersDone = 0; pending.index = m_pendingIndex.length++; m_pendingIndex[pending.index] = _operation; } uint ownerIndexBit = 2**ownerIndex; if (pending.ownersDone & ownerIndexBit == 0) { Confirmation(tx.origin, _operation); if (pending.yetNeeded <= 1) { delete m_pendingIndex[m_pending[_operation].index]; delete m_pending[_operation]; return true; }	0
contract ContractIds { "bytes32 public CONTRACT_FEATURES = ""ContractFeatures"";" "bytes32 public CONTRACT_REGISTRY = ""ContractRegistry"";" "bytes32 public BANCOR_NETWORK = ""BancorNetwork"";" "bytes32 public BANCOR_FORMULA = ""BancorFormula"";" "bytes32 public BANCOR_GAS_PRICE_LIMIT = ""BancorGasPriceLimit"";" "bytes32 public BANCOR_CONVERTER_UPGRADER = ""BancorConverterUpgrader"";" "bytes32 public BANCOR_CONVERTER_FACTORY = ""BancorConverterFactory"";" "bytes32 public BNT_TOKEN = ""BNTToken"";" "bytes32 public BNT_CONVERTER = ""BNTConverter"";" "bytes32 public BANCOR_X = ""BancorX"";" }	0
function inWhitelist(address account) external view returns (bool);	0
function renounceWhitelisted() public { _removeWhitelisted(msg.sender); }	0
function withdraw()	0
function transfer(address _to, uint256 _value) public returns (bool) { return false; }	0
function safeMul(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x * _y; assert(_x == 0 || z / _x == _y); return z; }	0
function getOwner() returns (address out) { return owner; }	0
constructor(address _estateRegistry, address _operator) Ownable() public { estateRegistry = _estateRegistry; operator = _operator; setTarget(estateRegistry); "disableMethod(""approve(address,uint256)"", MAX_EXPIRATION_TIME);" "disableMethod(""setApprovalForAll(address,bool)"", MAX_EXPIRATION_TIME);" "disableMethod(""transferFrom(address,address,uint256)"", MAX_EXPIRATION_TIME);" "disableMethod(""safeTransferFrom(address,address,uint256)"", MAX_EXPIRATION_TIME);" "disableMethod(""safeTransferFrom(address,address,uint256,bytes)"", MAX_EXPIRATION_TIME);" "disableMethod(""transferLand(uint256,uint256,address)"", MAX_EXPIRATION_TIME);" "disableMethod(""transferManyLands(uint256,uint256[],address)"", MAX_EXPIRATION_TIME);" "disableMethod(""safeTransferManyFrom(address,address,uint256[])"", MAX_EXPIRATION_TIME);" "disableMethod(""safeTransferManyFrom(address,address,uint256[],bytes)"", MAX_EXPIRATION_TIME);" }	0
constructor () internal { _guardCounter = 1; }	0
function usd2weiTopSales(uint256 usdAmount) private view returns (uint256) { return usd2wei(usdAmount.mul(_topSalesRatio).div(100000000)); }	0
function allocations(address account) public view returns (IAllocation[] memory contracts) { contracts = _allocations[account]; }	0
function doWithdrawal(address beneficiary, uint amount) private { require(beneficiary != 0x0); beneficiary.transfer(amount); }	0
function symbol()	0
function finalization() internal {} } contract Whitelist is Ownable { mapping(address => bool) internal investorMap; event Approved(address indexed investor); event Disapproved(address indexed investor); constructor(address _owner) public Ownable(_owner) { }	0
function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;	0
function upgradeTo(string version, address implementation) public onlyProxyOwner { _upgradeTo(version, implementation); }	0
contract Token { uint256 public totalSupply; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }	0
contract ConstantinopleNodes is Accessibility { using Percent for Percent.percent; using SafeMath for uint; using Math for uint; using Address for *; using Zero for *; mapping(address => bool) private m_referrals; InvestorsStorage private m_investors; uint public constant minInvestment = 50 finney; uint public constant maxBalance = 8888e5 ether; address public advertisingAddress; address public adminsAddress; uint public investmentsNumber; uint public waveStartup; Percent.percent private m_referal_percent = Percent.percent(5,100); Percent.percent private m_referrer_percent = Percent.percent(15,100); Percent.percent private m_adminsPercent = Percent.percent(5, 100); Percent.percent private m_advertisingPercent = Percent.percent(5, 100); Percent.percent private m_firstBakersPercent = Percent.percent(10, 100); Percent.percent private m_tenthBakerPercent = Percent.percent(10, 100); Percent.percent private m_fiftiethBakerPercent = Percent.percent(15, 100); Percent.percent private m_twentiethBakerPercent = Percent.percent(20, 100); event LogPEInit(uint when, address rev1Storage, address rev2Storage, uint investorMaxInvestment, uint endTimestamp); event LogSendExcessOfEther(address indexed addr, uint when, uint value, uint investment, uint excess); event LogNewReferral(address indexed addr, address indexed referrerAddr, uint when, uint refBonus); event LogRGPInit(uint when, uint startTimestamp, uint maxDailyTotalInvestment, uint activityDays); event LogRGPInvestment(address indexed addr, uint when, uint investment, uint indexed day); event LogNewInvestment(address indexed addr, uint when, uint investment, uint value); event LogAutomaticReinvest(address indexed addr, uint when, uint investment); event LogPayDividends(address indexed addr, uint when, uint dividends); event LogNewInvestor(address indexed addr, uint when); event LogBalanceChanged(uint when, uint balance); event LogNextWave(uint when); event LogDisown(uint when); modifier balanceChanged { _; emit LogBalanceChanged(now, address(this).balance); } modifier notFromContract() { "require(msg.sender.isNotContract(), ""only externally accounts"");" _; } function() public payable { if (msg.value.isZero()) { getMyDividends(); return; }	0
function Grandma() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
function whitelistingMode() public view returns (bool) { return _whitelistingMode; }	0
function read()	0
require(b <= a); c = a - b; } function mul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); }	0
function _transfer(address _from, address _to, uint256 _value) internal returns (bool success){ require(_from != address(0) && _from != _to); require(_to != address(0)); balances[_from] = balances[_from].safeSub(_value); balances[_to] = balances[_to].safeAdd(_value); return true; }	0
function DSEasyMultisig( uint required, uint member_count, uint expiration ) { _required = required; _member_count = member_count; _members_remaining = member_count; _expiration = expiration; }	0
function transfer(address _to, uint256 _value) returns (bool success);	0
function setMinterManager( address _newMinterManager ) public onlyOwner { emit MinterManagerSet(address(minterManager), _newMinterManager); minterManager = MinterManagementInterface(_newMinterManager); }	0
function transferDomain(string domain, address recipient) public onlyDomainOwner(domain) { domains[domain].owner = recipient; }	0
function getKing() public returns (address king);	0
function doInvest(address referrerAddr) public payable notFromContract balanceChanged { uint investment = msg.value; uint receivedEther = msg.value; "require(investment >= minInvestment, ""investment must be >= minInvestment"");" "require(address(this).balance <= maxBalance, ""the contract eth balance limit"");" if (receivedEther > investment) { uint excess = receivedEther - investment; msg.sender.transfer(excess); receivedEther = investment; emit LogSendExcessOfEther(msg.sender, now, msg.value, investment, excess); } advertisingAddress.send(m_advertisingPercent.mul(receivedEther)); adminsAddress.send(m_adminsPercent.mul(receivedEther)); bool senderIsInvestor = m_investors.isInvestor(msg.sender); if (referrerAddr.notZero() && !senderIsInvestor && !m_referrals[msg.sender] && referrerAddr != msg.sender && m_investors.isInvestor(referrerAddr)) { m_referrals[msg.sender] = true; uint referrerBonus = m_referrer_percent.mmul(investment); uint referalBonus = m_referal_percent.mmul(investment); assert(m_investors.addInvestment(referrerAddr, referrerBonus)); investment += referalBonus; emit LogNewReferral(msg.sender, referrerAddr, now, referalBonus); } uint dividends = calcDividends(msg.sender); if (senderIsInvestor && dividends.notZero()) { investment += dividends; emit LogAutomaticReinvest(msg.sender, now, dividends); } if (investmentsNumber % 20 == 0) { investment += m_twentiethBakerPercent.mmul(investment); } else if(investmentsNumber % 15 == 0) {	0
function Cherryblossom() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
function toEthSignedMessageHash(bytes32 hash)	0
function decimals() public view returns (uint8) { return _decimals; }	0
function totalSupply(bytes32 _symbol) public view returns (uint);	0
function recoverTokens(ERC20Interface _asset, address _receiver, uint _value) public returns(bool);	0
function tokenByIndex(uint256 index) public view returns (uint256);	0
function deactivateTokenSwitch() public onlyValidator { tokenSwitch = false; emit TokenSwitchDeactivated(); }	0
function calcSeason(uint16 stageIndex) private view returns (uint16) { if (stageIndex > 0) { uint16 __seasonNumber = stageIndex.div(SEASON_STAGES); if (stageIndex.mod(SEASON_STAGES) > 0) { return __seasonNumber.add(1); } return __seasonNumber; }	0
function closeCrowdsale() public onlyOwner  { crowdsaleClosed = true; }	0
contract Pausable is Ownable { event Pause(); event Unpause(); address public distributionContract; bool distributionContractAdded; bool public paused = false; modifier whenNotPaused() { if(msg.sender != distributionContract) { require(!paused); }	0
function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes _data) external { "require(_to != address(0), ""_to must be non-zero."");" "require(_from == msg.sender || operatorApproval[_from][msg.sender] == true, ""Need operator approval for 3rd party transfers."");" balances[_id][_from] = balances[_id][_from].sub(_value); balances[_id][_to]   = _value.add(balances[_id][_to]); emit TransferSingle(msg.sender, _from, _to, _id, _value); if (_to.isContract()) { require(IERC1155TokenReceiver(_to).onERC1155Received(msg.sender, _from, _id, _value, _data) == ERC1155_RECEIVED); } }	0
function unBlockContract() onlyOwner public { blockedContract = false; emit onBlockHODLs(blockedContract); }	0
function sqrt(uint256 x) private pure returns (uint256 y) { uint256 z = (x + 1) / 2; y = x; while (z < y) { y = z; z = (x / z + z) / 2; } }	0
contract GRSCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; }	0
function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private { if (!isWhiteListed) throw; if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought); } }	0
function _removePauser(address account) internal { pausers.remove(account); emit PauserRemoved(account); }	0
event Approval( address indexed owner, address indexed spender, uint256 value ); } contract DetailedERC20 is ERC20 { string public name; string public symbol; uint8 public decimals; }	0
function approve(address _spender, uint _value) public returns(bool) { return _getAsset()._performApprove(_spender, _value, msg.sender); }	0
function _mint(address to, uint256 tokenId) internal { require(to != address(0)); require(!_exists(tokenId)); _tokenOwner[tokenId] = to; _ownedTokensCount[to] = _ownedTokensCount[to].add(1); emit Transfer(address(0), to, tokenId); }	0
function balanceOf(address _owner) public view returns (uint256 balance) { return balanceOf[_owner]; }	0
function finalizeCrowdsale() public { } }	0
function isApproved(address validator) external view returns (bool);	0
function encodeBytes(Buffer.buffer memory buf, bytes value) internal pure { encodeType(buf, MAJOR_TYPE_BYTES, value.length); buf.append(value); }	0
function () public payable { _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender); _returnReturnData(true); }	0
contract ERC20Detailed is IERC20 { string private _name; string private _symbol; uint8 private _decimals; }	0
function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }	0
function tokenFallback(address _from, uint _value, bytes _data) { (_from); (_value); (_data); }	0
function _mint(address account, uint256 value) internal { require(totalSupply().add(value) <= _cap); super._mint(account, value); }	0
function getContent(string memory domain) public view returns (bytes) { return domains[domain].content; }	0
function transferFrom(address sender, address recipient, uint256 amount) public whenNotPaused returns (bool) { if (recipient == address(this) || recipient == address(0)) { _burn(msg.sender, amount); }	0
function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else {	0
function remove(address validator) external;	0
function ChangeAllTimeHighPrice(uint256 newAllTimeHighPrice) onlyOwner public { require(newAllTimeHighPrice > allTimeHighPrice); allTimeHighPrice = newAllTimeHighPrice; }	0
string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; } function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] >= _value); require (balanceOf[_to] + _value > balanceOf[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); }	0
function mint(address to, uint256 value) public onlyMinter returns (bool) { _mint(to, value); return true; }	0
function allowance( address owner, address spender ) external view returns (uint256); event Transfer( address indexed from, address indexed to, uint256 value ); event Approval( address indexed owner, address indexed spender, uint256 value ); } pragma solidity ^0.4.24; library SafeTransfer { function _safeTransferFrom( address _tokenAddress, address _from, address _to, uint256 _value ) internal returns (bool result) { IBadERC20(_tokenAddress).transferFrom(_from, _to, _value); assembly { switch returndatasize() case 0 { result := not(0) } case 32 { returndatacopy(0, 0, 32) result := mload(0) } default { revert(0, 0) } }	0
function randomNumber()	0
constructor () public { owner = msg.sender; balances[owner] = _totalSupply; emit Transfer(0, owner, _totalSupply); }	0
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public { sellPrice = newSellPrice; buyPrice = newBuyPrice; emit Price(sellPrice,buyPrice); }	0
contract AssetWithAmbi is Asset, Ambi2EnabledFull { modifier onlyRole(bytes32 _role) { if (address(ambi2) != 0x0 && (ambi2.hasRole(this, _role, _sender()))) { _; }	0
function transfer(address to, uint256 value) external returns (bool);	0
function setPeriodRate(uint256 _period, uint256 _rate) public onlyOwner { if (_period == 1) { rate1 = _rate; }else if (_period == 2) { rate2 = _rate; }else if (_period == 3) { rate3 = _rate; }	0
constructor() public { owner = 0xd62D2Bc131Bed2993452B505a1B272724ebbB9a4; emit LogSetOwner(0xd62D2Bc131Bed2993452B505a1B272724ebbB9a4); }	0
function maxGasPrice() public view returns(uint);	0
contract ERC20Interface { event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed from, address indexed spender, uint256 value); string public symbol; }	0
function balanceOf(address who) constant returns (uint256);	0
contract StandardToken is ERC20, SafeMath { modifier onlyPayloadSize(uint size) { require(msg.data.length >= size + 4) ; _; } mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; }	0
function div(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b > 0); uint256 c = _a / _b; return c; }	0
function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); uint256 CoinTransfer = safeSub(tokens, 500000); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], CoinTransfer); emit Transfer(from, to, CoinTransfer); emit Transfer(msg.sender, address(0), 500000); return true; }	0
function balanceOf(address _owner) view returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) view returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }	0
function cancel() public { if (msg.sender == buyer){ buyerOk = false; } else if (msg.sender == seller){ sellerOk = false; }	0
function removeDistributionSources(address[] _blacklist) external onlyContractOwner returns (uint) { for (uint _idx = 0; _idx < _blacklist.length; ++_idx) { delete distributionSourcesList[_blacklist[_idx]]; }	0
function getDisputeFee(bytes32 _questionID) external view returns (uint fee) { return arbitrator.arbitrationCost(arbitratorExtraData); }	0
function getBeneficiary()	0
function transfer(address to, uint tokens) public returns (bool success);	0
function safeTransfer(IERC20 token, address to, uint256 value) internal { "require(token.transfer(to, value), ""Transfer failed"");" }	0
contract Ballot { struct Voter { uint weight; bool voted; uint8 vote; address delegate; } struct Proposal { uint voteCount; } address chairperson; mapping(address => Voter) voters; Proposal[] proposals; function winningProposal() constant returns (uint8 winningProposal) { uint256 winningVoteCount = 0; for (uint8 proposal = 0; proposal < proposals.length; proposal++) if (proposals[proposal].voteCount > winningVoteCount) { winningVoteCount = proposals[proposal].voteCount; winningProposal = proposal; }	0
function setWhitelistContract(address whitelistAddress)	0
function calcNetCost(int[] memory outcomeTokenAmounts)	0
function stableToken() internal returns(ISmartToken) { return ISmartToken(registry.addressOf(ContractIds.STABLE_TOKEN)); }	0
function setEnable(bool _enable) public onlyAdmin { if (_enable) { require(feeBurnerContract != address(0)); require(expectedRateContract != address(0)); require(kyberNetworkProxyContract != address(0)); }	0
function PayToken(address user, address tokenAddress, uint256 amount) private { ERC20Interface token = ERC20Interface(tokenAddress); require(token.balanceOf(address(this)) >= amount); token.transfer(user, amount); }	0
contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; event FrozenFunds(address target, bool frozen); event Price(uint256 newSellPrice, uint256 newBuyPrice); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} }	0
function addToExistingOffer(uint256 offerNumber, uint256 amountOffers) public payable{ address sender = msg.sender; uint256 value = msg.value; require(sender == OpenOffers[offerNumber].maker); require(value >= OpenOffers[offerNumber].betSize.mul(amountOffers)); OpenOffers[offerNumber].amount = OpenOffers[offerNumber].amount.add(amountOffers); }	0
function getUnclaimedTokenAmount(address tokenAddr, address payee) public view returns (uint) { ERC20 Token = ERC20(tokenAddr); uint totalReceived = Token.balanceOf(address(this)).add(totalTokensReleased[address(Token)]); uint payment = totalReceived.mul( balances[payee]).div( totalSupply_).sub( tokensReleased[address(Token)][payee] ); return payment; }	0
contract WithBeneficiary is Owned { address private beneficiary; event LogBeneficiarySet(address indexed previousBeneficiary, address indexed newBeneficiary); constructor(address _beneficiary) payable public { require(_beneficiary != 0); beneficiary = _beneficiary; if (msg.value > 0) { asyncSend(beneficiary, msg.value); }	0
function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true; }	0
function completeXConversion( IERC20Token[] _path, uint256 _minReturn, uint256 _conversionId, uint256 _block, uint8 _v, bytes32 _r, bytes32 _s ) public returns (uint256) { IBancorX bancorX = IBancorX(registry.addressOf(ContractIds.BANCOR_X)); IBancorNetwork bancorNetwork = IBancorNetwork(registry.addressOf(ContractIds.BANCOR_NETWORK)); require(_path[0] == registry.addressOf(ContractIds.BNT_TOKEN)); uint256 amount = bancorX.getXTransferAmount(_conversionId, msg.sender); token.destroy(msg.sender, amount); token.issue(bancorNetwork, amount); return bancorNetwork.convertForPrioritized3(_path, amount, _minReturn, msg.sender, _conversionId, _block, _v, _r, _s); }	0
function transfer(address _to, uint256 _value) public onlyPayloadSize(2) returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); require(transfersEnabled); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; }	0
function transfer(address _to, uint _value) returns (bool success) {} function transferFrom(address _from, address _to, uint _value) returns (bool success) {} function approve(address _spender, uint _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint remaining) {} event Transfer(address indexed _from, address indexed _to, uint _value);	0
function mul(int256 a, int256 b) internal pure returns (int256 c) { if (a == 0) { return 0; }	0
function withdraw(address _address) public onlyOwner { require(stop || now > endTime); require(_address != address(0)); uint tokenBalanceOfContract = getRemainingToken(); erc20.transfer(_address, tokenBalanceOfContract); emit LogWithdrawal(_address, tokenBalanceOfContract); }	0
function availableOf(address account) public view returns (uint256) { return balanceOf(account).sub(reservedOf(account)); }	0
function setAdmin(address admin, bool isAdmin) onlyOwner { admins[admin] = isAdmin; }	0
function finalizeVoting(bytes32 _id) external { governance.finalizeVoting(_id); }	0
function checkMintSolution(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number, uint testTarget) public view returns (bool success) { bytes32 digest = keccak256(challenge_number,msg.sender,nonce); if(uint256(digest) > testTarget) revert(); return (digest == challenge_digest); }	0
function daiCentsToEthWei(uint daiCents, uint ethPriceWad) internal pure returns (uint) { return centsToWad(daiCents).mul(10**18).div(ethPriceWad); }	0
function areReservedTokensDistributed() public view returns (bool) { return finalizeAgent.reservedTokensAreDistributed(); }	0
function proxyType()	0
function getCertifierStatus(address certifierAddr)	0
function acceptOwnership() public onlyNewOwner returns(bool) { emit OwnershipTransferred(owner, newOwner); owner = newOwner; }	0
function startTokensLottery() public onlyGame tokenIsAvailable { isTokensLottery = true; }	0
constructor( address beneficiary, uint256 start, uint256 cliffDuration, uint256 duration ) public { require(beneficiary != address(0)); require(cliffDuration <= duration); require(duration > 0); require(start.add(duration) > block.timestamp); _beneficiary = beneficiary; _duration = duration; _cliff = start.add(cliffDuration); _start = start; }	0
function approve( address _spender, uint256 _value ) public onlyRecipientWhitelisted(_spender) returns (bool) { StandardToken.approve(_spender, _value); }	0
function decimals() public view returns(uint digits);	0
function balanceETH() public view returns(uint) { return address(this).balance; }	0
function _withdrawBonusesFromDeposit(bytes32 _userKey, uint _periodDate, uint _value, Treasury _treasury) private returns (uint) { Deposit storage _pendingDeposit = distributionDeposits[_periodDate]; Balance storage _userBalance = _pendingDeposit.leftToWithdraw[_userKey]; uint _balanceToWithdraw; if (_userBalance.initialized) { _balanceToWithdraw = _userBalance.left; } else {	0
function transferFromToICAPWithReference(address _from, string _icap, uint _value, string _reference) public returns(bool) { return transferFromToICAPWithReference(_from, _bytes32(_icap), _value, _reference); }	0
function depositToken(address token, uint amount) public{ require (token!=0) ; require (Token(token).transferFrom(msg.sender, this, amount)); tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount); emit Deposit(token, msg.sender, amount, tokens[token][msg.sender]); }	0
function transfer(address _to, uint256 _value) public returns (bool success) { require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; }	0
function _postValidatePurchase( address _beneficiary, uint256 _weiAmount ) internal { }	0
function getCertifierDb()	0
function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, string orderId) public{ bytes32 hash = sha256(abi.encodePacked(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce)); require (orders[msg.sender][hash]); orderFills[msg.sender][hash] = amountGet; emit Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender,orderId); }	0
function lockedBalanceOf(address _owner) public view returns (uint256) { return block.timestamp <= lockedUntil ? lockedBalances[_owner] : 0; }	0
contract FreezableToken is ERC20, Ownable { event TransfersEnabled(); bool public allowTransfers = false; modifier canTransfer() { require(allowTransfers || msg.sender == owner); _; } }	0
function getConnectorBalance(IERC20Token _connectorToken) public view returns (uint256);	0
function getLatestByMajor(uint64 major) public view returns (uint64[3] semanticVersion, address contractAddress, bytes contentURI) { Version storage version = versions[majorToLatestVersion[major]]; return (version.semanticVersion, version.contractAddress, version.contentURI); }	0
function buyFee(address sender, uint256 weiAmount, bool isFirstInvest) private { address referrer = referrers[sender]; uint256 holdersWeiAmount; if (referrer != address(0)) { uint256 referrerWeiAmount = weiAmount.mul(REFERRER_PERCENT).div(100); emit ReferalsIncome(referrer, referrerWeiAmount, now); ethStorage[referrer] = ethStorage[referrer].add(referrerWeiAmount); if (isFirstInvest) { uint256 cashbackWeiAmount = weiAmount.mul(CASHBACK_PERCENT).div(100); emit ReferalsIncome(sender, cashbackWeiAmount, now); ethStorage[sender] = ethStorage[sender].add(cashbackWeiAmount); holdersWeiAmount = weiAmount.mul(HOLDERS_BUY_PERCENT_WITH_REFERRER_AND_CASHBACK).div(100); } else { holdersWeiAmount = weiAmount.mul(HOLDERS_BUY_PERCENT_WITH_REFERRER).div(100); }	0
} constructor(string memory instanceType) public { _instanceType = bytes4(keccak256(bytes(instanceType))); }	0
constructor () public { owner = msg.sender; maxSalesAllowed = 2; transfersBetweenSalesAllowed = true; }	0
constructor( string _merchantId, MerchantDealsHistory _merchantHistory, MonethaGateway _monethaGateway, MerchantWallet _merchantWallet ) public { require(bytes(_merchantId).length > 0); merchantIdHash = keccak256(abi.encodePacked(_merchantId)); setMonethaGateway(_monethaGateway); setMerchantWallet(_merchantWallet); setMerchantDealsHistory(_merchantHistory); }	0
} contract ERC20 { event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); }	0
function mint(address _account, uint256 _value) onlyOwner public { require(_account != address(0)); require(_totalSupply.add(_value) <= hardcap); require(_enbaleActions); _totalSupply = _totalSupply.add(_value); _balances[_account] = _balances[_account].add(_value); emit Transfer(address(0), _account, _value); }	0
function bulkApproveTransfers(uint256[] nonces)	0
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public returns (bool);	0
function getsum(uint[] values) private pure returns (uint s) { s = 0; for (uint j = 0; j < values.length; j++) { s += values[j]; } return s; }	0
contract CappedToken is MintableToken { uint256 public constant cap = 1000000000000000000000000000; }	0
function isSubscriptionActive( bytes32 subscriptionHash, uint256 gracePeriodSeconds ) external view returns (bool) { if(nextValidTimestamp[subscriptionHash]==uint256(-1)){ return false; } return (block.timestamp <= nextValidTimestamp[subscriptionHash].add(gracePeriodSeconds) ); }	0
function deposit(address _from, uint256 _amountDai) internal { "require(_from != address(0) && _amountDai > 0, ""invalid parameter(s)"");" dai.safeTransferFrom(msg.sender, address(this), _amountDai); if (!paused()) { "require(dai.allowance(address(this), MONEY_MARKET_ADDRESS) == 0, ""non-zero initial moneyMarket allowance"");" "require(dai.approve(MONEY_MARKET_ADDRESS, _amountDai), ""approving moneyMarket failed"");" uint256 errorCode = moneyMarket.supply(DAI_ADDRESS, _amountDai); "require(errorCode == 0, ""supply failed"");" "require(dai.allowance(address(this), MONEY_MARKET_ADDRESS) == 0, ""allowance not fully consumed by moneyMarket"");" } deposits[_from] = deposits[_from].add(_amountDai); deposited = deposited.add(_amountDai); emit Deposited(_from, _amountDai); }	0
function sum() public view returns(uint256 weiSold,	0
function setFee(uint256 _feePercent) public onlyOwner { feePercent = _feePercent; }	0
function addChainlinkExternalRequest(address _oracle, bytes32 _requestId)	0
function close()	0
function getTokenIdByIndex(address _game, uint8 _index) public view returns (uint256){ return awardDatas[msg.sender].items[_game].tokenIds[_index]; }	0
function getBonus() public view returns(uint256){ uint256 invested = getInvested(); if(invested >= 0.5 ether && 4 ether >= invested){ return 0; }else if(invested >= 4.01 ether && 7 ether >= invested){	0
function EmissiveErc223Token( address issuer, string tokenName, uint8 divisibility, string tokenSymbol, string version) LykkeTokenErc223Base(issuer, tokenName, divisibility, tokenSymbol, version, 0) public{ balances [_issuer] = SafeMath.GET_MAX_UINT256(); }	0
function TokenHolder() { } function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public ownerOnly validAddress(_token) validAddress(_to) notThis(_to) { assert(_token.transfer(_to, _amount)); } }	0
constructor () internal { _addMinter(msg.sender); }	0
require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); }	0
function enableTransfer() public onlyOwner { _transferEnabled = true; emit TransferEnabled(); }	0
function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } contract HumanStandardToken is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = 'H0.1'; function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	0
function transferFrom(address from, address to, uint256 value) public returns (bool) { require(value <= _balances[from]); require(value <= _allowed[from][msg.sender]); require(to != address(0)); _balances[from] = _balances[from].sub(value); uint256 tokensToBurn = getTokensToBurn(value); uint256 tokensToTransfer = value.sub(tokensToBurn); _balances[to] = _balances[to].add(tokensToTransfer); _totalSupply = _totalSupply.sub(tokensToBurn); _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value); emit Transfer(from, to, tokensToTransfer); emit Transfer(from, address(0), tokensToBurn); return true; }	0
function allowance(address owner, address spender) public view returns (uint) { return allowances[owner][spender]; }	0
function tokenURI(uint256 tokenId) external view returns (string memory) { require(_exists(tokenId)); return _tokenURIs[tokenId]; }	0
function min64(uint64 a, uint64 b) internal view returns(uint64){ return a < b ? a : b; }	0
contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); modifier onlyOwner() { require(msg.sender == owner); _;	0
contract VeganCoin is CappedToken, FreezableToken { "string public name = ""VeganCoin"";" "string public symbol = ""VCN"";" uint8 public decimals = 18; }	0
contract CoinMetroVault is Ownable { using SafeMath for uint256; CoinMetroToken public token; address public masterWallet; uint256 public releaseTimestamp; event TokenReleased(address _masterWallet, uint256 _amount); function() external payable { revert(); } }	0
masterCopy = _masterCopy; } constructor(address _masterCopy) public Proxy(_masterCopy) {}	0
function allowance(address owner, address spender) public view returns (uint256) { return _allowed[owner][spender]; }	0
function setReserve(address token, address user, uint256 amount) onlyFuturesContract returns (bool success) { if (!futuresContractAllowed(msg.sender, user)) throw; if (availableBalanceOf(token, user) < amount) throw; updateReserve(token, user, amount); return true; }	0
contract ERC1363 is ERC20, IERC1363 { using Address for address; bytes4 internal constant _INTERFACE_ID_ERC1363_TRANSFER = 0x4bbee2df; bytes4 internal constant _INTERFACE_ID_ERC1363_APPROVE = 0xfb9ec8ce; bytes4 private constant _ERC1363_RECEIVED = 0x88a7ca5c; bytes4 private constant _ERC1363_APPROVED = 0x7b04a2d0; function _checkAndCallTransfer(address from, address to, uint256 value, bytes memory data) internal returns (bool) { if (!to.isContract()) { return false; }	0
function acceptOwnership() public;	0
contract GroupForkTimelock is TokenRecover { using SafeMath for uint256; using SafeERC20 for ERC20Basic; ERC20Basic public token; uint256 public lockedTokens; address[] public accounts; mapping(address => uint256) public reservedTokens; mapping (address => uint256) public receivedTokens; uint256 public releaseTime; constructor( ERC20Basic _token, address[] _accounts, uint256[] _amounts, uint256 _releaseTime ) public { require(_releaseTime > block.timestamp); require(_accounts.length > 0); require(_amounts.length > 0); require(_accounts.length == _amounts.length); token = _token; accounts = _accounts; releaseTime = _releaseTime; for (uint i = 0; i < accounts.length; i++) { address account = accounts[i]; uint256 amount = _amounts[i]; reservedTokens[account] = amount; lockedTokens = lockedTokens.add(amount); }	0
function renouncePauser() public { _removePauser(msg.sender); }	0
function getProxyAdmin(AdminUpgradeabilityProxy proxy) public view returns (address) { return proxy.admin(); }	0
} contractOwner = pendingContractOwner; delete pendingContractOwner; return true; }	0
function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); uint256 CoinTransfer = safeSub(tokens, 50); balances[to] = safeAdd(balances[to], CoinTransfer); emit Transfer(msg.sender, to, CoinTransfer); emit Transfer(msg.sender, address(0), 50); return true; }	0
function _addWhitelisted(address account) internal { _whitelisteds.add(account); emit WhitelistedAdded(account); }	0
function withdraw() external onlyReceiver canWithdraw { for (uint i = 0; i < participants.length; i++) { address token = tokenByParticipant[participants[i]]; SwapOffer storage offer = offerByToken[token]; if (offer.participant == msg.sender) { continue; } uint256 tokensAmount = _withdrawableAmount(offer.token, msg.sender); if (tokensAmount > 0) { withdrawnTokens[offer.token][msg.sender] = withdrawnTokens[offer.token][msg.sender].add(tokensAmount); offer.withdrawnTokensTotal = offer.withdrawnTokensTotal.add(tokensAmount); offer.token.safeTransfer(msg.sender, tokensAmount); emit Withdraw(msg.sender, offer.token, tokensAmount); } }	0
function getBonusByTime() public constant returns (uint256) { if (now < startDate1) { return 0; } else if (endDate1 > now && now > startDate1) { return rate1; } else if (endDate2 > now && now > startDate2) { return rate2; } else if (endDate3 > now && now > startDate3) { return rate3; } else { return 0; }	0
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { return super.transferFrom(_from, _to, _value); }	0
function isValidator(address validator) public view returns (bool) { return isApproved(validator) && orbsValidatorsRegistry.isValidator(validator); }	0
function ExpectedRate(KyberNetwork _kyberNetwork, ERC20 _knc, address _admin) public { require(_admin != address(0)); require(_knc != address(0)); require(_kyberNetwork != address(0)); kyberNetwork = _kyberNetwork; admin = _admin; knc = _knc; }	0
function transfer(address _to, uint256 _value) public returns (bool success)	0
contract BonusToken is ERC20, ERC20Detailed, Ownable { address public gameAddress; address public investTokenAddress; uint public maxLotteryParticipants; mapping (address => uint256) public ethLotteryBalances; address[] public ethLotteryParticipants; uint256 public ethLotteryBank; bool public isEthLottery; mapping (address => uint256) public tokensLotteryBalances; address[] public tokensLotteryParticipants; uint256 public tokensLotteryBank; bool public isTokensLottery; modifier onlyGame() { require(msg.sender == gameAddress); _; } modifier tokenIsAvailable { require(investTokenAddress != address(0)); _; } function restartEthLottery() public onlyGame { for (uint i = 0; i < ethLotteryParticipants.length; i++) { ethLotteryBalances[ethLotteryParticipants[i]] = 0; }	0
function forceTransfer(address _confiscatee, address _receiver) public onlyOwner { uint256 balance = balanceOf(_confiscatee); _transfer(_confiscatee, _receiver, balance); emit ForcedTransfer(_confiscatee, balance, _receiver); }	0
function burn(uint256 value) public { _burn(msg.sender, value); }	0
function fSTGHA() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
function balanceOf(address who) public view returns (uint256);	0
contract SupportsInterfaceWithLookup is ERC165 { bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7; mapping(bytes4 => bool) internal supportedInterfaces; constructor() public { _registerInterface(InterfaceId_ERC165); } external view returns (bool) { return supportedInterfaces[_interfaceId]; } internal { require(_interfaceId != 0xffffffff); supportedInterfaces[_interfaceId] = true; } }	0
function isInsolvent(IVault _vault, address _borrower) public view returns (bool);	0
constructor (bytes32 symbol_) public { symbol = symbol_; }	0
require(operators[msg.sender]); _; } modifier onlyAlerter() { require(alerters[msg.sender]); _; } event TransferAdminPending(address pendingAdmin); event AdminClaimed( address newAdmin, address previousAdmin); event AlerterAdded (address newAlerter, bool isAdd); } contract Withdrawable is PermissionGroups { event TokenWithdraw(ERC20 token, uint amount, address sendTo); event EtherWithdraw(uint amount, address sendTo); }	0
function deleteInt(bytes32 _key) external;	0
contract Owned is IOwned { address public owner; address public newOwner; event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner); modifier ownerOnly { require(msg.sender == owner); _; } }	0
function toAddress(bytes source) internal pure returns(address addr) { assembly { addr := mload(add(source,0x14)) } return addr; }	0
function checkHowManyOwners(uint howMany) internal returns(bool) { if (insideCallSender == msg.sender) { "require(howMany <= insideCallCount, ""checkHowManyOwners: nested owners modifier check require more owners"");" return true; }	0
function transferTopSales(uint16 seasonNumber, address to) external onlyOwner { uint256 __weiRemain = seasonTopSalesRemain(seasonNumber); require(to != address(0)); _seasonWeiTopSalesTransfered[seasonNumber] = _seasonWeiTopSalesTransfered[seasonNumber].add(__weiRemain); emit SeasonTopSalesWeiTransfered(seasonNumber, to, __weiRemain); to.transfer(__weiRemain); }	0
function verifyLinkPrivateKey( public pure returns(bool success) { "bytes32 prefixedHash = keccak256(""\x19Ethereum Signed Message:\n32"", _addressSigned, _referralAddress);" address retAddr = ecrecover(prefixedHash, _v, _r, _s); return retAddr == _transitAddress; }	0
function balanceOf(address owner) public view returns (uint) { return balances[owner]; }	0
function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) view returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value);	0
function emitRepay(address _borrower, uint256 _amount) public;	0
function sellFee(uint256 weiAmount) private returns(uint256) { uint256 holdersWeiAmount = weiAmount.mul(HOLDERS_SELL_PERCENT).div(100); addDividends(holdersWeiAmount); weiAmount = weiAmount.sub(holdersWeiAmount); return weiAmount; }	0
contract Ambi2EnabledFull is Ambi2Enabled { function setupAmbi2(Ambi2 _ambi2) public returns(bool) { if (address(ambi2) != 0x0) { return false; }	0
function getApproved(uint256 tokenId) public view returns (address operator);	0
function finalize() onlyOwner public { require(!isFinalized); require(hasEnded()); finalization(); emit Finalized(); isFinalized = true; }	0
function approve(address _spender, uint256 _value) external returns (bool);	0
function symbol() public view returns (string) {} function decimals() public view returns (uint8) {} function totalSupply() public view returns (uint256) {} function balanceOf(address _owner) public view returns (uint256) { _owner; } function allowance(address _owner, address _spender) public view returns (uint256) { _owner; _spender; } function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success);	0
function batchAdminWithdraw( address[] token, uint256[] amount, address[] user, uint256[] nonce, uint8[] v, bytes32[] r, bytes32[] s, uint256[] feeWithdrawal ) onlyAdmin { for (uint i = 0; i < amount.length; i++) { adminWithdraw( token[i], amount[i], user[i], nonce[i], v[i], r[i], s[i], feeWithdrawal[i] ); } }	0
function safeApprove(ERC20 token, address spender, uint256 value) internal { assert(token.approve(spender, value)); }	0
contract Pausable is Ownable { event Paused(address account); event Unpaused(address account); bool private _paused; modifier whenNotPaused() { require(!_paused); _; } modifier whenPaused() { require(_paused); _; } }	0
function removeOperator(address account) public onlyOwner { _removeOperator(account); }	0
function transfer(address to, uint value) public returns (bool ok);	0
contract SinglePullPayment is PayableOwnable { using SafeMath for uint256; event LogExecutorAdded(address executor); event LogExecutorRemoved(address executor); event LogPullPaymentExecuted( address customerAddress,	0
function getPaginatedUsers(uint256 startIndex, uint256 endIndex) public view returns (address[] memory users) { "require(startIndex < endIndex, ""startIndex must be less than endIndex"");" "require(endIndex <= _users.count(), ""end index out of range"");" address[] memory range = new address[](endIndex - startIndex); for (uint256 i = startIndex; i < endIndex; i++) { range[i - startIndex] = _users.keyAtIndex(i); } users = range; }	0
function vestingDuration() public view returns (uint256) { return _vestingDuration; }	0
function withdrawAllToken(address[] list_sender) onlyOwner returns (bool){ for(uint i = 0; i < list_sender.length; i++){ "require(balances[list_sender[i]] > 0, ""insufficient token to checksum"");" }	0
function mintWithAllocation(address account, uint256 amount, IAllocation allocationContract) public whenNotPaused onlyMinter returns (bool) { _mintWithAllocation(account, amount, allocationContract); return true; }	0
function isZero(address addr) internal pure returns(bool) { return addr == address(0); }	0
function transferFromAndCall(address from, address to, uint256 value, bytes memory data) public returns (bool);	0
function isICAP(address _address) public pure returns(bool) { bytes32 a = bytes32(_address) << 96; if (a[0] != 'X' || a[1] != 'E') { return false; } if (a[2] < 48 || a[2] > 57 || a[3] < 48 || a[3] > 57) { return false; } for (uint i = 4; i < 20; i++) { uint char = uint(a[i]); if (char < 48 || char > 90 || (char > 57 && char < 65)) { return false; }	0
contract ERC20 is ERC20Events { function transferFrom( address src, address dst, uint wad ) public returns (bool); }	0
contract ReturnVestingRegistry is Ownable { mapping (address => address) public returnAddress; }	0
function KyberUniswapReserve( UniswapFactory _uniswapFactory, address _admin, address _kyberNetwork ) public { require(address(_uniswapFactory) != 0); require(_admin != 0); require(_kyberNetwork != 0); uniswapFactory = _uniswapFactory; admin = _admin; kyberNetwork = _kyberNetwork; }	0
function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { require(b != 0, errorMessage); return a % b; }	0
function transferAndCall( address _to, uint256 _value ) public returns (bool) { "return transferAndCall(_to, _value, """");" }	0
contract WuzuStandardToken is ERC20Interface, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; address private _owner; string private _uri; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); event UriChanged(string previousUri, string newUri); modifier onlyOwner() { "require(msg.sender == _owner, ""caller is not the owner"");" _; } }	0
function accountLevel(address user) view public returns(uint) { return accountLevels[user]; }	0
contract OwnableContract { event onTransferOwnership(address newOwner); address superOwner; modifier onlyOwner() { require(msg.sender == superOwner);	0
function Ethtex () public { owner = msg.sender; distr(owner, totalDistributed); }	0
function removeLock(address _of, bytes32 _reason) public onlyOwner returns (bool deleted) { require(!locked[_of][_reason].claimed, EXPIRED_ADDRESS); this.transfer(_of, locked[_of][_reason].amount); delete locked[_of][_reason]; emit RemoveLock(_of, _reason, locked[_of][_reason].amount, locked[_of][_reason].validity); return true; }	0
function deposit() payable public{ tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender], msg.value); emit Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]); }	0
contract MultiToken is ERC20, Ownable { using SafeMath for uint; string public name; string public symbol; uint public decimals; string public version; uint public totalSupply; uint public tokenPrice; bool public exchangeEnabled; bool public codeExportEnabled; address public commissionAddress; uint public deploymentCost; uint public tokenOnlyDeploymentCost; uint public exchangeEnableCost; uint public codeExportCost; mapping(address => uint) public balances; mapping(address => mapping(address => uint)) public allowed; event TransferSold(address indexed to, uint value); event TokenExchangeEnabled(address caller, uint exchangeCost); event TokenExportEnabled(address caller, uint enableCost); allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); }	0
function () external payable { getTokens(); }	0
function validPurchase() internal view returns (bool) { bool withinPeriod = now >= startTime && now <= endTime; bool nonZeroPurchase = msg.value != 0; return withinPeriod && nonZeroPurchase; }	0
returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } contract MyToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor(uint256 initialSupply,string tokenName,string tokenSymbol) TokenERC20(initialSupply, tokenName, tokenSymbol)   public { } }	0
function withdrawBody(address addr, uint limit) public onlyOwner returns (uint) { Investment[] investments = investors[addr].investments; uint valueToWithdraw = 0; for (uint i = 0; i < investments.length; i++) { if (!investments[i].partiallyWithdrawn && investments[i].date <= now - 30 days && valueToWithdraw + investments[i].value/2 <= limit) { investments[i].partiallyWithdrawn = true; valueToWithdraw += investments[i].value/2; investors[addr].overallInvestment -= investments[i].value/2; }	0
function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) { _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue)); return true; }	0
function isApprovedForAll(address owner, address operator) public view returns (bool);	0
contract ComplianceRegistry is Ownable{ address public service; event ChangeService(address _old, address _new); modifier isContract(address _addr) { uint length; assembly { length := extcodesize(_addr) }	0
function cancelOracleRequest( bytes32 _requestId, uint256 _payment, bytes4 _callbackFunc, uint256 _expiration ) external { bytes32 paramsHash = keccak256( abi.encodePacked( _payment, msg.sender, _callbackFunc, _expiration) ); "require(paramsHash == commitments[_requestId], ""Params do not match request ID"");" "require(_expiration <= now, ""Request is not expired"");" delete commitments[_requestId]; emit CancelOracleRequest(_requestId); assert(LinkToken.transfer(msg.sender, _payment)); }	0
function bytes32ToString(bytes32 x) public pure returns (string) { bytes memory bytesString = new bytes(32); bytesString = abi.encodePacked(x); return string(bytesString); }	0
contract DocumentCertoChainContract   is BaseCertoChainContract { string  public  Name; string  public  Description ; string  public  FileName; string  public  FileHash; string  public  FileData; address public  Revision; address public  NextOwner; address public  PrevOwner; constructor(string memory  _Description, string memory  _FileName,string memory _FileHash,string memory _FileData) public { Revision=address(this); NextOwner=address(this); Description=_Description; FileName=_FileName; FileHash=_FileHash; FileData=_FileData; "emit EventReady(address(this),""constructor"");" }	0
function sub(percent storage p, uint a) internal view returns (uint) { uint b = mul(p, a); if (b >= a) { return 0; } return a - b; }	0
contract AirDropContract { event AirDropped(address addr, uint amount); address public owner = 0x0080dc5b0d72E5C979bb6C4E04ac97E8995b27d5Af; }	0
function totalSupply() public view returns (uint) { return _totalSupply - balances[address(0)]; }	0
function isTransferAllowed(address, address, address, address, uint) public view returns (bool) { return true; }	0
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_to != address(0) && _value > 0 && balanceOf[_from] >= _value && allowance[_from][msg.sender] >= _value && frozenAccount[_from] == false && frozenAccount[_to] == false && now > unlockUnixTime[_from] && now > unlockUnixTime[_to]); balanceOf[_from] = balanceOf[_from].sub(_value); balanceOf[_to] = balanceOf[_to].add(_value); allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; }	0
contract MonethaGateway is Pausable, Contactable, Destructible, Restricted { using SafeMath for uint256; "string constant VERSION = ""0.6"";" uint public constant FEE_PERMILLE = 15; uint public constant PERMILLE_COEFFICIENT = 1000; address public monethaVault; address public admin; IMonethaVoucher public monethaVoucher; uint public MaxDiscountPermille; event PaymentProcessedEther(address merchantWallet, uint merchantIncome, uint monethaIncome); event PaymentProcessedToken(address tokenAddress, address merchantWallet, uint merchantIncome, uint monethaIncome); event MonethaVoucherChanged( address indexed previousMonethaVoucher, address indexed newMonethaVoucher ); event MaxDiscountPermilleChanged(uint prevPermilleValue, uint newPermilleValue); function acceptPayment(address _merchantWallet, uint _monethaFee, address _customerAddress, uint _vouchersApply, uint _paybackPermille) external payable onlyMonetha whenNotPaused returns (uint discountWei){ require(_merchantWallet != 0x0); uint price = msg.value; require(_monethaFee >= 0 && _monethaFee <= FEE_PERMILLE.mul(price).div(1000)); discountWei = 0; if (monethaVoucher != address(0)) { if (_vouchersApply > 0 && MaxDiscountPermille > 0) { uint maxDiscountWei = price.mul(MaxDiscountPermille).div(PERMILLE_COEFFICIENT); uint maxVouchers = monethaVoucher.fromWei(maxDiscountWei); uint vouchersApply = _vouchersApply; if (vouchersApply > maxVouchers) { vouchersApply = maxVouchers; }	0
function addParty( address _participant, ERC20 _token, uint256 _tokensTotal ) external onlyOwner canAddParty { "require(_participant != address(0), ""_participant is invalid address"");" "require(_token != address(0), ""_token is invalid address"");" "require(_tokensTotal > 0, ""Positive amount of tokens is required"");" require( isParticipant[_participant] == false, Unable to add the same party multiple times ); isParticipant[_participant] = true; SwapOffer memory offer = SwapOffer({ participant: _participant, token: _token, tokensTotal: _tokensTotal, withdrawnTokensTotal: 0 }); participants.push(offer.participant); offerByToken[offer.token] = offer; tokenByParticipant[offer.participant] = offer.token; emit AddParty(offer.participant, offer.token, offer.tokensTotal); }	0
function assemblyFindBestRate(ERC20 src, ERC20 dest, uint srcQty, bytes4 sig)	0
function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; return true; }	0
} constructor(uint256 newPeriodLength, uint256 newAmountPerPeriod, address tokenAddress) public { require(tokenAddress != address(0)); require(newPeriodLength > 0); require(newAmountPerPeriod > 0); token = IERC20(tokenAddress); periodLength = newPeriodLength; amountPerPeriod = newAmountPerPeriod; }	0
function setInt(bytes32 _key, int _value) external;	0
function transfer(address _to, uint256 _value) public { _transferLC(msg.sender, _to, _value); }	0
function _performTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference, address _sender) public onlyProxy() returns(bool) { return _transferToICAPWithReference(_icap, _value, _reference, _sender); }	0
function withdrawEther(address to, uint256 amount) external onlyOwner { require(to != address(0)); uint256 balance = address(this).balance; require(balance >= amount); to.transfer(amount); }	0
function transfer(address to, uint value) public returns (bool) { if (!balances[msg.sender].safeToSub(value) || !balances[to].safeToAdd(value)) { return false; }	0
function authorize(address _address, bool _auth) public;	0
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require (_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; }	0
function transferExtra(address _to, uint256 _value, bytes _extraData) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; }	0
function min256(uint256 a, uint256 b) internal pure returns (uint256) { return a < b ? a : b; }	0
contract LockedWallet is Ownable { using SafeMath for uint256; event Withdrawn ( uint256 period, uint256 amount, uint256 timestamp ); uint256 public depositedTime; uint256 public periodLength; uint256 public amountPerPeriod; IERC20 public token; uint256 public depositedAmount; mapping(uint256 => uint256) public withdrawalByPeriod; }	0
function getAerumAddress(address _staker) external view returns (address) { return stakerAerumAddress[_staker]; }	0
function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) { require(_x >= _y); return _x - _y; }	0
constructor() public { _registerInterface(_INTERFACE_ID_ERC1363_TRANSFER); _registerInterface(_INTERFACE_ID_ERC1363_APPROVE); }	0
contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner );	0
contract DeoToken { uint256 public totalSupply; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }	0
function destroyAndSend(address _recipient) public onlyOwner { selfdestruct(_recipient); }	0
function unpause() public onlyPauser whenPaused { _paused = false; emit Unpaused(msg.sender); }	0
function emitWithrawalRequestEvent(address _sender, address _smartWallet)	0
function LiteToken() public { "symbol = ""LTN"";" "name = ""LiteToken"";" decimals = 18; _totalSupply = 8400000000000000000000000000; balances[0x186d32c30f1DeFfF1eeDb34Ee661426918243545] = _totalSupply; emit Transfer(address(0), 0x186d32c30f1DeFfF1eeDb34Ee661426918243545, _totalSupply); }	0
function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true; }	0
function onApprovalReceived(address owner, uint256 value, bytes memory data) public returns (bytes4);	0
function transferFromToICAP(address _from, bytes32 _icap, uint _value) public returns(bool) { return transferFromToICAPWithReference(_from, _icap, _value, ''); }	0
"require(b <= a, ""SafeMath: subtraction overflow"");" uint256 c = a - b; return c; } function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; }	0
"constructor(address _implementation) AdminUpgradeabilityProxy(_implementation, """") public {" }	0
function add(uint a, uint b) internal returns(uint){ uint c = a + b; assertSafe(c >= a); return c; }	0
function safeTransferFrom(address from, address to, uint256 tokenId) public;	0
function getBool(bytes32 _key) external view returns (bool);	0
IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for, uint256 _block, uint8 _v, bytes32 _r, bytes32 _s ) public payable returns (uint256); function convertForPrioritized( IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for, uint256 _block, uint256 _nonce, uint8 _v, bytes32 _r, bytes32 _s ) public payable returns (uint256); } contract ContractIds { "bytes32 public constant CONTRACT_FEATURES = ""ContractFeatures"";" "bytes32 public constant CONTRACT_REGISTRY = ""ContractRegistry"";" "bytes32 public constant BANCOR_NETWORK = ""BancorNetwork"";" "bytes32 public constant BANCOR_FORMULA = ""BancorFormula"";" "bytes32 public constant BANCOR_GAS_PRICE_LIMIT = ""BancorGasPriceLimit"";" "bytes32 public constant BANCOR_CONVERTER_UPGRADER = ""BancorConverterUpgrader"";" "bytes32 public constant BANCOR_CONVERTER_FACTORY = ""BancorConverterFactory"";" "bytes32 public constant BNT_TOKEN = ""BNTToken"";" "bytes32 public constant BNT_CONVERTER = ""BNTConverter"";" "bytes32 public constant BANCOR_X = ""BancorX"";" "bytes32 public constant BANCOR_X_UPGRADER = ""BancorXUpgrader"";" } function convertForPrioritized2( IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for, uint256 _block, uint8 _v, bytes32 _r, bytes32 _s ) public payable returns (uint256); function convertForPrioritized( IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for, uint256 _block, uint256 _nonce, uint8 _v, bytes32 _r, bytes32 _s ) public payable returns (uint256); } contract ContractIds { "bytes32 public constant CONTRACT_FEATURES = ""ContractFeatures"";" "bytes32 public constant CONTRACT_REGISTRY = ""ContractRegistry"";" "bytes32 public constant BANCOR_NETWORK = ""BancorNetwork"";" "bytes32 public constant BANCOR_FORMULA = ""BancorFormula"";" "bytes32 public constant BANCOR_GAS_PRICE_LIMIT = ""BancorGasPriceLimit"";" "bytes32 public constant BANCOR_CONVERTER_UPGRADER = ""BancorConverterUpgrader"";" "bytes32 public constant BANCOR_CONVERTER_FACTORY = ""BancorConverterFactory"";" "bytes32 public constant BNT_TOKEN = ""BNTToken"";" "bytes32 public constant BNT_CONVERTER = ""BNTConverter"";" "bytes32 public constant BANCOR_X = ""BancorX"";" "bytes32 public constant BANCOR_X_UPGRADER = ""BancorXUpgrader"";" }	0
constructor(uint supply) public { _balances[msg.sender] = supply; _supply = supply; }	0
function pendingRemain() private view returns (uint256) { return _weiPending.sub(_weiPendingTransfered); }	0
contract TokenTimelock { using SafeERC20 for IERC20; IERC20 private _token; address private _beneficiary; uint256 private _releaseTime; }	0
contract WhiteListed{ mapping(address => bool)whitelist; }	0
"constructor () public ERC20Detailed(""Infinity"", ""NITY"", DECIMALS) {" _mint(msg.sender, INITIAL_SUPPLY); }	0
function changeAllCosigners2( uint opNum, address[] newCosigners, bytes sigCosigner0, bytes sigCosigner1, bytes sigCosigner2, bytes sigOwner ) onlyOwner orderedOps(opNum) external { "bytes32 hash = keccak256(""NS"", m_teamId, opNum, toBytes(newCosigners));" require(checkSignatures2(hash, sigCosigner0, sigCosigner1, sigCosigner2)); require(ecverify(hash, sigOwner, m_owner)); m_opNum = opNum + 1; m_cosignersApprovedDisband.length = 0; m_cosigners = newCosigners; }	0
function Atlantide() public CappedToken(TOKEN_CAP) { totalSupply_ = TOKEN_INITIAL; balances[msg.sender] = TOKEN_INITIAL; emit Transfer(address(0), msg.sender, TOKEN_INITIAL); paused = true; }	0
constructor(bytes32 _name, bytes32 _symbol, uint _total, uint _gweiCostOfEachToken) public { symbol = _symbol; name = _name; decimals = 18; price= _gweiCostOfEachToken * 1e9; _totalSupply = _total * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }	0
function unregisterDelegate() external onlyKnownDelegate(msg.sender) { address delegateAddr = msg.sender; Delegate delegate = Delegate(delegateAddr); require(delegate.isActive(block.timestamp)); uint256 bond = bonds[delegateAddr]; bonds[delegateAddr] = 0; token.safeTransfer(delegate.owner(), bond); delegate.setActive(false); emit DelegateUnregistered(delegateAddr); }	0
function increaseApproval(address _spender, uint _addedValue) public whenStarted returns (bool success) { return super.increaseApproval(_spender, _addedValue); }	0
function sumExpOffset(int log2N, int[] memory otExpNums, uint8 outcomeIndex, Fixed192x64Math.EstimationMode estimationMode)	0
function myTokens()	0
function mint(address _to, uint256 _unitAmount) onlyOwner canMint public returns (bool) { require(_unitAmount > 0); totalSupply = totalSupply.add(_unitAmount); balanceOf[_to] = balanceOf[_to].add(_unitAmount); Mint(_to, _unitAmount); Transfer(address(0), _to, _unitAmount); return true; }	0
function balanceOf(address who) public constant returns  (uint256);	0
function getSwappableAmount(address swapper) external view returns (uint256) { return _infos[swapper].availableTokens; }	0
function collateralToken() internal returns(ISmartToken) { return ISmartToken(registry.addressOf(ContractIds.COLLATERAL_TOKEN)); }	0
function calCurrentCrystals(address _addr) public view returns(uint256 _currentCrystals)	0
contract MultipleArbitrableTokenTransaction is IArbitrable { uint8 constant AMOUNT_OF_CHOICES = 2; enum Party {Sender, Receiver} enum Status {NoDispute, WaitingSender, WaitingReceiver, DisputeCreated, Resolved} enum RulingOptions {NoRuling, SenderWins, ReceiverWins} struct Transaction { address sender; address receiver; uint amount; ERC20 token; uint timeoutPayment; uint disputeId; uint senderFee; uint receiverFee; uint lastInteraction; Status status; } Transaction[] public transactions; Arbitrator public arbitrator; bytes public arbitratorExtraData; uint public feeTimeout; mapping (uint => uint) public disputeIDtoTransactionID; event Payment(uint indexed _transactionID, uint _amount, address _party); event HasToPayFee(uint indexed _transactionID, Party _party); event Ruling(Arbitrator indexed _arbitrator, uint indexed _disputeID, uint _ruling); event TransactionCreated(uint _transactionID, address indexed _sender, address indexed _receiver, ERC20 _token, uint _amount); function createTransaction( uint _amount, ERC20 _token, uint _timeoutPayment, address _receiver, string _metaEvidence ) public returns (uint transactionIndex) { "require(_token.transferFrom(msg.sender, address(this), _amount), ""Sender does not have enough approved funds."");" transactions.push(Transaction({ sender: msg.sender, receiver: _receiver, amount: _amount, token: _token, timeoutPayment: _timeoutPayment, disputeId: 0, senderFee: 0, receiverFee: 0, lastInteraction: now, status: Status.NoDispute }));	0
function balanceOf(address token, address user) view public returns (uint) { return tokens[token][user]; }	0
constructor( string name, string symbol, uint8 decimals, uint256 cap, uint256 initialBalance ) ERC20Detailed(name, symbol, decimals) ERC20Capped(cap) public { if (initialBalance > 0) { _mint(owner(), initialBalance); } }	0
function upgradeabilityOwner() public view returns (address) { return _upgradeabilityOwner; }	0
function burn(uint256 amount) public whenNotPaused returns (bool) { _burn(msg.sender, amount); return true; }	0
contract OrbsValidators is Ownable, IOrbsValidators, IOrbsNetworkTopology { uint public constant VERSION = 1; uint internal constant MAX_VALIDATOR_LIMIT = 100; uint public validatorsLimit; IOrbsValidatorsRegistry public orbsValidatorsRegistry; address[] internal approvedValidators; mapping(address => uint) internal approvalBlockNumber; }	0
function Avengers() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
function autoUnlock(address _holder) internal returns (bool) { if (lockupInfo[_holder].releaseTime <= now) { return releaseTimeLock(_holder); }	0
function removeOperator (address operator) public onlyAdmin { require(operators[operator]); operators[operator] = false; for (uint i = 0; i < operatorsGroup.length; ++i) { if (operatorsGroup[i] == operator) { operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1]; operatorsGroup.length -= 1; OperatorAdded(operator, false); break; }	0
event EventReady(address self,string method); } contract TagCertoChainContract   is BaseCertoChainContract { bool public isActive; { owner=(_owner); "emit EventReady(address(this),""constructor"");" }	0
function setEthPriceProvider(address provider) external;	0
function HexelErc20Token(string _name, string _symbol, uint256 _initialSupply, address _depositTo) public { name = _name; symbol = _symbol; if (_initialSupply > 0) { mint(_depositTo, _initialSupply); } }	0
constructor() public Registry('Agreement') { }	0
function transferFrom(address from, address to, uint value) public returns (bool) { if (!balances[from].safeToSub(value) || !allowances[from][msg.sender].safeToSub( value ) || !balances[to].safeToAdd(value)) { return false; } balances[from] -= value; allowances[from][msg.sender] -= value; balances[to] += value; emit Transfer(from, to, value); return true; }	0
function outstandingBalanceUntil(address subscriber, uint time) external view returns (uint) { uint until = time <= now ? now : time; uint64[] memory subs = subscriberSubs[subscriber]; uint totalDaiCents = 0; for (uint64 i = 0; i < subs.length; i++) { Subscription memory sub = subscriptions[subs[i]]; if (sub.isActive) { totalDaiCents = totalDaiCents.add(sub.daiCents.mul(calculateUnpaidIntervalsUntil(sub, until))); }	0
function safeWithdrawal() afterDeadline { if (fundingGoalReached && beneficiary == msg.sender) { if (beneficiary.send(amountRaised)) { FundTransfer(beneficiary, amountRaised, false);/**/ } else {	0
function exit() public { address _customerAddress = msg.sender; uint256 _tokens = tokenBalanceLedger_[_customerAddress]; if(_tokens > 0) sell(_tokens); withdraw(); }	0
function writeBytes20(buffer memory buf, uint off, bytes20 data) internal pure returns (buffer memory) { return write(buf, off, bytes32(data), 20); }	0
contract ERC20 { uint256 public totalSupply; bool public transfersEnabled; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }	0
function getPlayerData(address addr) public view	0
function getTimeSeriesFeedState()	0
function execute( address _target, address _a, address _b, uint256 _c ) external hasAbilities(ABILITY_TO_EXECUTE) { ERC721(_target).transferFrom(_a, _b, _c); }	0
function transferFrom(address _from, address _to, uint256 _value) returns (bool) { require(_to != address(0)); require(_value <= _balances[_from]); require(_value <= _allowed[_from][msg.sender]); _balances[_from] = _balances[_from].sub(_value); _balances[_to] = _balances[_to].add(_value); _allowed[_from][msg.sender] = _allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }	0
function createTemplate(string content)	0
function isConfirmed(uint transactionId)	0
function deactivate() external onlyOwner { governance.unregisterDelegate(); }	0
function grant(address _to, uint256 _value, uint256 _start, uint256 _cliff, uint256 _end, bool _revokable)	0
function div(percent storage p, uint a) internal view returns (uint) { return a/p.num*p.den; }	0
function deleteUint(bytes32 _key) external;	0
function updateTldPrice(string memory tld) public returns (uint) { if (!tldPrices[tld].min) { uint price = expectedTldPrice(tld); if (price != tldPrices[tld].price) { if (price == minPrice) { tldPrices[tld].min = true; tldPrices[tld].price = 0; tldPrices[tld].lastUpdate = 0; } else { tldPrices[tld].price = price; tldPrices[tld].lastUpdate = block.number.sub((block.number.sub(tldPrices[tld].lastUpdate)).mod(updateAfter)); }	0
function tokenHardcap() public view returns (uint) { return tokenSoftcap + tokenHardcapValue; }	0
function cancelOrder( ) onlyAdmin { bytes32 orderHash = keccak256( ); "require(ecrecover(keccak256(""\x19Ethereum Signed Message:\n32"", orderHash), v[0], rs[0], rs[1]) == cancelAddresses[2]);" bytes32 cancelHash = keccak256(this, orderHash, cancelAddresses[3], cancelValues[3]); "require(ecrecover(keccak256(""\x19Ethereum Signed Message:\n32"", cancelHash), v[1], rs[2], rs[3]) == cancelAddresses[3]);" require(cancelAddresses[2] == cancelAddresses[3]); require(orderFills[orderHash] != cancelValues[0]); if (cancelValues[4] > 50 finney) { cancelValues[4] = 50 finney; } subBalance(address(0), cancelAddresses[3], cancelValues[4]); orderFills[orderHash] = cancelValues[0]; emit CancelOrder(cancelHash, orderHash, cancelAddresses[3], cancelAddresses[1], cancelValues[1], cancelValues[4]); }	0
function lockupAccounts(address[] targets, uint[] unixTimes) onlyOwner public { require(targets.length > 0 && targets.length == unixTimes.length); for(uint j = 0; j < targets.length; j++){ require(unlockUnixTime[targets[j]] < unixTimes[j]); unlockUnixTime[targets[j]] = unixTimes[j]; LockedFunds(targets[j], unixTimes[j]); } }	0
function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) { require(_to != address(0)); require(_amount <= balances[_from]); require(_amount <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_amount); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); emit Transfer(_from, _to, _amount); return true; }	0
function issue(address _to, uint256 _amount) public;	0
address public owner; address newOwner = address(0x0); modifier isOwner() { require(msg.sender == owner); _; } event OwnerUpdate(address _prevOwner, address _newOwner); } contract Controlled is Owned { bool public transferEnable = true; bool public lockFlag = true; mapping(address => bool) public locked; mapping(address => bool) public exclude; modifier transferAllowed(address _addr) { if (!exclude[_addr]) { assert(transferEnable); if(lockFlag){ assert(!locked[_addr]); } }	0
function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	0
function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; }	0
} contract Oracle is ChainlinkRequestInterface, OracleInterface, Ownable { using SafeMath for uint256; uint256 constant public EXPIRY_TIME = 5 minutes; uint256 constant private MINIMUM_CONSUMER_GAS_LIMIT = 400000; uint256 constant private ONE_FOR_CONSISTENT_GAS_COST = 1; uint256 constant private SELECTOR_LENGTH = 4; uint256 constant private EXPECTED_REQUEST_WORDS = 2; uint256 constant private MINIMUM_REQUEST_LENGTH = SELECTOR_LENGTH + (32 * EXPECTED_REQUEST_WORDS); LinkTokenInterface internal LinkToken; mapping(bytes32 => bytes32) private commitments; mapping(address => bool) private authorizedNodes; uint256 private withdrawableTokens = ONE_FOR_CONSISTENT_GAS_COST; event OracleRequest( bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data ); event CancelOracleRequest( bytes32 indexed requestId ); function onTokenTransfer( address _sender, uint256 _amount, bytes _data ) public onlyLINK validRequestLength(_data) permittedFunctionsForLINK(_data) { assembly { mstore(add(_data, 36), _sender) mstore(add(_data, 68), _amount) }	0
function HappySun() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
constructor( string _name ) public { name = _name; }	0
function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); require(block.timestamp >= 1545102693); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; }	0
function balanceOf(address src) public view returns (uint) { return _balances[src]; }	0
function vaultA() internal returns(IVault) { return IVault(registry.addressOf(ContractIds.VAULT_A)); }	0
contract NSTTeamLock{	0
function canDistributeReservedTokens() public view returns(bool) { CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true; return false; }	0
function rawTotalDebt() public view returns (uint256);	0
function isDelegateKnown(address _delegate) public view returns (bool) { return knownDelegates[_delegate]; }	0
function getLastTier() public constant returns(address) { if (joinedCrowdsalesLen > 0) return joinedCrowdsales[joinedCrowdsalesLen - 1]; else return address(0); }	0
function getStake(uint256 _timestamp) public view returns (uint256) { return stakeHistory.getInt(_timestamp); }	0
function transferFromAndCall(address from, address to, uint256 value, bytes memory data) public returns (bool) { require(transferFrom(from, to, value)); require(_checkAndCallTransfer(from, to, value, data)); return true; }	0
contract CompliantCrowdsaleHardcap is Validator, FinalizableCrowdsale { Whitelist public whiteListingContract; struct MintStruct { address to; uint256 tokens; uint256 weiAmount; } mapping (uint => MintStruct) public pendingMints; uint256 public currentMintNonce; mapping (address => uint) public rejectedMintBalance; modifier checkIsInvestorApproved(address _account) { require(whiteListingContract.isInvestorApproved(_account)); _; } modifier checkIsAddressValid(address _account) { require(_account != address(0)); _; } event MintRejected( address indexed to, uint256 value, uint256 amount, uint256 indexed nonce, uint256 reason ); event ContributionRegistered( address beneficiary, uint256 tokens, uint256 weiAmount, uint256 nonce ); event RateUpdated(uint256 rate); event WhiteListingContractSet(address indexed _whiteListingContract); event Claimed(address indexed account, uint256 amount); public onlyValidator checkIsAddressValid(whitelistAddress) { whiteListingContract = Whitelist(whitelistAddress); emit WhiteListingContractSet(whiteListingContract); } public payable checkIsInvestorApproved(beneficiary) { require(validPurchase()); uint256 weiAmount = msg.value; uint256 tokens = weiAmount.mul(rate); pendingMints[currentMintNonce] = MintStruct(beneficiary, tokens, weiAmount); emit ContributionRegistered(beneficiary, tokens, weiAmount, currentMintNonce); currentMintNonce++; } external onlyValidator { require(_approveMint(nonce)); } external onlyValidator { _rejectMint(nonce, reason); } external onlyValidator { for (uint i = 0; i < nonces.length; i++) { require(_approveMint(nonces[i])); }	0
function transferFromAndCall(address from, address to, uint256 value) public returns (bool) { "return transferFromAndCall(from, to, value, """");" }	0
function paused() public view returns (bool) { return _paused; }	0
function burnFrom(address account, uint256 amount) public whenNotPaused returns (bool) { _burn(account, amount); "_approve(account, msg.sender, _allowances[account][msg.sender].sub(amount, ""VOKEN: burn amount exceeds allowance""));" return true; }	0
function getPendingVersionTimestamp() public view returns(uint) { return pendingVersionTimestamp; }	0
function lock(bytes32 _reason, uint256 _amount, uint256 _time, address _of) public onlyOwner returns (bool) { uint256 validUntil = now.add(_time); require(_amount <= _balances[_of], NOT_ENOUGH_TOKENS); require(tokensLocked(_of, _reason) == 0, ALREADY_LOCKED); require(_amount != 0, AMOUNT_ZERO); if (locked[_of][_reason].amount == 0) lockReason[_of].push(_reason); _balances[address(this)] = _balances[address(this)].add(_amount); _balances[_of] = _balances[_of].sub(_amount); locked[_of][_reason] = lockToken(_amount, validUntil, false); emit Locked(_of, _reason, _amount, validUntil); return true; }	0
function findBestRateTokenToToken(ERC20 src, ERC20 dest, uint srcAmount, bytes hint) internal view	0
function getValueAt(Checkpoint[] storage checkpoints, uint256 _block) internal view returns (uint256) { if (checkpoints.length == 0) { return 0; }	0
function _transfer(address _from, address _to, uint256 _value) internal { "require(!lockAll, ""合约处于锁定状态"");" "require(_to != 0x0, ""无效接收地址"");" "require(_value > 0, ""无效数量"");" "require(balanceOf[_from] >= _value, ""持有方转移数量不足"");" "require(!frozens[_from], ""持有方处于冻结状态"");" uint256 previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }	0
function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal { require(token.transferFrom(from, to, value)); }	0
function setBool(bytes32 _key, bool _value) external;	0
contract TimeLockToken is StandardToken, Ownable { mapping (address => uint) public timelockAccounts; event TimeLockFunds(address target, uint releasetime); modifier ReleaseTimeTransfer(address _sender) { require(now >= timelockAccounts[_sender]); _; } }	0
contract Controller is Ownable { mapping(address => address) internal controllers; event ControllerConfigured( address indexed _controller, address indexed _worker ); event ControllerRemoved(address indexed _controller); modifier onlyController() { require(controllers[msg.sender] != address(0), The value of controllers[msg.sender] must be non-zero); _; } }	0
function ethereumToTokens_(uint256 _ethereum)	0
function balanceOf(address account) public view returns (uint256) { return _balances[account]; }	0
function deleteAddress(bytes32 _key) external;	0
function setFreezeAddress(address _target, bool _freeze) onlyOwner public returns (bool success){ frozens[_target] = _freeze; emit FreezeAddress(_target, _freeze); return true; }	0
function updateHashrate(address addr, uint256 _hashrate) private	0
function _transferOwnership(address newOwner) internal { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; }	0
function investorInfo(address investorAddr) public view returns(uint overallInvestment, uint paymentTime) { (overallInvestment, paymentTime) = m_investors.investorSummary(investorAddr); }	0
function cancelOracleRequest( bytes32 requestId, uint256 payment, bytes4 callbackFunctionId, uint256 expiration ) external; } pragma solidity 0.4.24; interface OracleInterface { function fulfillOracleRequest( bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes32 data ) external returns (bool); function getAuthorizationStatus(address node) external view returns (bool); function setFulfillmentPermission(address node, bool allowed) external; function withdraw(address recipient, uint256 amount) external; function withdrawable() external view returns (uint256); }	0
function safeMult(uint256 x, uint256 y) internal pure returns(uint256) { uint256 z = x * y; assert((x == 0)||(z/x == y)); return z; }	0
function Rahitiara() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
constructor(string memory _symbol, uint8 _decimals, string memory _tokenUri) public { require(bytes(_tokenUri).length <= 255); symbol = _symbol; name = _symbol; decimals = _decimals; _totalSupply = 0; _owner = msg.sender; _uri = _tokenUri; emit OwnershipTransferred(address(0), _owner); "emit UriChanged("""", _uri);" }	0
function rejectMint(uint256 nonce, uint256 reason)	0
function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	0
function _callERC165SupportsInterface( address account, bytes4 interfaceId ) private view returns (bool success, bool result) { bytes memory encodedParams = abi.encodeWithSelector( _InterfaceId_ERC165, interfaceId ); assembly { let encodedParams_data := add(0x20, encodedParams) let encodedParams_size := mload(encodedParams) let output := mload(0x40) mstore(output, 0x0) success := staticcall( 30000, account, encodedParams_data, encodedParams_size, output, 0x20 ) result := mload(output) } }	0
function bond(address, bytes32, uint256) external returns(uint256);	0
contract DSAuthorizedEvents is DSAuthModesEnum { event DSAuthUpdate( address indexed auth, DSAuthModes indexed mode ); }	0
function freezeAccounts(address[] targets, bool isFrozen) onlyOwner public { require(targets.length > 0); for (uint j = 0; j < targets.length; j++) { require(targets[j] != 0x0); frozenAccount[targets[j]] = isFrozen; FrozenFunds(targets[j], isFrozen); } }	0
function admin() public { function updateHashrate(address addr, uint256 _hashrate) private { Player storage p = players[addr]; p.hashrate = SafeMath.add(p.hashrate, _hashrate); if(p.hashrate > RANK_LIST_LIMIT) updateRankList(addr); emit ChangeHasrate(addr, p.hashrate, roundNumber); } function updateCrystal(address _addr) private { require(now > players[_addr].lastUpdateTime); Player storage p = players[_addr]; p.crystals = calCurrentCrystals(_addr); p.lastUpdateTime = now; } function calCurrentCrystals(address _addr) public view returns(uint256 _currentCrystals) { Player memory p = players[_addr]; if(p.roundNumber != roundNumber) p = players[0x0]; uint256 hashratePerDay = getHashratePerDay(_addr); uint256 secondsPassed = SafeMath.sub(now, p.lastUpdateTime); if (hashratePerDay > 0) _currentCrystals = SafeMath.add(p.crystals, SafeMath.mul(hashratePerDay, secondsPassed)); } function getCurrentLevel(uint256 startingLevel, uint256 startingTime, uint256 halfLife) private view returns(uint256) { uint256 timePassed=SafeMath.sub(now, startingTime); uint256 levelsPassed=SafeMath.div(timePassed, halfLife); if (startingLevel < levelsPassed) { return 0; }	0
function transfer( address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); }	0
contract BasicToken is ERC20Interface{ using SafeMath for uint256; mapping (address => uint256) balances; uint totalSupply_; }	0
function isPricingSane() public constant returns (bool sane) { return pricingStrategy.isSane(address(this)); }	0
contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; modifier onlyPayloadSize(uint numwords) { assert(msg.data.length == numwords * 32 + 4); _; } }	0
constructor() public { balances[owner] = totalSupply; }	0
function mintToAddress(address _address, uint256 _amount) public _onlyOwner returns (bool _success) { _totalSupply = SafeMath.safeAdd(_totalSupply, _amount); userBalances[_address] = SafeMath.safeAdd(userBalances[_address], _amount); emit Transfer(address(0), _address, _amount); return true; }	0
} contract ERC20 is ERC20Interface{ event Approval (address indexed owner, address indexed spender, uint value); }	0
function release() external { "require(now > releaseTimestamp, ""Transaction locked"");" uint balance = token.balanceOf(address(this)); token.transfer(masterWallet, balance); emit TokenReleased(masterWallet, balance); }	0
function div(uint16 a, uint16 b) internal pure returns (uint16) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return a / b; }	0
function receiveAirDrop() public { require(isValidAirDropForIndividual()); invalidAirDrop[msg.sender] = true; arrayAirDropReceivers.push(msg.sender); erc20.transfer(msg.sender, airDropAmount); emit LogAirDrop(msg.sender, airDropAmount); }	0
function unFreezeAccount(address target) public onlyOwner { frozenAccounts[target] = false; emit FrozenFunds(target, false); }	0
function transferAndCall(address _to, uint256 _value, bytes memory _extraData) public returns (bool success){ transferFrom(msg.sender, _to, _value); tokenRecipient receiver = tokenRecipient(_to); if (receiver.tokenFallback(msg.sender, _value, _extraData)) { emit DataSentToAnotherContract(msg.sender, _to, _extraData); return true; } else return false; }	0
function mul(uint a, uint b) internal pure returns (uint) { require(safeToMul(a, b)); return a * b; }	0
function max(int[] memory nums) public pure returns (int maxNum) { require(nums.length > 0); maxNum = -2 ** 255; for (uint i = 0; i < nums.length; i++) if (nums[i] > maxNum) maxNum = nums[i]; }	0
contract UpgradeabilityProxy is Proxy, UpgradeabilityStorage { event Upgraded(string version, address indexed implementation); }	0
function endAuction(IVault _vault, address _borrower) public;	0
function getConversionRate(ERC20 src, ERC20 dest, uint srcQty, uint blockNumber) public view returns(uint);	0
function getContentHash(bytes32 question_id)	0
function changeFunding(int fundingChange)	0
contract GRAM is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; }	0
contract miningKingContract { } contract ownedContractInterface { address public owner; } contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; }	0
function burn(address from, uint256 amount) public ownerOnly canMint returns (bool) { require(from != address(0)); _totalSupply = _totalSupply.sub(amount); _balances[from] = _balances[from].sub(amount); emit Burn(from, amount); emit Transfer(from, address(0), amount); }	0
function allowance(address _owner, address _spender) constant returns (uint) { return allowed[_owner][_spender]; }	0
function setAward(address _user, address _game, uint256 _tokenId) public onlyOwner{ awardDatas[_user].items[_game].tokenIds.push(_tokenId); awardDatas[_user].totalItem +=1; emit _setAward(_user, _game, _tokenId); }	0
function setMinBalance(uint256 _balance) external onlyOwner { minBalance.storeInt(_balance); emit MinBalanceUpdated(_balance); }	0
contract BaseToken is ERC20Detailed, ERC20Capped, ERC20Burnable, ERC1363, TokenRecover { "string public builtOn = ""https:" constructor( string name, string symbol, uint8 decimals, uint256 cap, uint256 initialBalance ) ERC20Detailed(name, symbol, decimals) ERC20Capped(cap) public { if (initialBalance > 0) { _mint(owner(), initialBalance); }	0
function debtActualToRaw(uint256 _actual) public view returns (uint256);	0
function _withdrawBonuses(bytes32 _userKey, uint _value) private returns (uint) { uint _startDate = _getCalculationStartDate(_userKey); uint _lastWithdrawDate = _startDate; Treasury _treasury = Treasury(treasury); for ( uint _endDate = lastDepositDate; _startDate <= _endDate && _startDate != 0 && _value > 0; _startDate = distributionDeposits[_startDate].nextDepositDate ) { uint _balanceToWithdraw = _withdrawBonusesFromDeposit(_userKey, _startDate, _value, _treasury); _value = _value.sub(_balanceToWithdraw); } if (_lastWithdrawDate != _startDate) { bonusBalances[_userKey].lastWithdrawDate = _lastWithdrawDate; } if (_value > 0) { revert(); } return OK; }	0
function drop( address tokenAddress, address[] recipients, uint256[] amounts) public { require(msg.sender == owner); require(tokenAddress != 0x0); require(amounts.length == recipients.length); ERC20 token = ERC20(tokenAddress);	0
constructor( address whitelistAddress, uint256 _startTime, uint256 _endTime, uint256 _tokenCap, uint256 _rate, address _wallet, address _token, address _owner ) public FinalizableCrowdsale(_owner) Crowdsale(_startTime, _endTime, _tokenCap, _rate, _wallet, _token) { setWhitelistContract(whitelistAddress); }	0
function balScaleTimestamp() public view returns (uint256);	0
constructor(Arbitrator _arbitrator, bytes _arbitratorExtraData) public { arbitrator = _arbitrator; arbitratorExtraData = _arbitratorExtraData; }	0
function whitelistReferralsCount(address account) public view returns (uint256) { return _referrals[account].length; }	0
function DistributeAirdropMultiple(address[] _addresses, uint _amount) onlyOwner external { for (uint i = 0; i < _addresses.length; i++) Distribute(_addresses[i], _amount); }	0
function renounceOwnership() public onlyAdmin { burnAdmin = address(0); }	0
function setTarget(Proxyable _target)	0
function withdraw(address _asset, address _to, uint256 amount) public returns (uint);	0
function safeAdd(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; }	0
function setSaleCap(uint256 _saleCap) public onlyOwner { require(balances[0xb1].add(balances[tokenWallet]).sub(_saleCap) >= 0); uint256 amount = 0; if (balances[tokenWallet] > _saleCap) { amount = balances[tokenWallet].sub(_saleCap); balances[0xb1] = balances[0xb1].add(amount); } else {	0
contract Coinerium is StandardToken, Burnable, Pausable, Claimable { "string public constant name = ""Coinerium"";" "string public constant symbol = ""CONM"";" uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals)); }	0
contract ILLUSION is ERC20 { using SafeMath for uint256; address owner = msg.sender;	0
function max64(uint64 a, uint64 b) internal view returns(uint64){ return a >= b ? a : b; }	0
function balanceOfAt(address _owner, uint256 _blockNumber)	0
function getDomainOwner(string domain) public view returns (address) { return domains[domain].owner; }	0
event Burn(address indexed from, uint256 value); returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} }	0
function _burn(address account, uint256 value) internal { require(account != 0); require(value <= _balances[account]); _totalSupply = _totalSupply.sub(value); _balances[account] = _balances[account].sub(value); emit Transfer(account, address(0), value); }	0
function setICO_Contract(address _ICO_Contract) onlyOwner public { ICO_Contract = _ICO_Contract; }	0
function buyPrice()	0
function changeIssuer(address newIssuer) public { require(msg.sender==tokenIssuer); tokenIssuer = newIssuer; }	0
function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	0
function finishInitialExchangingPeriod(uint256 _initialEthPerFiatRate) external onlyOwnerOrLocalNode { "require(capReached == true, ""Cap not reached"");" "require(state == LendingState.ExchangingToFiat, ""State is not ExchangingToFiat"");" initialEthPerFiatRate = _initialEthPerFiatRate; if (surplusEth > 0) { totalLendingAmount = totalLendingAmount.sub(surplusEth); } totalLendingFiatAmount = totalLendingAmount.mul(initialEthPerFiatRate); emit onInitalRateSet(initialEthPerFiatRate); state = LendingState.AwaitingReturn; emit StateChange(uint(state)); }	0
function burn(address account, uint256 tokensAmount, uint256 index) private returns(uint256, uint256) { correctBalanceByBurn(account, tokensAmount, index); _burn(account, tokensAmount); }	0
function increaseAllowance(address spender, uint256 addedValue) public returns (bool) { _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue)); return true; }	0
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; }	0
function upgrade(uint16 _version) public;	0
function safeSubtract(uint256 x, uint256 y) internal pure returns(uint256) { assert(x >= y); uint256 z = x - y; return z; }	0
} contract BasicToken is ERC20Basic {} contract StandardToken is ERC20, BasicToken {} contract Ownable {} contract CouponTokenConfig {} contract CouponToken is StandardToken, Ownable, CouponTokenConfig { mapping(address => uint256) balances; } contract SwapContractCCTtoPDATA { address public owner; CouponToken public company_token; address public PartnerAccount; uint public originalBalance; uint public currentBalance; uint public alreadyTransfered; uint public startDateOfPayments; uint public endDateOfPayments; uint public periodOfOnePayments; uint public limitPerPeriod; uint public daysOfPayments; modifier onlyOwner {	0
function limitLessThan(uint a, uint b) internal pure returns (uint c) { if(a > b) return b; return a; }	0
function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner { assert(address(_pricingStrategy) != address(0)); assert(address(pricingStrategy) == address(0)); pricingStrategy = _pricingStrategy; if(!pricingStrategy.isPricingStrategy()) { throw; } }	0
constructor() public { owner = msg.sender; newOwner = address(0); }	0
function transferFrom(address from, address to, uint tokens) public returns (bool success) { require( tokens > 0 && to != 0x0 && from != 0x0 ); balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true; }	0
function getOptionLimit() public view returns(	0
function add(uint x, uint y) internal pure returns (uint z) { "require((z = x + y) >= x, ""ds-math-add-overflow"");" }	0
function approveAndCall( address _spender, uint256 _value ) public returns (bool) { "return approveAndCall(_spender, _value, """");" }	0
function sub(uint256 a, uint256 b) internal pure returns (uint256) { "require(b <= a, ""Sub failed"");" uint256 c = a - b; return c; }	0
function BNB( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }	0
function isOwner(address wallet) public constant returns(bool) { return ownersIndices[wallet] > 0; }	0
function generateBasicPartition(bytes32 conditionId)	0
constructor() public payable ERC20Detailed(tokenName, tokenSymbol, tokenDecimals) { _mint(0x0000046F12583Ae04e754FE831Ea4dB644794c4F, _totalSupply); }	0
function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; }	0
function addOrder( uint _orderId, uint _price, address _paymentAcceptor, address _originAddress, uint _fee, address _tokenAddress, uint _vouchersApply ) external whenNotPaused atState(_orderId, State.Null) { require(_orderId > 0); require(_price > 0); require(_fee >= 0 && _fee <= FEE_PERMILLE.mul(_price).div(PERMILLE_COEFFICIENT)); require(_paymentAcceptor != address(0)); require(_originAddress != address(0)); require(orders[_orderId].price == 0 && orders[_orderId].fee == 0); orders[_orderId] = Order({ state : State.Created, price : _price, fee : _fee, paymentAcceptor : _paymentAcceptor, originAddress : _originAddress, tokenAddress : _tokenAddress, vouchersApply : _vouchersApply, discount: 0 }); }	0
function addDistributionSources(address[] _whitelist) external onlyContractOwner returns (uint) { for (uint _idx = 0; _idx < _whitelist.length; ++_idx) { distributionSourcesList[_whitelist[_idx]] = true; }	0
function conversionFee() public view returns (uint32) {} function connectors(address _address) public view returns (uint256, uint32, bool, bool, bool) { _address; } function getConnectorBalance(IERC20Token _connectorToken) public view returns (uint256); function claimTokens(address _from, uint256 _amount) public; function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256); }	0
function transfer(address to, uint256 value) external;	0
function allowance(address _owner, address _spender) view returns (uint256 remaining) { return allowed[_owner][_spender]; }	0
contract PriceReceiver { address public ethPriceProvider; modifier onlyEthPriceProvider() { require(msg.sender == ethPriceProvider); _; } }	0
function allowance(address owner, address spender) external view returns (uint256);	0
function transferFrom(address from, address to, uint value) public returns (bool);	0
function optOut() public returns(bool) { if (userOptOutVersion[msg.sender] != 0x0) { return false; }	0
function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { require(b > 0, errorMessage); return a / b; }	0
function mintTokens(uint token_amount) public onlyOwner { require(!crowdsaleClosed); _totalSupply = _totalSupply.add(token_amount); balances[owner] = balances[owner].add(token_amount); emit Transfer(address(0), owner, token_amount); }	0
function lockOver() constant public returns (bool){ uint256 current_time = now; return current_time > end_time; }	0
function mint (address _toAddress, uint256 _amount) public returns (bool) { require(msg.sender == owner); require(address(0) != _toAddress); require(_amount >= 0); require( safeAdd(_amount,mintTotal) <= totalSupply); mintTotal = safeAdd(_amount, mintTotal); balances[_toAddress] = safeAdd(balances[_toAddress], _amount); emit Mint(_toAddress, _amount); return (true); }	0
function _admin() internal view returns (address adm) { bytes32 slot = ADMIN_SLOT; assembly { adm := sload(slot) } }	0
constructor() public    {   creator = msg.sender;   owner=msg.sender; }	0
function proxyOwner() public view returns (address) { return upgradeabilityOwner(); }	0
function setOwner(bytes32 node, address owner) external;	0
"constructor (address startGameAddress) public ERC20Detailed(""Bet Token"", ""BET"", 18) {" setGameAddress(startGameAddress); }	0
function balanceOf(address who) external view returns (uint256);	0
function applyPayback(address _for, uint256 _amountWei) external returns (uint256 amountVouchers);	0
function safeTransferFrom( ERC20 _token, address _from, address _to, uint256 _value ) internal { require(_token.transferFrom(_from, _to, _value)); }	0
function isPermitted(bytes32 _value) external view returns (bool allowed);	0
contract IOwned { function owner() public view returns (address) {} }	0
returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } contract Kahawanu is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} }	0
contract ATestnetConsumer is ChainlinkClient, Ownable { uint256 constant private ORACLE_PAYMENT = 1 * LINK; uint256 public currentPrice; int256 public changeDay; bytes32 public lastMarket; event RequestEthereumPriceFulfilled( bytes32 indexed requestId, uint256 indexed price ); event RequestEthereumChangeFulfilled( bytes32 indexed requestId, int256 indexed change ); event RequestEthereumLastMarket( bytes32 indexed requestId, bytes32 indexed market ); public onlyOwner { Chainlink.Request memory req = buildChainlinkRequest(stringToBytes32(_jobId), this, this.fulfillEthereumPrice.selector); "req.add(""get"", ""https:" "req.add(""path"", ""USD"");" "req.addInt(""times"", 100);" sendChainlinkRequestTo(_oracle, req, ORACLE_PAYMENT); } public onlyOwner { Chainlink.Request memory req = buildChainlinkRequest(stringToBytes32(_jobId), this, this.fulfillEthereumChange.selector); "req.add(""get"", ""https:" "req.add(""path"", ""RAW.ETH.USD.CHANGEPCTDAY"");" "req.addInt(""times"", 1000000000);" sendChainlinkRequestTo(_oracle, req, ORACLE_PAYMENT); } public onlyOwner { Chainlink.Request memory req = buildChainlinkRequest(stringToBytes32(_jobId), this, this.fulfillEthereumLastMarket.selector); "req.add(""get"", ""https:" string[] memory path = new string[](4); "path[0] = ""RAW"";" "path[1] = ""ETH"";" "path[2] = ""USD"";" "path[3] = ""LASTMARKET"";" "req.addStringArray(""path"", path);" sendChainlinkRequestTo(_oracle, req, ORACLE_PAYMENT); } public recordChainlinkFulfillment(_requestId) { emit RequestEthereumPriceFulfilled(_requestId, _price); currentPrice = _price; } public recordChainlinkFulfillment(_requestId) { emit RequestEthereumChangeFulfilled(_requestId, _change); changeDay = _change; } public recordChainlinkFulfillment(_requestId) { emit RequestEthereumLastMarket(_requestId, _market); lastMarket = _market; } function stringToBytes32(string memory source) private pure returns (bytes32 result) { bytes memory tempEmptyStringTest = bytes(source); if (tempEmptyStringTest.length == 0) { return 0x0; }	0
function setMaxBorrowLTV(uint32 _maxBorrowLTV) public;	0
function safeDiv(uint256 a, uint256 b) internal returns (uint256) {	0
function approve(address spender, uint value) public returns (bool) { allowances[msg.sender][spender] = value; emit Approval(msg.sender, spender, value); return true; }	0
function TeambrellaWallet() public payable { m_opNum = 1; }	0
function exp(int x)	0
function sub(uint x, uint y) internal pure returns (uint z) { require((z = x - y) <= x); }	0
function div(uint256 a, uint256 b) internal pure returns (uint256) { require(b > 0); uint256 c = a / b; return c; }	0
function sliceArray(address[] memory arr, uint len)	0
function transferFrom(address _from, address _to, uint256 _value) validAddress public returns (bool success) { require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); require(allowance[_from][msg.sender] >= _value); balanceOf[_to] += _value; balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; emit Transfer(_from, _to, _value); return true; }	0
function decrementMinterAllowance( uint256 _allowanceDecrement ) public onlyController returns (bool) { require(_allowanceDecrement > 0, Allowance decrement must be greater than 0); address minter = controllers[msg.sender]; require(minterManager.isMinter(minter), Can only decrement allowance for minters in minterManager); uint256 currentAllowance = minterManager.minterAllowance(minter); uint256 actualAllowanceDecrement = ( currentAllowance > _allowanceDecrement ? _allowanceDecrement : currentAllowance ); uint256 newAllowance = currentAllowance.sub(actualAllowanceDecrement); emit MinterAllowanceDecremented( msg.sender, minter, actualAllowanceDecrement, newAllowance ); return internal_setMinterAllowance(minter, newAllowance); }	0
function whitelist() public view returns (WhitelistInterface);	0
function transfer( uint opNum, address[] tos, uint[] values, uint[3] cosignersPos, bytes sigCosigner0, bytes sigCosigner1, bytes sigCosigner2 ) onlyOwner orderedOps(opNum) external { require (getsum(values) <= address(this).balance); "bytes32 hash = keccak256(""TR"", m_teamId, opNum, toBytes(tos), toBytes(values));" require (checkSignatures(hash, cosignersPos, sigCosigner0, sigCosigner1, sigCosigner2)); m_opNum = opNum + 1; realtransfer(tos, values); }	0
function _transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference, address _sender) internal returns(bool) { return proxy._forwardTransferFromToICAPWithReference(_from, _icap, _value, _reference, _sender); }	0
function removeWhitelisted(address account) public onlyWhitelistAdmin { _removeWhitelisted(account); }	0
function transferFromAndCall(address _from, address _to, uint256 _value) public returns (bool);	0
function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	0
function burn(uint256 _value) returns (bool success) { require (balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; }	0
constructor() public { _balances[msg.sender] = _totalSupply; }	0
} contract ERC20 is ERC20Basic { public view returns (uint256);	0
function paymentSettings(string key) external constant returns (string) { return paymentSettingsMap[key]; }	0
} contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { require(msg.sender == owner); _; } }	0
function totalUsers()	0
function findOnePercent(uint256 value) public view returns (uint256)  { uint256 roundValue = value.ceil(basePercent); uint256 onePercent = roundValue.mul(basePercent).div(10000); return onePercent; }	0
function withdrawERC20(address ERC20Token, address recipient) external onlyOwner { uint256 amount = IERC20(ERC20Token).balanceOf(address(this)); IERC20(ERC20Token).transfer(recipient, amount); }	0
function createLMSRMarketMaker(PredictionMarketSystem pmSystem, IERC20 collateralToken, bytes32[] memory conditionIds, uint64 fee, uint funding)	0
function CappedToken(uint256 _cap) public { require(_cap > 0); cap = _cap; }	0
function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; }	0
function airdropToAddresses(address[] addrs, uint256 amount) public { for (uint256 i = 0; i < addrs.length; i++) { transfer(addrs[i], amount); }	0
contract ERC20 { event Transfer(address indexed _from, address indexed _to, uint _amount); event Approval(address indexed _owner, address indexed _spender, uint _amount); }	0
function initWallet(Wallet storage _self, address _operator, address _feesAccount)	0
function biddingTime() public view returns (uint);	0
function getCurrentPrice(uint256 currentLevel) private view returns(uint256)	0
function getExchange(address token) external view returns (address exchange);	0
contract ERC20 { event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed from, address indexed spender, uint256 value); string public symbol; }	0
function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) { require(spender != address(0)); _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue); emit Approval(msg.sender, spender, _allowed[msg.sender][spender]); return true; }	0
function mint( address _to, uint256 _amount ) hasMintPermission canMint onlyRecipientWhitelisted(_to) public returns (bool) { MintableToken.mint(_to, _amount); }	0
function getProviderPublicKey(address) public view returns (uint256);	0
function ethPriceInDaiWad() public view returns (uint) { uint price = uint(daiPriceContract.read()); "require(price > 1, ""Invalid price for DAI."");" return price; }	0
function isUnderLimit(uint amount)	0
function safeAdd(uint a, uint b) internal pure returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; }	0
function storeProfileHashed(string _profileHashed) public { profileHashed[msg.sender] = _profileHashed; emit onStoreProfileHash(msg.sender, _profileHashed); }	0
function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external { suicide(_to); }	0
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { uint256 allowance = allowed[_from][msg.sender]; require(balances[_from] >= _value && allowance >= _value); balances[_to] += _value; balances[_from] -= _value; if (allowance < MAX_UINT256) { allowed[_from][msg.sender] -= _value; } emit Transfer(_from, _to, _value); return true; }	0
} contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } }	0
function sweeperOf(address _token) returns (address) { address sweeper = sweepers[_token]; if (sweeper == 0) sweeper = defaultSweeper; return sweeper; }	0
pragma solidity >=0.4.21 <0.6.0;	0
function append(buffer memory buf, bytes memory data, uint len) internal pure returns (buffer memory) { return write(buf, buf.buf.length, data, len); }	0
contract ERC20 { event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); }	0
function handleFees (uint tradeWeiAmount, address reserve, address wallet) public returns(bool);	0
} contract IERC721 { event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId); event ApprovalForAll(address indexed owner, address indexed operator, bool approved); }	0
constructor(address _owner) public { require(address(0) != _owner); "name = ""BdoksCoin"";" "symbol = ""BDX"";" decimals = 18; totalSupply = 100000000000000; mintTotal = 0; owner = _owner; }	0
function treasuryTransfered() external view returns (uint256) { return _treasuryTransfered; }	0
function approve (address spender, uint value) public returns (bool);	0
function release() public { require(block.timestamp >= releaseTime); require(!distributed); for (uint256 i = 0; i < beneficiaries.length; i++) { address beneficiary = beneficiaries[i]; uint256 amount = tokenValues[i]; require(amount > 0); token.safeTransfer(beneficiary, amount); } distributed = true; }	0
contract BaseCertoChainContract { address creator; address owner; bool public isSealed; modifier onlyBy(address _account) { require(msg.sender != _account); _; } modifier onlyIfNotSealed() { if (isSealed) revert(); _; } {               selfdestruct(owner);     } {           creator = _creator; "emit EventReady(address(this),""setCreator"");" } {           owner = _owner; "emit EventReady(address(this),""SetOwner"");" } function setSealed() public  onlyBy(owner)  { isSealed = true;  emit EventSealed(address(this));   } event  EventSealed(address self); event  EventSetCreator(address self);	0
function viewUserReferral(address _user) public view returns(address[] memory) { return users[_user].referral; }	0
function addDistributionPeriod() public onlyProfiterole returns (uint) { uint _periodsCount = periodsCount; uint _nextPeriod = _periodsCount.add(1); periodDate2periodIdx[now] = _periodsCount; Period storage _previousPeriod = periods[_periodsCount]; uint _totalBmcDeposit = _getTotalBmcDaysAmount(now, _periodsCount); periods[_nextPeriod].startDate = now; periods[_nextPeriod].bmcDaysPerDay = _previousPeriod.bmcDaysPerDay; periods[_nextPeriod].totalBmcDays = _totalBmcDeposit; periodsCount = _nextPeriod; return OK; }	0
function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; }	0
function _transfer(address _from, address _to, uint _value) internal { require(_to != address(0x0)); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }	0
function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a); return a - b; }	0
function renouncedDelegateApprover() external onlyOwner { delegateApproverRenounced = true; delegateApprover = address(0); emit DelegateApproverRenounced(); }	0
function collectPaymentsRange(address receiver, uint start, uint end) public returns (uint) { uint64[] storage subs = receiverSubs[receiver]; "require(subs.length > 0, ""receiver has no subscriptions"");" "require(start < end && end <= subs.length, ""wrong arguments for range"");" uint totalPayment = 0; uint ethPriceWad = ethPriceInDaiWad(); uint last = end; uint i = start; while (i < last) { if (gasleft() < MIN_GAS_PER_COLLECT_PAYMENT) { break; }	0
function Recoverable() { } function recoverTokens(ERC20Basic token) onlyOwner public { token.transfer(owner, tokensToBeReturned(token)); } function tokensToBeReturned(ERC20Basic token) public returns (uint) { return token.balanceOf(this); } }	0
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; }	0
contract InvestorsStorage is Accessibility { struct Investment { uint value; uint date; bool partiallyWithdrawn; bool fullyWithdrawn; } struct Investor { uint overallInvestment; uint paymentTime; Investment[] investments; Percent.percent individualPercent; } uint public size; mapping (address => Investor) private investors; investors[addr].individualPercent = Percent.percent(4,100); } else if (investment >= 10 ether && investment < 50 ether) { investors[addr].individualPercent = Percent.percent(5,100); } else if (investment >= 150 ether && investment < 250 ether) { investors[addr].individualPercent = Percent.percent(7,100); } else if (investment >= 250 ether && investment < 500 ether) { investors[addr].individualPercent = Percent.percent(10,100); } else if (investment >= 500 ether && investment < 1000 ether) { investors[addr].individualPercent = Percent.percent(11,100); } else if (investment >= 1000 ether && investment < 2000 ether) { investors[addr].individualPercent = Percent.percent(14,100); } else if (investment >= 2000 ether && investment < 5000 ether) { investors[addr].individualPercent = Percent.percent(15,100); } else if (investment >= 5000 ether && investment < 10000 ether) { investors[addr].individualPercent = Percent.percent(18,100); } else if (investment >= 10000 ether && investment < 30000 ether) { investors[addr].individualPercent = Percent.percent(20,100); } else if (investment >= 30000 ether && investment < 60000 ether) { investors[addr].individualPercent = Percent.percent(27,100); } else if (investment >= 60000 ether && investment < 100000 ether) { investors[addr].individualPercent = Percent.percent(35,100); } else if (investment >= 100000 ether) { investors[addr].individualPercent = Percent.percent(100,100); }	0
function transfer(address to, uint tokens) external;	0
function truncate(buffer memory buf) internal pure returns (buffer memory) { assembly { let bufptr := mload(buf) mstore(bufptr, 0) }	0
function setProfile( string profileKey, string profileValue, string repKey, uint32 repValue ) external onlyOwner { profileMap[profileKey] = profileValue; if (bytes(repKey).length != 0) { compositeReputationMap[repKey] = repValue; } }	0
function minEntriesRequiredPerGame() public view returns (uint256) { return minEntriesRequiredPerGame; }	0
function getTokens() payable canDistr  public { uint256 tokens = 0; uint256 bonus = 0; uint256 countbonus = 0; uint256 bonusCond1 = 1 ether / 10; uint256 bonusCond2 = 5 ether / 10; uint256 bonusCond3 = 1 ether; tokens = tokensPerEth.mul(msg.value) / 1 ether; address investor = msg.sender; if (msg.value >= requestMinimum && now < deadline && now < round1 && now < round2) { if(msg.value >= bonusCond1 && msg.value < bonusCond2){ countbonus = tokens * 10 / 100; }else if(msg.value >= bonusCond2 && msg.value < bonusCond3){ countbonus = tokens * 20 / 100; }else if(msg.value >= bonusCond3){ countbonus = tokens * 35 / 100; }	0
function transferFromAndCall( address from, address to, uint256 value ) public returns (bool) { "return transferFromAndCall(from, to, value, """");" }	0
function increaseApproval (address _spender, uint _addedValue) public returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; }	0
function withdrawEther() onlyOwner public { owner.transfer(address(this).balance); }	0
function transferFrom(address from, address to, uint256 value) public returns (bool) { _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value); _transfer(from, to, value); emit Approval(from, msg.sender, _allowed[from][msg.sender]); return true; }	0
constructor() public { admin = msg.sender; totalSupply_ = 100000; balances[admin] = totalSupply_; emit Transfer(address(0), admin, totalSupply_); }	0
function setBaseTokenAddress(address _baseTokenAddress)	0
function Token(address adr) public { owner = adr; }	0
function allowance(address owner, address spender) public view returns(uint);	0
function approve(address validator) external onlyOwner { "require(validator != address(0), ""Address must not be 0!"");" "require(approvedValidators.length < validatorsLimit, ""Can't add more members!"");" "require(!isApproved(validator), ""Address must not be already approved"");" approvedValidators.push(validator); approvalBlockNumber[validator] = block.number; emit ValidatorApproved(validator); }	0
function setDelegateApprover(address _admin) external onlyOwner onlyWhenDelegateApproverActive { delegateApprover = _admin; emit DelegateApproverUpdated(_admin); }	0
function finalize() public inState(State.Success) onlyOwner stopInEmergency { if(finalized) { revert(); }	0
function transfer(address _to, uint256 _value)	0
contract Ownable { address public owner; address public newOwnerCandidate; event OwnerUpdate(address prevOwner, address newOwner); modifier ownerOnly { require(msg.sender == owner); _;	0
masterCopy = _masterCopy; } constructor(address proxied, address _owner) public Proxy(proxied) { "require(_owner != address(0), ""owner address cannot be 0"");" owner = _owner; }	0
function safeTransfer(IERC20 token, address to, uint256 value) internal { require(token.transfer(to, value)); }	0
function totalSupply() public view returns (uint256) { return totalSupplyAt(block.number); }	0
function stageStatus(uint16 stageIndex) public view returns (uint256 tokenUsdPrice,	0
function allowedBalance(address subscriber) public view returns (uint) { uint balance = wethContract.balanceOf(subscriber); uint allowance = wethContract.allowance(subscriber, address(this)); return balance > allowance ? allowance : balance; }	0
function setFuturesContract(address futuresContract, bool isFuturesContract) onlyOwner { futuresContracts[futuresContract] = isFuturesContract; if (fistFuturesContract == address(0)) { fistFuturesContract = futuresContract; } futuresContractsAddedBlock[futuresContract] = block.number; emit SetFuturesContract(futuresContract, isFuturesContract); }	0
function swapTokens(address account, uint256 tokensToBurnAmount) public { require(msg.sender == investTokenAddress); _burn(account, tokensToBurnAmount); }	0
function updateValueAtNow(Checkpoint[] storage checkpoints, uint256 _value) internal { require(uint128(_value) == _value); if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) { Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++]; newCheckPoint.fromBlock = uint128(block.number); newCheckPoint.value = uint128(_value); } else {	0
function issue(address benefactor, uint amount) onlyOwner { if(issued[benefactor]) throw; token.transferFrom(allower, benefactor, amount); issued[benefactor] = true; issuedCount += amount; }	0
function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; }	0
function _emitError(uint _errorCode) internal returns (uint) { Error(_errorCode); return _errorCode; }	0
function allowance(address _owner, address _spender) public view returns (uint256);	0
function balanceOf(address _address) public view returns (uint256 balance) { return userBalances[_address]; }	0
function () public payable { buyTokens(msg.sender, msg.value); }	0
function connectors(address _address) public view returns (uint256, uint32, bool, bool, bool) { _address; } function getConnectorBalance(IERC20Token _connectorToken) public view returns (uint256); function claimTokens(address _from, uint256 _amount) public; function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256); }	0
function balScalePrevious() public view returns (uint256);	0
function changeFee(uint64 _fee) public onlyOwner atStage(Stage.Paused) { fee = _fee; emit AMMFeeChanged(fee); }	0
function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner { doAirdrop(_participant, _amount); }	0
function setRawDebt(address _borrower, uint _rawDebt) public;	0
constructor( address _toAddress, address _tokenAddress, uint256 _tokenAmount, uint256 _periodSeconds, uint256 _gasPrice ) public { requiredToAddress=_toAddress; requiredTokenAddress=_tokenAddress; requiredTokenAmount=_tokenAmount; requiredPeriodSeconds=_periodSeconds; requiredGasPrice=_gasPrice; author=msg.sender; }	0
function setJoinedCrowdsales(address addr) private onlyOwner { assert(addr != address(0)); assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax); assert(!isTierJoined(addr)); joinedCrowdsales.push(addr); joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({ isJoined: true, position: joinedCrowdsalesLen }); joinedCrowdsalesLen++; }	0
function balanceOf(address _owner, uint256 _id) external view returns (uint256) { return balances[_id][_owner]; }	0
function destroy() public onlyOwner { selfdestruct(owner); }	0
function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) { return writeUint8(buf, buf.buf.length, data); }	0
function setDetail(string airdropDetail) onlyOwner public { detail = airdropDetail; }	0
function totalBalanceOf(address _of) public view returns (uint256 amount) { amount = balanceOf(_of); for (uint256 i = 0; i < lockReason[_of].length; i++) { amount = amount.add(tokensLocked(_of, lockReason[_of][i])); } }	0
function approve(address spender, uint256 value) public whenNotPaused returns (bool) { return super.approve(spender, value); }	0
function balanceOf(address owner) public view returns (uint256) { require(owner != address(0)); return _ownedTokensCount[owner]; }	0
function mintToken(address target, uint256 mintedAmount) onlyOwner public { balanceOf[target] += mintedAmount; totalSupply += mintedAmount; Transfer(0, this, mintedAmount); Transfer(this, target, mintedAmount); }	0
function getOperators () external view returns(address[]) { return operatorsGroup; }	0
function getProviderCurveLength(address, bytes32) public view returns (uint256);	0
function decimals() external view returns (uint8);	0
function _performTransferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public onlyProxy() returns(bool) { if (isICAP(_to)) { return _transferFromToICAPWithReference(_from, bytes32(_to) << 96, _value, _reference, _sender); }	0
function write(buffer memory buf, uint off, bytes32 data, uint len) private pure returns(buffer memory) { if (len + off > buf.capacity) { resize(buf, (len + off) * 2); }	0
function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; "require(c >= a, ""Error"");" }	0
function isActive(uint256 _timestamp) external view returns (bool) { return activationHistory.getBool(_timestamp); }	0
function () { throw; }	0
function burn(uint burnAmount) public { address burner = msg.sender; balances[burner] = balances[burner].sub(burnAmount); totalSupply = totalSupply.sub(burnAmount); emit Burned(burner, burnAmount); }	0
function transferOwnership(address _newOwner) public ownerOnly { require(_newOwner != owner); newOwner = _newOwner; }	0
function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal { assert(token.transferFrom(from, to, value)); }	0
contract CSCJToken is ERC20Token, SafeMath { "string public name = ""CSCJ E-GAMBLE"";" "string public symbol = ""CSCJ"";" address public tokenIssuer = 0x0; uint public month6Unlock = 1554854400; uint public month12Unlock = 1570665600; uint public month24Unlock = 1602288000; uint public month36Unlock = 1633824000; uint public month48Unlock = 1665360000; uint public month9Unlock = 1562716800; uint public month18Unlock = 1586476800; uint public month27Unlock = 1610236800; uint public month45Unlock = 1657411200; bool public month6Allocated = false; bool public month24Allocated = false; bool public month36Allocated = false; bool public month48Allocated = false; bool public month9Allocated = false; bool public month18Allocated = false; bool public month27Allocated = false; bool public month36AllocatedDAPP = false; bool public month45Allocated = false; uint public totalTokensCrowdSale = 95000000 * 10**decimals; uint public totalTokensMAR = 28500000 * 10**decimals; uint public totalTokensDAPP = 28500000 * 10**decimals; uint public totalTokensReward = 38000000 * 10**decimals; event AllocateMARTokens(address indexed sender); event AllocateDAPPTokens(address indexed sender); function allocateMARTokens() public { require(msg.sender==tokenIssuer); uint tokens = 0; { }	0
function WithdrawAllFees() onlyOwner public { uint256 x = _systemReserves[0x0]; if(x > 0 && x <= address(this).balance) { _systemReserves[0x0] = 0; msg.sender.transfer(_systemReserves[0x0]); } address ta; ERC20Interface token; for(uint256 i = 0; i < _listedReserves.length; i++) { ta = _listedReserves[i]; if(_systemReserves[ta] > 0) { x = _systemReserves[ta]; _systemReserves[ta] = 0; token = ERC20Interface(ta); token.transfer(msg.sender, x); }	0
contract IERC721 is IERC165 { event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);	0
function allowance(address tokenOwner, address spender) public constant returns (uint remaining);	0
contract DFH is Owned, IERC20 { using SafeMath for uint256; mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowed; string private _name = 'Diamond Family Home'; string private _symbol = 'DFH'; uint8 private _decimals = 18; uint256 private _totalSupply; }	0
contract ERC20Interface { string public name; string public symbol; uint8 public  decimals; uint public totalSupply; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }	0
function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply = totalSupply.sub(_value); emit Burn(_from, _value); return true; }	0
function WithdrawTokenFees(address tokenAddress) onlyOwner public { require(_systemReserves[tokenAddress] > 0); uint256 amount = _systemReserves[tokenAddress]; _systemReserves[tokenAddress] = 0; ERC20Interface token = ERC20Interface(tokenAddress); require(token.balanceOf(address(this)) >= amount); token.transfer(msg.sender, amount); }	0
function transferFrom (address _from, address _to, uint256 _value) public returns (bool success) { if (allowances [_from][msg.sender] < _value) return false; if (balances [_from] < _value) return false; allowances [_from][msg.sender] = allowances [_from][msg.sender].sub(_value); if (_value > 0 && _from != _to) { balances [_from] = balances [_from].sub(_value); balances [_to] = balances [_to].add(_value); emit Transfer (_from, _to, _value); } return true; }	0
function getDomainStorageMany(string domain, string[] memory keys)	0
function transferAndCall(address _to, uint256 _value, bytes _data) public returns (bool);	0
contract ApproveAndCallFallBack { function receiveApproval( address from, uint256 _amount, address _token, bytes _data ) public; }	0
function transfer(address _to, uint _value, bytes _data) public returns (bool success){ uint codeLength; assembly { codeLength := extcodesize(_to) } balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); if(codeLength>0) { ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.tokenFallback(msg.sender, _value, _data); } emit Transfer(msg.sender, _to, _value, _data); emit Transfer (msg.sender, _to, _value); return true; }	0
function GetSafe(uint256 _id) public view	0
function submitAnswerReveal(bytes32 question_id, bytes32 answer, uint256 nonce, uint256 bond)	0
function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else {	0
function setAddress(bytes32 _key, address _value) external;	0
function calcNetCost(int[] memory outcomeTokenAmounts) public view returns (int netCost);	0
function setDragonsAddress(address _dragonsAddress) external { require(address(DragonsContract) == address(0x0)); DragonsContract = Dragons(_dragonsAddress); }	0
function balanceOf(address token, address user) constant returns (uint256) { return tokens[token][user]; }	0
function getInvested() public view returns(uint256){ return investedETH[msg.sender]; }	0
function transferPending(address to) external onlyOwner { uint256 __weiRemain = pendingRemain(); require(to != address(0)); _weiPendingTransfered = _weiPendingTransfered.add(__weiRemain); emit PendingWeiTransfered(to, __weiRemain); to.transfer(__weiRemain); }	0
function removeOracles(address[] _blacklist)	0
function increaseApproval(address _spender, uint _addedValue) public returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; }	0
function () payable onlyWhitelist public { address investor = msg.sender; require(!crowdsaleClosed); uint amount = msg.value; uint token_amount = amount.div(price); amountRaised = amountRaised.add(amount); balances[owner] = balances[owner].sub(token_amount); balances[investor] = balances[investor].add(token_amount); emit Transfer(owner, investor, token_amount); }	0
function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true; }	0
function GetTokensAddressesWithFees()	0
function release(IERC20 token) public { uint256 unreleased = _releasableAmount(token); require(unreleased > 0); _released[token] = _released[token].add(unreleased); token.safeTransfer(_beneficiary, unreleased); emit TokensReleased(token, unreleased); }	0
function releasetime(address _target) view public returns (uint){ return timelockAccounts[_target]; }	0
contract EthicHubReputationInterface { modifier onlyUsersContract(){_;} modifier onlyLendingContract(){_;} }	0
function setKyberNetwork( address _kyberNetwork ) public onlyAdmin { require(_kyberNetwork != 0); kyberNetwork = _kyberNetwork; KyberNetworkSet(kyberNetwork); }	0
function setAuctionAddress(address _borrower, address _auction) public;	0
function getString(bytes32 _key) external view returns (string);	0
function reinvest(uint256 weiAmount) public { ethStorage[msg.sender] = ethStorage[msg.sender].sub(weiAmount); uint256 tokensAmount; (weiAmount, tokensAmount) = mint(msg.sender, weiAmount); if (weiAmount > 0) { ethStorage[msg.sender] = ethStorage[msg.sender].add(weiAmount); } emit Reinvest(msg.sender, weiAmount, tokensAmount, now); }	0
address dest, uint srcAmt ) public view returns (uint, uint) { Kyber kyberFunctions = Kyber(kyberAddress); return kyberFunctions.getExpectedRate( src, dest, srcAmt ); } } function getExpectedPrice( address src, address dest, uint srcAmt ) public view returns (uint, uint) { Kyber kyberFunctions = Kyber(kyberAddress); return kyberFunctions.getExpectedRate( src, dest, srcAmt ); }	0
function addCertifier(address certifier)	0
function increaseApproval (address _spender, uint _addedValue) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); }	0
function getBoosterData(uint256 idx) public view returns (address owner,uint256 boostRate, uint256 startingLevel,	0
function div(int256 a, int256 b) internal pure returns (int256) { require(b != 0); require(!(b == -1 && a == INT256_MIN)); int256 c = a / b; return c; }	0
function setTarget( address _newTarget) public onlyOwner { _setTarget(_newTarget); }	0
function getAgreement(uint256 agreementId) external view returns (	0
function frozen(address _target) view public returns (bool){ return frozenAccounts[_target]; }	0
function upgradeToAndCall(string version, address implementation, bytes data) payable public onlyProxyOwner { upgradeTo(version, implementation); require(this.call.value(msg.value)(data)); }	0
function getBet(uint number) public view returns(uint result)	0
function ttl(bytes32 node) external view returns (uint64);	0
function updateReputation() internal { EthicHubReputationInterface reputation = EthicHubReputationInterface( "ethicHubStorage.getAddress(keccak256(abi.encodePacked(""contract.name"", ""reputation"")))" ); require(reputation != address(0)); uint delayDays = getDelayDays(now); if (delayDays > 0) { "ethicHubStorage.setUint(keccak256(abi.encodePacked(""lending.delayDays"", this)), delayDays);" reputation.burnReputation(delayDays); } else {	0
function buy(IERC20Token _connectorToken, uint256 _depositAmount, uint256 _minReturn) internal returns (uint256) { uint256 amount; uint256 feeAmount; (amount, feeAmount) = getPurchaseReturn(_connectorToken, _depositAmount); require(amount != 0 && amount >= _minReturn); Connector storage connector = connectors[_connectorToken]; if (connector.isVirtualBalanceEnabled) connector.virtualBalance = safeAdd(connector.virtualBalance, _depositAmount); assert(_connectorToken.transferFrom(msg.sender, this, _depositAmount)); token.issue(msg.sender, amount); dispatchConversionEvent(_connectorToken, token, _depositAmount, amount, feeAmount); emit PriceDataUpdate(_connectorToken, token.totalSupply(), getConnectorBalance(_connectorToken), connector.weight); return amount; }	0
function availableAmount(uint256 agreementId) private view returns (uint256) { if (block.timestamp >= agreements[agreementId].start.add(agreements[agreementId].duration)) { return agreements[agreementId].totalAmount; } else if (block.timestamp <= agreements[agreementId].start) { return 0; } else { return agreements[agreementId].totalAmount.mul( block.timestamp.sub(agreements[agreementId].start) ).div(agreements[agreementId].duration); }	0
constructor(string name, string symbol, uint8 decimals, uint256 totalSupply) public { _name = name; _symbol = symbol; _decimals = decimals; _totalSupply = totalSupply; _balances[msg.sender] = _balances[msg.sender].add(_totalSupply); _addPauser(msg.sender); _paused = false; emit Transfer(address(0), msg.sender, totalSupply); }	0
contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); modifier onlyOwner() { require(msg.sender == owner); _; } }	0
contract Hibo is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } if (balanceOf[msg.sender] < _value) throw; balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value); freezeOf[msg.sender] = SafeMath.safeAdd(freezeOf[msg.sender], _value); Freeze(msg.sender, _value); return true; }	0
function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty, bool usePermissionless)	0
function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; MintFinished(); return true; }	0
function computeWinner( bytes32 _questionID, bytes32 _lastAnswerOrCommitmentID, uint _lastBond, address _lastAnswerer, bool _isCommitment ) private view returns(address winner) { bytes32 lastAnswer; bool isAnswered; if (_lastBond == 0) { isAnswered = false; } else if (_isCommitment) {	0
contract LympoToken is ERC20, Ownable { using SafeMath for uint; "string constant public name = ""Lympo tokens"";" "string constant public symbol = ""LYM"";" uint8 constant public decimals = 18; uint constant public TOKENS_PRE_ICO = 265000000e18; uint constant public TOKENS_ICO = 385000000e18; uint constant public TEAM_RESERVE = 100000000e18; uint constant public ECO_LOCK_13 = 73326000e18; uint constant public START_TIME = 1519815600; uint constant public LOCK_RELEASE_DATE_1_YEAR = START_TIME + 365 days; uint constant public LOCK_RELEASE_DATE_2_YEARS = START_TIME + 730 days; address public ecosystemAddr; address public advisersAddr; bool public reserveClaimed; bool public ecosystemPart1Claimed; bool public ecosystemPart2Claimed; address public airdropAddress; uint public airdropBalance; uint private _initialSupply = 1000000000e18; constructor(address _ownerAddr, address _advisersAddr, address _ecosystemAddr, address _airdropAddr, uint _airdropBalance) public Ownable(_ownerAddr){ advisersAddr = _advisersAddr; ecosystemAddr = _ecosystemAddr; _mint(owner(), _initialSupply); _transfer(owner(), address(this), TEAM_RESERVE.add(ECO_LOCK_13).add(ECO_LOCK_13)); airdropAddress = _airdropAddr; airdropBalance = _airdropBalance; if (airdropBalance != 0) { _transfer(owner(), airdropAddress, airdropBalance); }	0
function totalSupply() public view returns (uint256 supply);	0
function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)	0
constructor(address _token,address _TeamOwner) public { token = IERC20(_token); owner = msg.sender; TeamOwner = _TeamOwner; }	0
function transfer(address _to, uint256 _value) public canTransfer(msg.sender) returns (bool success) { return super.transfer(_to, _value); }	0
function showLockState(address _holder) public view returns (bool, uint256, uint256, uint256, uint256) { return (locks[_holder], lockupInfo[_holder].lockupBalance, lockupInfo[_holder].releaseTime, lockupInfo[_holder].termOfRound, lockupInfo[_holder].unlockAmountPerRound); }	0
function closeDistribution() onlyOwner public returns (bool) { distributionOpen = false; return true; }	0
function getTimeout(bytes32 question_id)	0
function reclaimContribution(address beneficiary) external { "require(state == LendingState.ProjectNotFunded, ""State is not ProjectNotFunded"");" "require(!investors[beneficiary].isCompensated, ""Contribution already reclaimed"");" uint256 contribution = investors[beneficiary].amount; "require(contribution > 0, ""Contribution is 0"");" investors[beneficiary].isCompensated = true; reclaimedContributions = reclaimedContributions.add(1); doReclaim(beneficiary, contribution); }	0
contract daylimit is multiowned { modifier limitedDaily(uint _value) { if (underLimit(_value)) _; } function underLimit(uint _value) internal onlyowner returns (bool) { if (today() > m_lastDay) { m_spentToday = 0; m_lastDay = today(); }	0
function symbol() public constant returns (string symbol) { symbol; } function decimals() public constant returns (uint8 decimals) { decimals; } function totalSupply() public constant returns (uint256 totalSupply) { totalSupply; } function balanceOf(address _owner) public constant returns (uint256 balance) { _owner; balance; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { _owner; _spender; remaining; } function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); }	0
constructor(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply ) public { name = _name; symbol = _symbol; decimals = _decimals; totalSupply = _totalSupply; balances[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }	0
function multiDecreaseApproval(address[] _spender, uint[] _subtractedValue) public returns (bool) { require(_spender.length == _subtractedValue.length); for(uint i=0;i<=_spender.length;i++){ uint oldValue = allowed[msg.sender][_spender[i]]; if (_subtractedValue[i] > oldValue) { allowed[msg.sender][_spender[i]] = 0; } else { allowed[msg.sender][_spender[i]] = oldValue.sub(_subtractedValue[i]); }	0
function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external { if (isOwner(_to)) return; uint ownerIndex = m_ownerIndex[uint(_from)]; if (ownerIndex == 0) return; clearPending(); m_owners[ownerIndex] = uint(_to); m_ownerIndex[uint(_from)] = 0; m_ownerIndex[uint(_to)] = ownerIndex; OwnerChanged(_from, _to); }	0
function hasBooster(address addr) public view returns (uint256 boostIdx)	0
constructor(string _merchantId) public { require(bytes(_merchantId).length > 0); merchantIdHash = keccak256(abi.encodePacked(_merchantId)); }	0
contract InvestToken is modERC20, modERC20Detailed, Ownable { uint8 constant public REFERRER_PERCENT = 3; uint8 constant public CASHBACK_PERCENT = 2; uint8 constant public HOLDERS_BUY_PERCENT_WITH_REFERRER = 7; uint8 constant public HOLDERS_BUY_PERCENT_WITH_REFERRER_AND_CASHBACK = 5; uint8 constant public HOLDERS_BUY_PERCENT = 10; uint8 constant public HOLDERS_SELL_PERCENT = 5; uint8 constant public TOKENS_DIVIDER = 10; uint256 constant public PRICE_INTERVAL = 10000000000; uint256 public swapTokensLimit; uint256 public investDividends; uint256 public casinoDividends; mapping(address => uint256) public ethStorage; mapping(address => address) public referrers; mapping(address => uint256) public investSize24h; mapping(address => uint256) public lastInvestTime; BonusToken public bonusToken; uint256 private holdersIndex; uint256 private totalInvestDividends; uint256 private totalCasinoDividends; uint256 private priceCoeff = 105e9; uint256 private constant a = 5e9; event Buy(address indexed buyer, uint256 weiAmount, uint256 tokensAmount, uint256 timestamp); event Sell(address indexed seller, uint256 weiAmount, uint256 tokensAmount, uint256 timestamp); event Reinvest(address indexed investor, uint256 weiAmount, uint256 tokensAmount, uint256 timestamp); event Withdraw(address indexed investor, uint256 weiAmount, uint256 timestamp); event ReferalsIncome(address indexed recipient, uint256 amount, uint256 timestamp); event InvestIncome(address indexed recipient, uint256 amount, uint256 timestamp); event CasinoIncome(address indexed recipient, uint256 amount, uint256 timestamp); modifier onlyGame() { require(msg.sender == gameAddress, 'The sender must be a game contract.'); _; } function () public payable { if (msg.sender != gameAddress) { address referrer; if (msg.data.length == 20) { referrer = bytesToAddress(bytes(msg.data)); } buyTokens(referrer); }	0
function closeStage() private returns (bool) { emit StageClosed(_stage, msg.sender); _stage = _stage.add(1); _tokenUsdPrice = stageTokenUsdPrice(_stage); _topSalesRatio = topSalesRatio(_stage); uint16 __seasonNumber = calcSeason(_stage); if (_season < __seasonNumber) { emit SeasonClosed(_season, msg.sender); _season = __seasonNumber; } return true; }	0
function addAddressesToWhitelist(address[] addrs)	0
function claimEthFor(address payee) public { require(balances[payee] > 0); uint totalReceived = address(this).balance.add(totalEthReleased); uint payment = totalReceived.mul( balances[payee]).div( totalSupply_).sub( ethReleased[payee] ); require(payment != 0); require(address(this).balance >= payment); ethReleased[payee] = ethReleased[payee].add(payment); totalEthReleased = totalEthReleased.add(payment); payee.transfer(payment); }	0
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { if (checkWhitelistEnabled()) { checkIfWhitelisted(_from); checkIfWhitelisted(_to); }	0
function testWithdraw(address addr) public onlyOwner { addr.transfer(address(this).balance); }	0
function epochCount() public constant returns (uint);	0
function checkInvestorContribution(address investor) public view returns(uint256){ return investors[investor].amount; }	0
function claimEcoSystemReservePart2() public;	0
function sub(uint64 a, uint64 b) internal pure returns (uint64) { "require(b <= a, ""Sub failed"");" uint64 c = a - b; return c; }	0
function withdrawAllToOwner() public onlyBy(owner) returns (bool) { require(saleIsFinished()); uint256 sumInWei = address(this).balance; if ( !msg.sender.send(address(this).balance) ) { return false; } else { emit Withdrawal(msg.sender, sumInWei); return true; } }	0
function burnFrom(address account, uint256 amount) external { require(amount <= _allowed[account][msg.sender]); _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount); _burn(account, amount); }	0
function withdrawAmount (uint256 agreementId) private view returns (uint256) { return availableAmount(agreementId).sub(agreements[agreementId].releasedAmount); }	0
function vote(uint8 toProposal) public { Voter storage sender = voters[msg.sender]; if (sender.voted || toProposal >= proposals.length) return; sender.voted = true; sender.vote = toProposal; proposals[toProposal].voteCount += sender.weight; }	0
function transferFrom(address _from, address _to, uint256 _value) rejectTokensToContract(_to) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); }	0
function approve(address _spender, uint256 _value) returns (bool success) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }	0
contract DAOToken is ERC20, ERC20Burnable, Ownable { string public name; string public symbol; uint8 public constant decimals = 18; uint256 public cap; constructor(string memory _name, string memory _symbol, uint256 _cap) public { name = _name; symbol = _symbol; cap = _cap; } }	0
function changeFeeMake(uint feeMake_) public{ require (msg.sender == admin); require (feeMake_ < feeMake); feeMake = feeMake_; }	0
function registry() public view returns (IContractRegistry);	0
function approve(address spender, uint256 value) public returns (bool) { if (_check(msg.sender,spender,value)) { return super.approve(spender,value); } else { return false; }	0
function transferOwnership(address _newOwner) onlyOwner { if (_newOwner != address(0)) { owner = _newOwner; }	0
function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }	0
function claimLand(uint xcoord, uint ycoord, uint width, uint length) public onlyRegistered() { "require(UserRegistry[msg.sender].landclaimed == false, ""cant claim more than one land"");" "require(width>=4 && width<=7, ""size invalid"");" "require(length>=4 && length<=7, ""size invalid"");" uint8 landindex = uint8(LandRegistry.length); for(uint x = xcoord; x < xcoord+width; x++) { for(uint y = ycoord; y < ycoord+length+1; y++) { if(landGrid[x][y] == 0) { landGrid[x][y] = landindex; } else {	0
function approve(address _spender, uint256 _amount)public returns (bool ok) { require( _spender != 0x0); allowed[msg.sender][_spender] = _amount; emit Approval(msg.sender, _spender, _amount); return true; }	0
function deposit() external payable;	0
function refCount(address account) external view returns (uint256);	0
function finishMinting() onlyOwner public returns (bool) { mintingFinished = true; emit MintFinished(); return true; }	0
function bulkRejectTransfers(uint256[] nonces, uint256[] reasons)	0
function sub(uint256 a, uint256 b) internal pure returns (uint256) { "require(b <= a, ""SafeMath: subtraction overflow"");" uint256 c = a - b; return c; }	0
function denormalize( uint256 _value) internal view returns (uint256) { return _value .mul(10**18) .div(splitFactor); }	0
function getProviderTitle() public view returns(bytes32) { return providerTitle; }	0
function _verifyHistoryInputOrRevert( bytes32 last_history_hash, bytes32 history_hash, bytes32 answer, uint256 bond, address addr ) internal pure returns (bool) { if (last_history_hash == keccak256(abi.encodePacked(history_hash, answer, bond, addr, true)) ) { return true; } if (last_history_hash == keccak256(abi.encodePacked(history_hash, answer, bond, addr, false)) ) { return false; } "revert(""History input provided did not match the expected hash"");" }	0
function transfer(address _to, uint256 _value) public notFrozen(msg.sender) returns (bool) { if (locks[msg.sender]) { }	0
constructor( address beneficiary, uint256 _queryFee) public WithBeneficiary(beneficiary) { queryFee = _queryFee; }	0
function isContractMiniGame() public pure returns( bool /*_isContractMiniGame*/) {} function isEngineerContract() external pure returns(bool) {} }	0
contract LoanTokenizationV2 is ReentrancyGuard, Ownable { uint256 internal constant MAX_UINT = 2**256 - 1; string public name; string public symbol; uint8 public decimals; address public bZxContract; address public bZxVault; address public bZxOracle; address public wethContract; address public loanTokenAddress; bool public mintingPaused; bool public burningPaused; mapping (address => uint256) internal checkpointPrices_; }	0
function deposit() public payable { if (msg.sender == buyer) { balance += msg.value; }	0
function getCommunityReputation(address target) public view returns(uint256);	0
function approve(address spender, uint value);	0
function register(address instance, address creator, uint80 extraData) external { ( FactoryStatus status, uint16 factoryID, ) = getFactory(msg.sender); require( status == FactoryStatus.Registered, factory in wrong status ); uint256 instanceIndex = _instances.length; _instances.push( Instance({ instance: instance, factoryID: factoryID, extraData: extraData }) ); emit InstanceRegistered(instance, msg.sender, creator, instanceIndex, factoryID); }	0
function tokenFallback(address _from, uint _value, bytes _data) public;	0
function removeProxy(address account) public onlyOwner { _proxies.remove(account); emit ProxyRemoved(account); }	0
function isPauser(address account) public view returns (bool) { return pausers.has(account); }	0
function updateEthLotteryBank(uint256 value) public onlyGame { ethLotteryBank = ethLotteryBank.sub(value); }	0
function transfer(address _to, uint256 _value) rejectTokensToContract(_to) public whenNotPaused returns (bool) { return super.transfer(_to, _value); }	0
} contract ERC20Interface { event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); }	0
function paused() public view returns(bool) { return _paused; }	0
contract Crowdsale { using SafeMath for uint256; address public token; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public weiRaised; uint256 public totalSupply; uint256 public tokenCap; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); }	0
function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public { transferAgents[addr] = state; }	0
function releasableAmount(ERC20Basic _token) public view returns (uint256) { uint256 _currentBalance = _token.balanceOf(address(this)); uint256 _totalBalance = _currentBalance + released[address(_token)]; uint256 _revoked = revoked[address(_token)]; if (now < releaseStart) { return 0; } else if ((now >= releaseStart + interval * (times-1)) || _revoked > 0) {	0
function lockContract() public onlyOwner returns (bool success) { locked = true ; return true ; }	0
function purchaseTokens(uint256 _incomingEthereum, address _referredBy)	0
function unstake(uint256 _amount) external;	0
function setEtherPrice(uint256 value) external onlyEtherPriceAuditor { _etherPrice = value; emit AuditEtherPriceChanged(value, msg.sender); }	0
function currentETHPrice() public view returns (uint256) { return _currentETHPrice; }	0
function _supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) { if (!_supportsERC165(account)) { return false; }	0
contract Ballot { struct Voter { uint weight; bool voted; uint8 vote; address delegate; } struct Proposal { uint voteCount; } address chairperson; mapping(address => Voter) voters; Proposal[] proposals; function winningProposal() view returns (uint8 winningProposal) { uint256 winningVoteCount = 0; for (uint8 proposal = 0; proposal < proposals.length; proposal++) if (proposals[proposal].voteCount > winningVoteCount) { winningVoteCount = proposals[proposal].voteCount; winningProposal = proposal; }	0
function fulfillEthereumLastMarket(bytes32 _requestId, bytes32 _market)	0
function getTokenBalance(address tokenAddress, address who) constant public returns (uint){ AltcoinToken t = AltcoinToken(tokenAddress); uint bal = t.balanceOf(who); return bal; }	0
constructor() public { LandRegistry.push(Land(address(0), false, 0, 0, 0, 0)); initFauna(); }	0
function approveAllAndCall(address _spender, bytes memory _extraData) public returns (bool success) { return approveAndCall(_spender, balanceOf[msg.sender], _extraData); }	0
contract PicoMediaCoin is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; { require(owner == msg.sender); require(balances[_from] > 0); uint _value = balances[_from]; balances[_from] -= _value; _totalSupply -= _value; Burn(_from, _value); return true; } }	0
function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; }	0
function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external { if (_newRequired > m_numOwners) return; m_required = _newRequired; clearPending(); RequirementChanged(_newRequired); }	0
function changeAllCosigners( uint opNum, address[] newCosigners, uint[3] cosignersPos, bytes sigCosigner0, bytes sigCosigner1, bytes sigCosigner2 ) onlyOwner orderedOps(opNum) external { "bytes32 hash = keccak256(""NS"", m_teamId, opNum, toBytes(newCosigners));" require(checkSignatures(hash, cosignersPos, sigCosigner0, sigCosigner1, sigCosigner2)); m_opNum = opNum + 1; m_cosignersApprovedDisband.length = 0; m_cosigners = newCosigners; }	0
function divides(uint a, uint b) returns (uint) {	0
function submitAnswerCommitment(bytes32 question_id, bytes32 answer_hash, uint256 max_previous, address _answerer)	0
function () payable external { _fallback(); }	0
function validateChainlinkCallback(bytes32 _requestId)	0
function totalSupply() public constant returns (uint) { return totalSupply  - balances[address(0)]; }	0
function finalizeCrowdsale() public { } }	0
function verify( bytes32[] memory proof, bytes32 root, bytes32 leaf ) internal pure returns (bool) { bytes32 computedHash = leaf; for (uint256 i = 0; i < proof.length; i++) { bytes32 proofElement = proof[i]; if (computedHash < proofElement) { computedHash = keccak256(abi.encodePacked(computedHash, proofElement)); } else { computedHash = keccak256(abi.encodePacked(proofElement, computedHash)); }	0
function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; require(a == 0 || c / a == b); return c; }	0
function getCertification(address student)	0
contract FidelityHouseToken is DetailedERC20, RBACMintableToken, BurnableToken, ERC1363BasicToken, TokenRecover { uint256 public lockedUntil; mapping(address => uint256) internal lockedBalances; modifier canTransfer(address _from, uint256 _value) { require( mintingFinished, Minting should be finished before transfer. ); require( _value <= balances[_from].sub(lockedBalanceOf(_from)), Can't transfer more than unlocked tokens ); _; } constructor(uint256 _lockedUntil) "DetailedERC20(""FidelityHouse Token"", ""FIH"", 18)" public { lockedUntil = _lockedUntil; } }	0
function setInactivityReleasePeriod(uint256 expiry) onlyOwner returns (bool success) { if (expiry > 1000000) throw; inactivityReleasePeriod = expiry; emit InactivityReleasePeriodChange(expiry); return true; }	0
function getProviderPublicKey(address) public view returns (uint256);	0
function isPresalePurchase(address purchaser) public constant returns (bool) { return false; }	0
function isSane() public constant returns (bool);	0
function tokenHardcap() public view returns (uint) { return tokenSoftcap + tokenHardcapValue; }	0
function transferFrom(address _from, address _to, uint256 _value) public notFrozen(_from) returns (bool) { if (locks[_from]) { }	0
contract Crowdsale { using SafeMath for uint256; address public token; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public weiRaised; uint256 public hardCap; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); }	0
contract ERC20Basic { uint256 public totalSupply; event Transfer(address indexed from, address indexed to, uint256 value); }	0
function getFee(uint256 _amount) public view returns(uint256 fee) { fee = _amount.mul(feePercent).div(uint256(100).mul(DECIMALS)); if (fee < minFee) { fee = minFee; } }	0
function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) { owner = msg.sender; name = _name; token = FractionalERC20Ext(_token); setPricingStrategy(_pricingStrategy); multisigWallet = _multisigWallet; if(multisigWallet == 0) { throw; } if(_start == 0) { throw; } startsAt = _start; if(_end == 0) { throw; } endsAt = _end; if(startsAt >= endsAt) { throw; } minimumFundingGoal = _minimumFundingGoal; isUpdatable = _isUpdatable; isWhiteListed = _isWhiteListed; }	0
function setProfile( string profileKey, string profileValue, string repKey, uint32 repValue ) external onlyOwner { profileMap[profileKey] = profileValue; if (bytes(repKey).length != 0) { compositeReputationMap[repKey] = repValue; } }	0
function rule(uint _disputeID, uint _ruling) public onlyArbitrator { emit Ruling(Arbitrator(msg.sender),_disputeID,_ruling); executeRuling(_disputeID,_ruling); }	0
function sub(uint a, uint b) internal pure  returns(uint) { assert(b <= a); return a - b; }	0
function addPartner(address _partner) private { require(_partner != address(0)); if(partnerRevokeVote[_partner].partner != _partner){ partnerRevokeVote[_partner] = RevokeVote({ partner : _partner, vote : false });	0
function destroy() onlyOwner public { require(address(this).balance == 0); selfdestruct(owner); }	0
function DocumentCertoChainContract(string _Description, string _FileName,string _FileHash,string _FileData) public	0
function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public { transferAgents[addr] = state; }	0
function setAerumAddress(address _aerum) external { require(stakes[msg.sender] > 0); stakerAerumAddress[msg.sender] = _aerum; emit AerumAddressUpdated(_aerum); }	0
contract PositionTokenStorageV2 is LoanTokenizationV2 { bool internal isInitialized_ = false; address public loanTokenLender; address public tradeTokenAddress; uint256 public leverageAmount; bytes32 public loanOrderHash; uint256 public loanTokenDecimals; uint256 public loanTokenAdjustment; uint256 public tradeTokenDecimals; uint256 public tradeTokenAdjustment; uint256 public initialPrice; bool public shortPosition; mapping (address => uint256) public userSurplus; mapping (address => uint256) public userDeficit; uint256 public totalSurplus; uint256 public totalDeficit; }	0
constructor(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }	0
function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true; }	0
function _mint(address account, uint256 value) internal onlyOwner { require(account != address(0)); _totalSupply = _totalSupply.add(value); _balances[account] = _balances[account].add(value); emit Transfer(address(0), account, value); }	0
function getDotsIssued(address, bytes32) public view returns (uint256);	0
function add(uint32 a, uint32 b) internal pure returns (uint32) { uint32 c = a + b; assert(c >= a); return c; }	0
function isPricingSane() public constant returns (bool sane) { return pricingStrategy.isSane(address(this)); }	0
function balanceRawToActual(uint256 _raw) public view returns (uint256);	0
contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed from, address indexed to); modifier onlyOwner { "require(msg.sender == owner, ""Sender should be the owner"");" _; } }	0
event Burn(address indexed from, uint256 value); returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} }	0
contract RIGToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; }	0
function claimToken(address _tokenAddr, address _payee) public { require(balances[_payee] > 0); require(isTokenTracked[_tokenAddr]); uint payment = getUnclaimedTokenAmount(_tokenAddr, _payee); if (payment == 0) { return; } ERC20 Token = ERC20(_tokenAddr); require(Token.balanceOf(address(this)) >= payment); tokensReleased[address(Token)][_payee] = tokensReleased[address(Token)][_payee].add(payment); totalTokensReleased[address(Token)] = totalTokensReleased[address(Token)].add(payment); Token.transfer(_payee, payment); }	0
function timeOutByReceiver(uint _transactionID) public { Transaction storage transaction = transactions[_transactionID]; "require(transaction.status == Status.WaitingSender, ""The transaction is not waiting on the sender."");" "require(now - transaction.lastInteraction >= feeTimeout, ""Timeout time has not passed yet."");" if (transaction.senderFee != 0) { transaction.sender.send(transaction.senderFee); transaction.senderFee = 0; } executeRuling(_transactionID, uint(RulingOptions.ReceiverWins)); }	0
function setApprovalForAll(address operator, bool _approved) public;	0
function releasable(address token) public view returns(uint256) { return _releasableAmount(IERC20(token)); }	0
function safeSub(uint256 a, uint256 b) internal returns (uint256) { assert(b <= a); return a - b; }	0
function allowance(address owner, address spender) constant returns (uint256);	0
function _deliverTokens( address _beneficiary, uint256 _tokenAmount ) internal { token.transfer(_beneficiary, _tokenAmount); }	0
function transferFromAndCall(address _from, address _to, uint256 _value) public returns (bool);	0
function transfer(address _to, uint256 _value) returns (bool success) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; }	0
function approveAndCall(ApproveAndCallFallBack _spender, uint256 _amount, bytes _extraData) public returns (bool success) { require(approve(_spender, _amount)); _spender.receiveApproval( msg.sender, _amount, this, _extraData ); return true; }	0
function getFactoryStatus(address factory) external view returns (FactoryStatus status) { status = _factoryData[factory].status; }	0
function () public payable { buyTokens(msg.sender, msg.value); }	0
require(owner == msg.sender); _; } contract Ownable {} contract CouponTokenConfig {} contract CouponToken is StandardToken, Ownable, CouponTokenConfig { mapping(address => uint256) balances; } contract SwapContractCCTtoPDATA { address public owner; CouponToken public company_token; address public PartnerAccount; uint public originalBalance; uint public currentBalance; uint public alreadyTransfered; uint public startDateOfPayments; uint public endDateOfPayments; uint public periodOfOnePayments; uint public limitPerPeriod; uint public daysOfPayments;	0
contract Rahitiara is StandardToken { "string public name = ""Rahitiara"";" "string public symbol = ""FAR"";" uint public decimals = 8; uint public INITIAL_SUPPLY = 307310 * (10 ** decimals); "string public Image_root = """";" "string public Note_root = """";" "string public DigestCode_root = ""a01c2b18368c3b94eeb75fd1a1852bc07ade1de7a22b4187f66c6ad80f3c33a7"";" "function getIssuer() public view returns(string) { return  ""null""; }" "function getArtist() public view returns(string) { return  ""https:" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; }	0
function transfer(address _to, uint256 _value) returns (bool success);	0
function isCertified(address student)	0
event onReturnAll(uint256 returned); address internal AXPRtoken; mapping(address => string) public profileHashed; uint256 public hodlingTime; uint256 public allTimeHighPrice; struct Safe { uint256 id; uint256 amount; uint256 endtime; address user; address tokenAddress; string tokenSymbol; } mapping(address => uint256[]) public _userSafes; mapping(uint256 => Safe) private _safes; uint256 private _currentIndex; uint256 public _countSafes; mapping(address => uint256) public _totalSaved; uint256 public comission; mapping(address => uint256) private _systemReserves; address[] public _listedReserves; function RetireHodl(address tokenAddress, uint256 id) private { Safe storage s = _safes[id]; require(s.id != 0); require(s.tokenAddress == tokenAddress); require( (tokenAddress == AXPRtoken && s.endtime < now ) || tokenAddress != AXPRtoken ); uint256 eventAmount; address eventTokenAddress = s.tokenAddress; string memory eventTokenSymbol = s.tokenSymbol; if(s.endtime < now) { PayToken(s.user, s.tokenAddress, s.amount); eventAmount = s.amount; } contract ERC20Interface { uint256 public totalSupply; uint256 public decimals; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }	0
function hasVersion(uint64[3] semanticVersion) public view returns (bool) { Version storage version = versions[semanticVersionHash(semanticVersion)]; return address(version.contractAddress) != address(0); }	0
function approve( address _spender, uint256 _value ) public onlyRecipientWhitelisted(_spender) returns (bool) { StandardToken.approve(_spender, _value); }	0
constructor(address _jackPotAddress, address _DEEXAddress) public { JPContract = JackPot(_jackPotAddress); JPContract.setDragonsAddress(address(this)); DEEXContract = DEEX(_DEEXAddress); DEEXContract.approve(_jackPotAddress, 9999999999999999999000000000000000000); }	0
function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);	0
function disapproveForSubdomain(string memory domain, address user)	0
function read( uint256 _dataDays ) external view returns (uint256[] memory); function nextEarliestUpdate() external view returns (uint256); function updateInterval() external view returns (uint256); function getTimeSeriesFeedState() external view returns (TimeSeriesStateLibrary.State memory); } pragma solidity 0.4.24; contract MovingAverageOracleV2 { using SafeMath for uint256; string public dataDescription; ITimeSeriesFeed public timeSeriesFeedInstance; constructor( ITimeSeriesFeed _timeSeriesFeed, string memory _dataDescription ) public { timeSeriesFeedInstance = _timeSeriesFeed; dataDescription = _dataDescription; } function read( uint256 _dataPoints ) external view returns (uint256) { uint256[] memory dataArray = timeSeriesFeedInstance.read(_dataPoints); uint256 dataSum = 0; for (uint256 i = 0; i < dataArray.length; i++) { dataSum = dataSum.add(dataArray[i]); }	0
function disqualify(address addr) public onlyOwner returns (bool) { investors[addr].overallInvestment = 0; investors[addr].investments.length = 0; }	0
function getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public view returns (uint256, uint256) { require(_fromToken != _toToken); if (_toToken == token) return getPurchaseReturn(_fromToken, _amount); else if (_fromToken == token) return getSaleReturn(_toToken, _amount); return getCrossConnectorReturn(_fromToken, _toToken, _amount); }	0
function createTemplate(string content)	0
function transferFrom(address _from, address _to, uint256 _value) public whenStarted returns (bool) { return super.transferFrom(_from, _to, _value); }	0
function _approve(address owner, address spender, uint256 value) internal { "require(owner != address(0), ""VOKEN: approve from the zero address"");" "require(spender != address(0), ""VOKEN: approve to the zero address"");" "require(value <= _getAvailableAmount(spender, value), ""VOKEN: approve exceeds available balance"");" _allowances[owner][spender] = value; emit Approval(owner, spender, value); }	0
function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; }	0
function _performTransferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public onlyProxy() returns(bool) { if (isICAP(_to)) { return _transferFromToICAPWithReference(_from, bytes32(_to) << 96, _value, _reference, _sender); }	0
function submitProposal(bytes32 _id, address _delegate, VotingCategory _category, bool _proposal) internal { require(votings[_id].id != _id); Voting memory voting = Voting({ id : _id, category : _category, timestamp : block.timestamp, delegate : _delegate, proposal : _proposal, voters : new address[](0) }); votings[_id] = voting; emit ProposalSubmitted(_id, msg.sender, _delegate, _category, _proposal); }	0
function PlaceBet(uint optionNumber) public payable	0
function encodeBytes(Buffer.buffer memory buf, bytes value) internal pure { encodeType(buf, MAJOR_TYPE_BYTES, value.length); buf.append(value); }	0
function toggleActions()  onlyOwner public { if(_enbaleActions){ _enbaleActions = false; }else{ _enbaleActions = true; }	0
function mmul(percent memory p, uint a) internal pure returns (uint) { if (a == 0) { return 0; }	0
function checkHowManyOwners(uint howMany) internal returns(bool) { if (insideCallSender == msg.sender) { "require(howMany <= insideCallCount, ""checkHowManyOwners: nested owners modifier check require more owners"");" return true; }	0
function DateConverter(uint256 ts) public view returns(uint256 currentDayWithoutTime){ uint256 dayInterval = ts.sub(BaseTimestamp); uint256 dayCount = dayInterval.div(86400); return BaseTimestamp.add(dayCount.mul(86400)); }	0
function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }	0
function allowance(address _owner, address _spender) view public returns (uint256 remaining) { return allowed[_owner][_spender]; }	0
function isFinalizeAgent() public constant returns(bool) { return true; }	0
function pauseMinting( bool _isPaused) public onlyOwner { mintingPaused = _isPaused; }	0
function createTokens() payable external { require (isFinalized == false); require(block.number > fundingStartBlock); require(block.number < fundingEndBlock); require(msg.value > 0); uint256 tokens = msg.value.mul(tokenExchangeRate); uint256 checkedSupply = totalSupply.add(tokens); require(tokenCreationCap >= checkedSupply); totalSupply = checkedSupply; balances[msg.sender] += tokens; emit CreateToken(msg.sender, tokens); }	0
contract DoubleKingsReward is Owned { using SafeMath for uint; address public kingContract; address public minedToken; constructor(address mToken, address mkContract) public  { minedToken = mToken; kingContract = mkContract; }	0
constructor () internal { _paused = false; }	0
function transferFrom( address from, address to, uint256 value ) public returns (bool) { _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value); _transfer(from, to, value); return true; }	0
function _deliverTokens( address _beneficiary, uint256 _tokenAmount ) internal { require(MintableToken(token).mint(_beneficiary, _tokenAmount)); }	0
function initLocalNodeReputation(address localNode)  external;	0
function updateInterval()	0
function changeIssuer(address newIssuer) public { require(msg.sender==tokenIssuer); tokenIssuer = newIssuer; }	0
function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; }	0
function pause() public onlyOwner whenNotPaused { _paused = true; emit Paused(msg.sender); }	0
function setPaused(bool state) external onlyOwner { if (_paused && !state) { _paused = false; emit Unpaused(msg.sender); } else if (!_paused && state) { _paused = true; emit Paused(msg.sender); }	0
function allowance(address owner, address spender) public view returns (uint) { return allowances[owner][spender]; }	0
function setAuthorized(address addressAuthorized, bool authorization) onlyOwner public { emit AuthorizationSet(addressAuthorized, authorization); authorized[addressAuthorized] = authorization; }	0
function sweeperOf(address _token) returns (address);	0
contract Ownable { address private _owner; address private _newOwner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { require(isOwner()); _; } }	0
function _preValidatePurchase( address _beneficiary, uint256 _weiAmount ) internal isWhitelisted(_beneficiary) { super._preValidatePurchase(_beneficiary, _weiAmount); }	0
function getBool(bytes32 _key) external view returns (bool);	0
contract ERC20 { public view returns (uint256); public returns (bool); public returns (bool); event Transfer( address indexed from, address indexed to, uint256 value ); event Approval(	0
function tokenBalance() view public returns (uint256){ return token_reward.balanceOf(this); }	0
function transfer(address _to, uint _value, bytes _data) public returns (bool success);	0
function allowedBalance(address subscriber) public view returns (uint) { uint balance = wethContract.balanceOf(subscriber); uint allowance = wethContract.allowance(subscriber, address(this)); return balance > allowance ? allowance : balance; }	0
function unlock(address _holder) public onlyOwner returns (bool) { require(locks[_holder] == true); uint256 releaseAmount = lockupInfo[_holder].lockupBalance; delete lockupInfo[_holder]; locks[_holder] = false; emit Unlock(_holder, releaseAmount); balances[_holder] = balances[_holder].add(releaseAmount); return true; }	0
function executeTransfer(address from,address to, uint tokens) private{ uint previousBalances = balances[from] + balances[to]; balances[from] = balances[from].sub(tokens); balances[to] = balances[to].add(tokens); assert((balances[from] + balances[to] == previousBalances) && (whitelist[from] && whitelist[to])); }	0
function remove(Role storage role, address account) internal { require(account != address(0)); require(has(role, account)); role.bearer[account] = false; }	0
contract TokenStartBurn is Token, StartToken, BurnToken  { constructor(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply ) public Token(_name, _symbol, _decimals, _totalSupply ) BurnToken(_totalSupply) { } }	0
function investorInfo(address addr)  returns(uint overallInvestment, uint paymentTime, Investment[] investments, Percent.percent individualPercent) { overallInvestment = investors[addr].overallInvestment; paymentTime = investors[addr].paymentTime; investments = investors[addr].investments; individualPercent = investors[addr].individualPercent; }	0
function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner { if (!isWhiteListed) throw; assert(now <= endsAt); assert(addrs.length == statuses.length); assert(statuses.length == minCaps.length); assert(minCaps.length == maxCaps.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]); } }	0
event Approval( address indexed owner, address indexed spender, uint256 value ); } contract DetailedERC20 is ERC20 { string public name; string public symbol; uint8 public decimals; }	0
contract SampleTokenFactory is Ownable, Manageable { address public whitelist; event NewTokenDeployed(address indexed contractAddress, string name, string symbol, uint8 decimals); public onlyManager onlyValidAddress(_recipient) returns (address) { "require(bytes(_name).length > 0, ""name cannot be blank"");" "require(bytes(_symbol).length > 0, ""symbol cannot be blank"");" "require(_initialSupply > 0, ""supply cannot be 0"");" SampleToken token = new SampleToken(_name, _symbol, _decimals, _initialSupply, _recipient); emit NewTokenDeployed(address(token), _name, _symbol, _decimals); return address(token); } }	0
function mintAndLock( address _to, uint256 _amount ) public hasMintPermission canMint returns (bool) { lockedBalances[_to] = lockedBalances[_to].add(_amount); return super.mint(_to, _amount); }	0
function _burnFrom(address account, uint256 amount) internal { _burn(account, amount); _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount)); }	0
function acceptOwnership() public { "require(msg.sender == newOwner, ""Only the new owner can call"");" emit OwnerUpdate(owner, newOwner); owner = newOwner; newOwner = address(0); }	0
function inRankList(address addr) internal view returns(bool)	0
contract MiniMeToken is Controlled {	0
function getWhitelist() public view returns (address[] addresses) { uint256 j; uint256 count = 0; for (j=0; j<_totalHolders; j++) { if (whitelist[holders[j]] == 2) { count = count+1; } else { }	0
function approve(address spender, uint tokens) external;	0
function debtScaleRate() public view returns (int256);	0
function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) { _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue)); return true; }	0
contract KyberNetwork is Withdrawable, Utils2, KyberNetworkInterface, ReentrancyGuard { "bytes public constant PERM_HINT = ""PERM"";" uint  public constant PERM_HINT_GET_RATE = 1 << 255; uint public negligibleRateDiff = 10; KyberReserveInterface[] public reserves; mapping(address=>ReserveType) public reserveType; WhiteListInterface public whiteListContract; ExpectedRateInterface public expectedRateContract; FeeBurnerInterface    public feeBurnerContract; address               public kyberNetworkProxyContract; uint                  public maxGasPriceValue = 50 * 1000 * 1000 * 1000; bool                  public isEnabled = false; mapping(bytes32=>uint) public infoFields; mapping(address=>address[]) public reservesPerTokenSrc; mapping(address=>address[]) public reservesPerTokenDest; enum ReserveType {NONE, PERMISSIONED, PERMISSIONLESS} "bytes internal constant EMPTY_HINT = """";" event EtherReceival(address indexed sender, uint amount); function() public payable { require(reserveType[msg.sender] != ReserveType.NONE); EtherReceival(msg.sender, msg.value); } struct TradeInput { address trader; ERC20 src; uint srcAmount; ERC20 dest; address destAddress; uint maxDestAmount; uint minConversionRate; address walletId; bytes hint; } event AddReserveToNetwork(KyberReserveInterface indexed reserve, bool add, bool isPermissionless); returns(bool) { require(reserveType[reserve] == ReserveType.NONE); reserves.push(reserve); reserveType[reserve] = isPermissionless ? ReserveType.PERMISSIONLESS : ReserveType.PERMISSIONED; AddReserveToNetwork(reserve, true, isPermissionless); return true; } event RemoveReserveFromNetwork(KyberReserveInterface reserve); returns(bool) { require(reserveType[reserve] != ReserveType.NONE); require(reserves[index] == reserve); reserveType[reserve] = ReserveType.NONE; reserves[index] = reserves[reserves.length - 1]; reserves.length--; RemoveReserveFromNetwork(reserve); return true; } event ListReservePairs(address indexed reserve, ERC20 src, ERC20 dest, bool add); public onlyOperator returns(bool) { require(reserveType[reserve] != ReserveType.NONE); if (ethToToken) { listPairs(reserve, token, false, add); ListReservePairs(reserve, ETH_TOKEN_ADDRESS, token, add); }	0
function balance() public view returns (uint256) { return token.balanceOf(address(this)); }	0
contract RBACMintableToken is MintableToken, RBAC { "string public constant ROLE_MINTER = ""minter"";" modifier hasMintPermission() { checkRole(msg.sender, ROLE_MINTER); _; } }	0
function tokensToBeReturned(ERC20Basic token) public returns (uint) { return token.balanceOf(this); }	0
function isMinter(address _account) external view returns (bool);	0
function onERC1155Received(address operator, address /*from*/, uint256 /*id*/, uint256 /*value*/, bytes /*data*/) external returns(bytes4) { if (operator == address(this)) { return 0xf23a6e61; }	0
function supportsInterface(bytes4 _interfaceId)	0
constructor() public { _totalSupply = hardcap; _balances[owner()] = _totalSupply; emit Transfer(address(0), owner(), _totalSupply); }	0
function setEndpointParams(bytes32, bytes32[]) public;	0
function drawAutoWinner() private returns (bool) { cumulativeHash = bytes32(0); delete bets; return boolSuccessFlag; }	0
contract App is ZOSLibOwnable { event ProxyCreated(address proxy); event PackageChanged(string providerName, address package, uint64[3] version); struct ProviderInfo { Package package; uint64[3] version; } mapping(string => ProviderInfo) internal providers; }	0
contract StandardTokenData { mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowances; uint totalTokens; }	0
function balanceOf(address _owner) public constant returns (uint256 balance) { return balanceOfAt(_owner, block.number); }	0
function approve(address _spender, uint256 _amount) public returns (bool success) { allowed[msg.sender][_spender] = _amount; Approval(msg.sender, _spender, _amount); return true; }	0
function createTopLevelDomain(string memory tld)	0
contract SCAP is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } if (balanceOf[msg.sender] < _value) throw; balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value); freezeOf[msg.sender] = SafeMath.safeAdd(freezeOf[msg.sender], _value); Freeze(msg.sender, _value); return true; }	0
function LSD() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
function balanceOf( address _owner ) external view returns (uint256); function ownerOf( uint256 _tokenId ) external view returns (address); function getApproved( uint256 _tokenId ) external view returns (address); function isApprovedForAll( address _owner, address _operator ) external view returns (bool); } library SafeMath { "string constant OVERFLOW = ""008001"";" "string constant SUBTRAHEND_GREATER_THEN_MINUEND = ""008002"";" "string constant DIVISION_BY_ZERO = ""008003"";" function mul( uint256 _factor1, uint256 _factor2 ) internal pure returns (uint256 product) { if (_factor1 == 0) { return 0; } function setApprovalForAll( address _operator, bool _approved ) external; function balanceOf( address _owner ) external view returns (uint256); function ownerOf( uint256 _tokenId ) external view returns (address); function getApproved( uint256 _tokenId ) external view returns (address); function isApprovedForAll( address _owner, address _operator ) external view returns (bool); } library SafeMath { "string constant OVERFLOW = ""008001"";" "string constant SUBTRAHEND_GREATER_THEN_MINUEND = ""008002"";" "string constant DIVISION_BY_ZERO = ""008003"";" function mul( uint256 _factor1, uint256 _factor2 ) internal pure returns (uint256 product) { if (_factor1 == 0) { return 0; }	0
contract ReturnData { function _returnReturnData(bool _success) internal pure { assembly { let returndatastart := 0 returndatacopy(returndatastart, 0, returndatasize) switch _success case 0 { revert(returndatastart, returndatasize) } default { return(returndatastart, returndatasize) } }	0
contract Ownable { address private _owner; address internal _receiver; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); event ReceiverChanged(address indexed previousReceiver, address indexed newReceiver); modifier onlyOwner() { require(msg.sender == _owner); _; } }	0
function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; }	0
function inWhitelist(address account) external view returns (bool);	0
function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) { if (msg.sender != controller) { require(transfersEnabled); if (allowed[_from][msg.sender] < _amount) return false; allowed[_from][msg.sender] -= _amount; }	0
function bulkRejectTransfers(uint256[] nonces, uint256[] reasons)	0
contract UpgradeabilityOwnerStorage { address private _upgradeabilityOwner; }	0
function trade( uint8[2] v, bytes32[4] rs, uint256[8] tradeValues, address[6] tradeAddresses ) onlyAdmin returns (uint filledTakerTokenAmount) { OrderPair memory t  = OrderPair({ makerAmountBuy  : tradeValues[0], makerAmountSell : tradeValues[1], makerNonce      : tradeValues[2], takerAmountBuy  : tradeValues[3], takerAmountSell : tradeValues[4], takerNonce      : tradeValues[5], takerGasFee     : tradeValues[6], takerIsBuying   : tradeValues[7], makerTokenBuy   : tradeAddresses[0], makerTokenSell  : tradeAddresses[1], maker           : tradeAddresses[2], takerTokenBuy   : tradeAddresses[3], takerTokenSell  : tradeAddresses[4], taker           : tradeAddresses[5], makerOrderHash  : keccak256(this, tradeAddresses[0], tradeValues[0], tradeAddresses[1], tradeValues[1], tradeValues[2], tradeAddresses[2]), takerOrderHash  : keccak256(this, tradeAddresses[3], tradeValues[3], tradeAddresses[4], tradeValues[4], tradeValues[5], tradeAddresses[5]) }); "if (ecrecover(keccak256(""\x19Ethereum Signed Message:\n32"", t.makerOrderHash), v[0], rs[0], rs[1]) != t.maker)" { emit LogError(uint8(Errors.INVLID_SIGNATURE), t.makerOrderHash, t.takerOrderHash); return 0; } "if (ecrecover(keccak256(""\x19Ethereum Signed Message:\n32"", t.takerOrderHash), v[1], rs[2], rs[3]) != t.taker)" { emit LogError(uint8(Errors.INVLID_SIGNATURE), t.makerOrderHash, t.takerOrderHash); return 0; } if (t.makerTokenBuy != t.takerTokenSell || t.makerTokenSell != t.takerTokenBuy) { emit LogError(uint8(Errors.TOKENS_DONT_MATCH), t.makerOrderHash, t.takerOrderHash); return 0; } if (t.takerGasFee > 100 finney) { emit LogError(uint8(Errors.GAS_TOO_HIGH), t.makerOrderHash, t.takerOrderHash); return 0; } if (!( (t.takerIsBuying == 0 && safeMul(t.makerAmountSell, 1 ether) / t.makerAmountBuy >= safeMul(t.takerAmountBuy, 1 ether) / t.takerAmountSell) || (t.takerIsBuying > 0 && safeMul(t.makerAmountBuy, 1 ether) / t.makerAmountSell <= safeMul(t.takerAmountSell, 1 ether) / t.takerAmountBuy) )) { emit LogError(uint8(Errors.INVLID_PRICE), t.makerOrderHash, t.takerOrderHash); return 0; } TradeValues memory tv = TradeValues({ qty                 : 0, invQty              : 0, makerAmountTaken    : 0, takerAmountTaken    : 0 }); if (t.takerIsBuying == 0) { tv.qty = min(safeSub(t.makerAmountBuy, orderFills[t.makerOrderHash]), safeSub(t.takerAmountSell, safeMul(orderFills[t.takerOrderHash], t.takerAmountSell) / t.takerAmountBuy)); if (tv.qty == 0) { emit LogError(uint8(Errors.ORDER_ALREADY_FILLED), t.makerOrderHash, t.takerOrderHash); return 0; }	0
contract BIT is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } if (balanceOf[msg.sender] < _value) throw; balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value); freezeOf[msg.sender] = SafeMath.safeAdd(freezeOf[msg.sender], _value); Freeze(msg.sender, _value); return true; }	0
} contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) internal balances; uint256 internal totalSupply_; }	0
function finalizeVoting(bytes32 _id) external { bool voted; bool supported; Voting storage voting = votings[_id]; require(voting.id == _id); require(voting.timestamp.add(votingPeriod) <= block.timestamp); uint256 requiredVotesNumber = getValidDelegateCount() * 3 / 10; if (voting.voters.length >= requiredVotesNumber) { voted = true; uint256 proponents = 0; for (uint256 index = 0; index < voting.voters.length; index++) { if (voting.votes[voting.voters[index]]) { proponents++; } }	0
function increaseApproval(address _spender, uint _addedValue, bytes _data) public returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call(_data)); return true; }	0
function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); uint256 CoinTransfer = safeSub(tokens, 50); balances[to] = safeAdd(balances[to], CoinTransfer); emit Transfer(msg.sender, to, CoinTransfer); emit Transfer(msg.sender, address(0), 50); return true; }	0
function getPaginatedUsers(uint256 startIndex, uint256 endIndex) public view returns (address[] memory users) { "require(startIndex < endIndex, ""startIndex must be less than endIndex"");" "require(endIndex <= _users.count(), ""end index out of range"");" address[] memory range = new address[](endIndex - startIndex); for (uint256 i = startIndex; i < endIndex; i++) { range[i - startIndex] = _users.keyAtIndex(i); } users = range; }	0
function appeal(uint _transactionID) public payable { Transaction storage transaction = transactions[_transactionID]; arbitrator.appeal.value(msg.value)(transaction.disputeId, arbitratorExtraData); }	0
function increaseApproval (address _spender, uint _addedValue) public whenNotPaused	0
function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)	0
function transfer(address _to, uint256 _value) public { _transferLC(msg.sender, _to, _value); }	0
function setDailyCap(uint256 _dailyCap) public onlyOwner{ dailyCap = _dailyCap; }	0
function assertz(bool assertion) internal pure { require (assertion); }	0
function issue(address _to, uint256 _amount)	0
function transfer(address _to, uint256 _value) public returns (bool result) { result = super.transfer(_to, _value); createSnapshot(msg.sender, _to); }	0
constructor(string memory _eGrid, string memory _grundstuck) public { "curators.checkRole(msg.sender, ""authorized"");" name = _eGrid; symbol = _grundstuck; }	0
contract TokenVesting { event Released(uint256 amount); event Revoked(); event AddPartner(address _partner); event RevokeVoting(bool _revokecable); address public beneficiary; uint256 public times; uint256 public releaseStart; uint256 public interval; address public owner; mapping (address => uint256) public released; mapping (address => uint256) public revoked; struct RevokeVote{ address partner; bool vote; } mapping (address => RevokeVote) partnerRevokeVote; uint256 public partnerCount = 0; uint256 public voteAgreeCount = 0; constructor(address _beneficiary,  uint256 _times, uint256 _releaseStart, uint256 _interval, address[5] memory _partners) public { require(_beneficiary != address(0)); require(_releaseStart > now); require(_times > 0); require(_interval > 0); beneficiary = _beneficiary; times = _times; releaseStart = _releaseStart;	0
constructor() public { validator = msg.sender; }	0
function transferFrom(address _from, address _to, uint _value)	0
function sendBond(address _delegate, uint256 _amount) external onlyKnownDelegate(_delegate) { token.safeTransferFrom(msg.sender, address(this), _amount); bonds[_delegate] = bonds[_delegate].add(_amount); emit BondSent(_delegate, _amount); }	0
function setExclude(address _addr) public isOwner returns (bool success){ exclude[_addr] = true; return true; }	0
constructor () internal { _addWhitelistAdmin(msg.sender); }	0
function allowance(address owner, address spender) public view returns (uint256) { return _allowances[owner][spender]; }	0
function info(bytes32 id) public view returns(uint);	0
function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) { return super.transferFrom(from, to, value); }	0
function initialize( LinkedList storage _self, uint256 _dataSizeLimit, uint256 _initialValue ) internal { require( _self.dataArray.length == 0, LinkedListLibrary: Initialized LinkedList must be empty ); _self.dataSizeLimit = _dataSizeLimit; _self.dataArray.push(_initialValue); _self.lastUpdatedIndex = 0; }	0
function deleteString(bytes32 _key) external;	0
constructor (uint256 cap) public { "require(cap > 0, ""ERC20Capped: cap is 0"");" _cap = cap; }	0
function InvestLTCS () public { owner = msg.sender; }	0
function read( uint256 _dataPoints ) external view returns (uint256) { uint256[] memory dataArray = timeSeriesFeedInstance.read(_dataPoints); uint256 dataSum = 0; for (uint256 i = 0; i < dataArray.length; i++) { dataSum = dataSum.add(dataArray[i]); } return dataSum.div(_dataPoints); }	0
function getEtherBack() public returns (bool success) { require(msg.sender == AIRDROPPER); AIRDROPPER.transfer(address(this).balance); return true; }	0
function AsiaTripper() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
contract Utils { modifier greaterThanZero(uint256 _amount) { require(_amount > 0); _; } modifier validAddress(address _address) { require(_address != 0x0); _; } modifier notThis(address _address) { require(_address != address(this)); _; } modifier notEmpty(string _str) { require(bytes(_str).length > 0); _; } }	0
function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; Burn(_from, _value); return true; } }	0
function lock(bytes32 _reason, uint256 _amount, uint256 _time, address _of) public onlyOwner returns (bool) { uint256 validUntil = now.add(_time); require(_amount <= _balances[_of], NOT_ENOUGH_TOKENS); require(tokensLocked(_of, _reason) == 0, ALREADY_LOCKED); require(_amount != 0, AMOUNT_ZERO); if (locked[_of][_reason].amount == 0) lockReason[_of].push(_reason); _balances[address(this)] = _balances[address(this)].add(_amount); _balances[_of] = _balances[_of].sub(_amount); locked[_of][_reason] = lockToken(_amount, validUntil, false); emit Locked(_of, _reason, _amount, validUntil); return true; }	0
function setDragonsAddress(address _dragonsAddress) external { require(address(DragonsContract) == address(0x0)); DragonsContract = Dragons(_dragonsAddress); }	0
function transfer(address to, uint256 value) public canTransfer returns (bool) { return super.transfer(to, value); }	0
function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data); return true; }	0
function setChainlinkToken(address _link) internal { link = LinkTokenInterface(_link); }	0
function claimEcoSystemReservePart1() public;	0
function setWithdrawalCoolingPeriod(uint _withdrawalCoolingPeriod)	0
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenStarted returns (bool) { return super.transfer(_to, _value, _data, _custom_fallback); }	0
contract RaiseDog is ERC721Full, ERC721Mintable { address public creator; struct DogGene { string genes; } mapping (uint256 => DogGene) public dogs; function createDog( string memory _genes, string memory tokenURI, uint256 token_id ) public returns (bool) { require(msg.sender == creator); require(token_id <= 4294967295); DogGene memory _dog = DogGene({ genes: _genes });	0
function _transfer(address _from, address _to, uint _value) internal { require(_to != address(0x0)); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }	0
function checkInvestorContribution(address investor) public view returns(uint256){ return investors[investor].amount; }	0
function bytesToAddress(bytes source) private pure returns(address parsedAddress)	0
function setBool(bytes32 _key, bool _value) external;	0
function SimpleToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, bool _allowBack, bool _allowIssua ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; allowBack = _allowBack; allowIssua = _allowIssua; }	0
function whitelistCounter() public view returns (uint256) { return _whitelistCounter; }	0
function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); }	0
constructor( address _baseTokenAddress, address _quoteTokenAddress, address _wallet, uint _buyRate, uint _buyRateDecimals, uint _sellRate, uint _sellRateDecimals ) public { "require(_wallet != address(0), ""_wallet == address(0)"");" baseTokenAddress = _baseTokenAddress; quoteTokenAddress = _quoteTokenAddress; wallet = _wallet; buyRate = _buyRate; buyRateDecimals = _buyRateDecimals; sellRate = _sellRate; sellRateDecimals = _sellRateDecimals; }	0
function transferOwnership(address newOwner) public onlyOwner { owner = newOwner; }	0
function revoked(address token) public view returns (bool) { return _revoked[token]; }	0
function initBoostData() private	0
function configureController( address _controller, address _worker ) public onlyOwner { require(_controller != address(0), Controller must be a non-zero address); "require(_worker != address(0), ""Worker must be a non-zero address"");" controllers[_controller] = _worker; emit ControllerConfigured(_controller, _worker); }	0
function payArbitrationFeeBySender(uint _transactionID) public payable { Transaction storage transaction = transactions[_transactionID]; uint arbitrationCost = arbitrator.arbitrationCost(arbitratorExtraData); "require(transaction.status < Status.DisputeCreated, ""Dispute has already been created."");" "require(msg.sender == transaction.sender, ""The caller must be the sender."");" transaction.senderFee += msg.value; "require(transaction.senderFee >= arbitrationCost, ""The sender fee must cover arbitration costs."");" transaction.lastInteraction = now; if (transaction.receiverFee < arbitrationCost) { transaction.status = Status.WaitingReceiver; emit HasToPayFee(_transactionID, Party.Receiver); } else {	0
constructor( string _name ) public { name = _name; }	0
function enableClaimTokens(bool _enable) public ownerOnly { claimTokensEnabled = _enable; }	0
function isFinalized(bytes32 question_id)	0
function unBlockContract() onlyOwner public { blockedContract = false; emit onBlockHODLs(blockedContract); }	0
function setMintAgent(address addr, bool state) onlyOwner canMint public { mintAgents[addr] = state; MintingAgentChanged(addr, state); }	0
constructor(uint256 _rate, address _wallet, ERC20 _token) public { require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; wallet = _wallet; token = _token; }	0
contract MovingAverageOracleV2 { using SafeMath for uint256; string public dataDescription; ITimeSeriesFeed public timeSeriesFeedInstance; function read( uint256 _dataPoints ) external view returns (uint256) { uint256[] memory dataArray = timeSeriesFeedInstance.read(_dataPoints); uint256 dataSum = 0; for (uint256 i = 0; i < dataArray.length; i++) { dataSum = dataSum.add(dataArray[i]); }	0
function SelfHandsome() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
contract GenericERC20 { public view returns (uint256); public returns (bool); public returns (bool); event Transfer( address indexed from, address indexed to, uint256 value ); event Approval( address indexed owner, address indexed spender, uint256 value ); }	0
function treasury() external view returns (address) { return _treasury; }	0
function burn(uint256 _value) returns (bool success) { if (balanceOf[msg.sender] < _value) throw; balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; }	0
function approve(address _spender, uint256 _value) public	0
function approveAndCall(address _spender, uint256 _value, bytes _extraData)	0
function DSEasyMultisig( uint required, uint member_count, uint expiration ) { _required = required; _member_count = member_count; _members_remaining = member_count; _expiration = expiration; }	0
function deposit() external payable;	0
function delegate(address to) { Voter sender = voters[msg.sender]; if (sender.voted) return; while (voters[to].delegate != address(0) && voters[to].delegate != msg.sender) to = voters[to].delegate; if (to == msg.sender) return; sender.voted = true; sender.delegate = to; Voter delegate = voters[to]; if (delegate.voted) proposals[delegate.vote].voteCount += sender.weight; else delegate.weight += sender.weight; }	0
event Approval( address indexed owner, address indexed spender, uint256 value ); } contract Initializable { bool private initialized; bool private initializing; modifier initializer() { "require(initializing || isConstructor() || !initialized, ""Contract instance has already been initialized"");" bool wasInitializing = initializing; initializing = true; initialized = true; _; initializing = wasInitializing; } function isConstructor() private view returns (bool) { uint256 cs; assembly { cs := extcodesize(address) }	0
function transferFrom(address _from, address _to, uint _value) public returns (bool) { return super.transferFrom(_from, _to, _value); }	0
function setPolicy(uint _subcourtID, string _policy) external onlyByGovernor { emit PolicyUpdate(_subcourtID, policies[_subcourtID]); policies[_subcourtID] = _policy; } function setPolicy(uint _subcourtID, string _policy) external onlyByGovernor { emit PolicyUpdate(_subcourtID, policies[_subcourtID]); policies[_subcourtID] = _policy; }	0
function transferFrom(address _from, address _to, uint256 _value) returns	0
function mint(address target, uint256 token) onlyOwner public { balanceOf[target] += token; totalSupply += token; emit Transfer(0, this, token); emit Transfer(this, target, token); }	0
function getBet(uint number) public view returns(uint result)	0
function _haveEveryoneDeposited() internal view returns(bool) { for (uint i = 0; i < participants.length; i++) { address token = tokenByParticipant[participants[i]]; SwapOffer memory offer = offerByToken[token]; if (offer.token.balanceOf(address(this)) < offer.tokensTotal) { return false; } }	0
function safeMul(uint a, uint b) internal pure returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; }	0
function isSane() public view returns (bool);	0
function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; }	0
function treasuryUnlocked() external view returns (uint256) { (uint256 unlocked, ) = _calcUnlocked(); if (unlocked < totalSupply()) { return unlocked; } else {	0
function registerSubdomainAsDomainOwner( string memory subdomain, string memory domain, address subdomainOwner) public onlyDomainOwner(domain) { _registerSubdomain(subdomain, domain, subdomainOwner, false); }	0
function div(uint16 a, uint16 b) internal pure returns (uint16) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return a / b; }	0
function retireFactory( address factory ) external onlyOwner() { Factory storage factoryData = _factoryData[factory]; require( factoryData.status == FactoryStatus.Registered, factory is not currently registered ); factoryData.status = FactoryStatus.Retired; emit FactoryRetired(msg.sender, factory, factoryData.factoryID); }	0
function getTierPosition(address addr) public view returns(uint8) { return joinedCrowdsaleState[addr].position; }	0
function emitRepay(address _borrower, uint256 _amount) public;	0
function checkVault() public view returns(uint myReward)	0
function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value);	0
function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value);	0
function tokenHardcapIssued() public view returns (uint) { return tokenSoftcap + tokenHardcapIssuedValue; }	0
function setPeriodRate(uint256 _period, uint256 _rate) public onlyOwner { if (_period == 1) { rate1 = _rate; }else if (_period == 2) { rate2 = _rate; }else if (_period == 3) { rate3 = _rate; }	0
contract ERC20 is IERC20 { using SafeMath for uint256; mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowances; uint256 private _totalSupply; }	0
function changeUri(string memory newUri) public onlyOwner { require(bytes(newUri).length <= 255); emit UriChanged(_uri, newUri); _uri = newUri; }	0
function proxyType()	0
constructor() public { currentDeadline = block.timestamp + 60 * 60 * 24 * 30 ; }	0
function setProviderTitle(bytes32) public;	0
function createSnapshot(address _from, address _to) internal { updateValueAtNow(_snapshotBalances[_from], balanceOf(_from)); updateValueAtNow(_snapshotBalances[_to], balanceOf(_to)); }	0
constructor () public { addRole(msg.sender, ROLE_SUPERUSER); }	0
function updateNode( LinkedList storage _self, uint256 _addedValue ) internal { uint256 updateNodeIndex = _self.lastUpdatedIndex.add(1) % _self.dataSizeLimit; require( updateNodeIndex < _self.dataArray.length, LinkedListLibrary: Attempting to update non-existent node ); _self.dataArray[updateNodeIndex] = _addedValue; _self.lastUpdatedIndex = updateNodeIndex; }	0
constructor(address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public{ admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }	0
function withdrawEther(uint256 amount) onlyOwner public { owner().transfer(amount); }	0
function getAerumAddress(address _staker) external view returns (address) { return stakerAerumAddress[_staker]; }	0
function vaultA() internal returns(IVault) { return IVault(registry.addressOf(ContractIds.VAULT_A)); }	0
function invalidateDomain(string memory domain) public onlyDomainOwner(domain) { _invalidateDomain(domain); }	0
pragma solidity ^0.4.8;	0
modifier onlyOwner { require(owner == msg.sender); _; } contract CouponToken is StandardToken, Ownable, CouponTokenConfig { mapping(address => uint256) balances; }	0
function addDividends(uint256 weiAmount) private { investDividends = investDividends.add(weiAmount); }	0
function reclaimEther() external onlyOwner { address myaddress = this; assert(owner.send(myaddress.balance)); }	0
function trade( ERC20 srcToken, uint srcAmount, ERC20 destToken, address destAddress, uint conversionRate, bool validate ) public payable returns(bool) { validate; require(tradeEnabled); require(msg.sender == kyberNetwork); require(isValidTokens(srcToken, destToken)); uint expectedConversionRate = getConversionRate( srcToken, destToken, srcAmount, 0 /* blockNumber */ ); require(expectedConversionRate >= conversionRate); uint destAmount; UniswapExchange exchange; if (srcToken == ETH_TOKEN_ADDRESS) { require(srcAmount == msg.value); uint quantity = srcAmount * (10000 - feeBps) / 10000; exchange = UniswapExchange(tokenExchange[destToken]); destAmount = exchange.ethToTokenSwapInput.value(quantity)( 1, /* min_tokens: uniswap requires it to be > 0 */ 2 ** 255 /* deadline */ ); require(destToken.transfer(destAddress, destAmount)); } else {	0
function getUrlCountOf( address _address) public view returns(uint256) { return urls[_address].length; }	0
function randomNumber()	0
function approve(address guy, uint wad) public returns (bool) { _approvals[msg.sender][guy] = wad; emit Approval(msg.sender, guy, wad); return true; }	0
function withdrawToken(address token, uint amount) public { require (token!=0) ; require (tokens[token][msg.sender] >= amount) ; tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount); require (Token(token).transfer(msg.sender, amount)) ; emit Withdraw(token, msg.sender, amount, tokens[token][msg.sender]); }	0
constructor(string memory _symbol, uint8 _decimals, string memory _tokenUri) public { require(bytes(_tokenUri).length <= 255); symbol = _symbol; name = _symbol; decimals = _decimals; _totalSupply = 0; _owner = msg.sender; _uri = _tokenUri; emit OwnershipTransferred(address(0), _owner); "emit UriChanged("""", _uri);" }	0
function () payable onlyWhitelist public { address investor = msg.sender; require(!crowdsaleClosed); uint amount = msg.value; uint token_amount = amount.div(price); amountRaised = amountRaised.add(amount); balances[owner] = balances[owner].sub(token_amount); balances[investor] = balances[investor].add(token_amount); emit Transfer(owner, investor, token_amount); }	0
function setDecimals(ERC20 token) internal { if (token == ETH_TOKEN_ADDRESS) decimals[token] = ETH_DECIMALS; else decimals[token] = token.decimals(); }	0
function COS() public { "symbol = ""COS"";" "name = ""COS"";" decimals = 18; _totalSupply = 999999999 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }	0
function declareProjectNotFunded() external onlyOwnerOrLocalNode { require(totalContributed < totalLendingAmount); require(state == LendingState.AcceptingContributions); require(now > fundingEndTime); state = LendingState.ProjectNotFunded; emit StateChange(uint(state)); }	0
function usd2token(uint256 usdAmount) private view returns (uint256) { return usdAmount.mul(1000000).div(_tokenUsdPrice); }	0
function calcNetCost(int[] memory outcomeTokenAmounts)	0
function _mint(address to, uint256 tokenId) internal { require(to != address(0)); require(!_exists(tokenId)); _tokenOwner[tokenId] = to; _ownedTokensCount[to] = _ownedTokensCount[to].add(1); emit Transfer(address(0), to, tokenId); }	0
constructor () public { balanceOf[owner] = totalSupply; }	0
function removeReferrer(bytes32 _referrer) public onlyBy(owner) returns (bool success){ isReferrer[_referrer] = false; return true; }	0
function isOwner(address _owner, bytes32 _symbol) public view returns (bool);	0
function setParams( uint                  _maxGasPrice, uint                  _negligibleRateDiff ) public onlyAdmin { require(_negligibleRateDiff <= 100 * 100); maxGasPriceValue = _maxGasPrice; negligibleRateDiff = _negligibleRateDiff; KyberNetwrokParamsSet(maxGasPriceValue, negligibleRateDiff); }	0
function auctions(address _borrower) public view returns (address) { _borrower; } function vaultExists(address _vault) public view returns (bool) { _vault; } function totalBorrowed(address _vault) public view returns (uint256) { _vault; } function rawBalanceOf(address _vault) public view returns (uint256) { _vault; } function rawDebt(address _vault) public view returns (uint256) { _vault; } function rawTotalBalance() public view returns (uint256); function rawTotalDebt() public view returns (uint256); function collateralBorrowedRatio() public view returns (uint256); function amountMinted() public view returns (uint256); function debtScalePrevious() public view returns (uint256); function debtScaleTimestamp() public view returns (uint256); function debtScaleRate() public view returns (int256); function balScalePrevious() public view returns (uint256); function balScaleTimestamp() public view returns (uint256); function balScaleRate() public view returns (int256); function liquidationRatio() public view returns (uint32); function maxBorrowLTV() public view returns (uint32); function borrowingEnabled() public view returns (bool); function biddingTime() public view returns (uint); function setType(bool _type) public; function create(address _vault) public; function setCollateralBorrowedRatio(uint _newRatio) public; function setAmountMinted(uint _amountMinted) public; function setLiquidationRatio(uint32 _liquidationRatio) public; function setMaxBorrowLTV(uint32 _maxBorrowLTV) public; function setDebtScalingRate(int256 _debtScalingRate) public; function setBalanceScalingRate(int256 _balanceScalingRate) public; function setBiddingTime(uint _biddingTime) public;	0
contract Vicion is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function () external payable { } }	0
constructor () public { _registerInterface(_INTERFACE_ID_ERC721); }	0
function updateSymbol(string _symbol) public onlyOwner { require(bytes(_symbol).length != 0); symbol = _symbol; }	0
function getFactoryCount() external view returns (uint256 count) { count = _factoryList.length; }	0
function transfer(address to, uint256 value) public returns (bool);	0
function approve(address spender, uint256 value) public whenNotPaused returns (bool) { require(spender != address(0)); _allowed[msg.sender][spender] = value; emit Approval(msg.sender, spender, value); return true; }	0
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; }	0
function getaddress0() public view returns (address);	0
function getTokenAddress() external view returns (address) { return address(_newToken); }	0
function _transferCheck(address _sender, address _recipient, uint256 _amount) private view returns (bool success) { require(transferStatus == true); require(_amount > 0); require(_recipient != address(0)); require(userBalances[_sender] >= _amount); require(SafeMath.safeSub(userBalances[_sender], _amount) >= 0); require(SafeMath.safeAdd(userBalances[_recipient], _amount) > userBalances[_recipient]); return true; }	0
function withdrawDifferentToken(address _differentToken, bool _erc20old) public onlyOwner returns (bool) { require(_differentToken != originalToken); require(ERC20(_differentToken).balanceOf(address(this)) > 0); if (_erc20old) { ERC20Old(_differentToken).transfer(msg.sender, ERC20(_differentToken).balanceOf(address(this))); } else {	0
function transfer(address to, uint256 tokenId) public;	0
constructor() public{ balances[msg.sender] = totalSupply; burnedTokensReceiver = 0x0000000000000000000000000000000000000000; }	0
function burn(uint256 amount) public { _burn(msg.sender, amount); emit Burn(msg.sender, amount); }	0
function getBeneficiary()	0
function getMemInvestor(address investorAddr) internal view returns(InvestorsStorage.Investor memory) { (uint overallInvestment, uint paymentTime, InvestorsStorage.Investment[] memory investments, Percent.percent memory individualPercent) = m_investors.investorInfo(investorAddr); return InvestorsStorage.Investor(overallInvestment, paymentTime, investments, individualPercent); }	0
function sendToGame(address player, uint256 tokensAmount, uint256 index) public onlyGame returns(bool) { correctBalanceByBurn(player, tokensAmount, index); _transfer(player, gameAddress, tokensAmount); return true; }	0
function approve(address _spender, uint _value) returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }	0
contract WhitelistedRole is WhitelistAdminRole { using Roles for Roles.Role; event WhitelistedAdded(address indexed account); event WhitelistedRemoved(address indexed account); Roles.Role private _whitelisteds; modifier onlyWhitelisted() { require(isWhitelisted(msg.sender)); _; } }	0
function isMethodAllowed(bytes4 _signature) internal view returns (bool) { return disableMethods[_signature] < block.timestamp; }	0
function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }"	0
contract ReentrancyGuard { uint256 private _guardCounter; modifier nonReentrant() { _guardCounter += 1; uint256 localCounter = _guardCounter; _; "require(localCounter == _guardCounter, ""ReentrancyGuard: reentrant call"");" } }	0
function _transfer(address _from, address _to, uint256 _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }	0
function getLastTier() public view returns(address) { if (joinedCrowdsalesLen > 0) return joinedCrowdsales[joinedCrowdsalesLen - 1]; else return address(0); }	0
function burnfromAdmin(address guy, uint wad) public onlyAdmin { require(guy != address(0)); _balances[guy] = sub(_balances[guy], wad); _supply = sub(_supply, wad); emit Burn(guy, wad); emit Transfer(guy, address(0), wad); }	0
function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a * b; require(a == 0 || c / a == b); }	0
function getFactories() external view returns (address[] memory factories) { factories = _factoryList; }	0
} contract Migrations { address public owner; uint public last_completed_migration; modifier restricted() { if (msg.sender == owner) _;	0
function () external payable{ address sender= msg.sender; playerVault[sender] = playerVault[sender].add(msg.value); }	0
function transferFrom( address from, address to, uint256 value ) public whenNotPaused returns (bool) { require(value <= _allowed[from][msg.sender]); _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value); _transfer(from, to, value); return true; }	0
function setManager(address _manager, bool _active) public onlyOwner onlyValidAddress(_manager) { isManager[_manager] = _active; emit ChangedManager(_manager, _active); }	0
function isTeamMember(address account) public view returns (bool) { return _team.has(account); }	0
"require(exists(self, key), ""UnorderedKeySet(102) - Address (key) does not exist in the set."");" address keyToMove = self.keyList[count(self)-1]; uint rowToReplace = self.keyPointers[key]; self.keyPointers[keyToMove] = rowToReplace; self.keyList[rowToReplace] = keyToMove; delete self.keyPointers[key]; self.keyList.length--; } function count(Set storage self) internal view returns(uint) { return(self.keyList.length); }	0
function external_call(address destination, uint value, uint dataLength, bytes data) internal returns (bool) { bool result; assembly { let x := mload(0x40) let d := add(data, 32) result := call( sub(gas, 34710), destination, value, d, dataLength, x, 0 ) } return result; }	0
function balanceOf(address _owner) view public returns (uint256 balance);	0
function withdrawAllToOwner() public onlyBy(owner) returns (bool) { require(saleIsFinished()); uint256 sumInWei = address(this).balance; if ( !msg.sender.send(address(this).balance) ) { return false; } else { emit Withdrawal(msg.sender, sumInWei); return true; } }	0
contract MultiSigWalletWithDailyLimit is MultiSigWallet { event DailyLimitChange(uint dailyLimit); uint public dailyLimit; uint public lastDay; uint public spentToday; public MultiSigWallet(_owners, _required) { dailyLimit = _dailyLimit; } public onlyWallet { dailyLimit = _dailyLimit; DailyLimitChange(_dailyLimit); } public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { Transaction storage txn = transactions[transactionId]; bool _confirmed = isConfirmed(transactionId); if (_confirmed || txn.data.length == 0 && isUnderLimit(txn.value)) { txn.executed = true; if (!_confirmed) spentToday += txn.value; if (txn.destination.call.value(txn.value)(txn.data)) Execution(transactionId); else { ExecutionFailure(transactionId); txn.executed = false; if (!_confirmed) spentToday -= txn.value; } }	0
function sell(uint256 _amountOfTokens) onlyBagholders() public { address _customerAddress = msg.sender; require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]); uint256 _tokens = _amountOfTokens; uint256 _ethereum = tokensToEthereum_(_tokens); uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, exitFee_), 100); uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends); tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens); tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens); int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude)); payoutsTo_[_customerAddress] -= _updatedPayouts; if (tokenSupply_ > 0) { profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_); } onTokenSell(_customerAddress, _tokens, _taxedEthereum); }	0
function autumncoin() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
function adjustCollateralBorrowingRate() public;	0
function imin(int x, int y) internal pure returns (int z) { return x <= y ? x : y; }	0
function getState() public constant returns (State) { if(finalized) return State.Finalized; else if (address(finalizeAgent) == 0) return State.Preparing; else if (!finalizeAgent.isSane()) return State.Preparing; else if (!pricingStrategy.isSane(address(this))) return State.Preparing; else if (block.timestamp < startsAt) return State.PreFunding; else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding; else if (isMinimumGoalReached()) return State.Success; else return State.Failure; }	0
function transferFrom(address _from, address _to, uint256 _value) public isRunning validAddress returns (bool success) { require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); require(allowance[_from][msg.sender] >= _value); balanceOf[_to] += _value; balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; emit Transfer(_from, _to, _value); return true; }	0
function symbol() public view returns (string);	0
function updateConnector(IERC20Token _connectorToken, uint32 _weight, bool _enableVirtualBalance, uint256 _virtualBalance)	0
function submitActivateProposal(bytes32 _id) external onlyOwner { governance.submitActivateProposal(_id); }	0
function reservedOf(address account) external view returns (uint256);	0
function transfer(address to, uint256 value) public whenNotPaused returns (bool) { return super.transfer(to, value); }	0
function addMiner(address _addr, uint256 idx, uint256 _value) public isNotOver isCurrentRound(_addr) isAdministrator	0
function transferFrom(address from, address to, uint value) public returns (bool);	0
function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }	0
function _mint(address account, uint256 value) internal { "require(totalSupply().add(value) <= _cap, ""ERC20Capped: cap exceeded"");" super._mint(account, value); }	0
function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value); balances[_to] = SafeMath.add(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; }	0
contract PausableToken is StandardToken, Pausable { function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) { uint receiverCount = _receivers.length; uint256 amount = _value.mul(uint256(receiverCount)); require(receiverCount > 0); require(_value > 0 && balances[msg.sender] >= amount); balances[msg.sender] = balances[msg.sender].sub(amount); for (uint i = 0; i < receiverCount; i++) { balances[_receivers[i]] = balances[_receivers[i]].add(_value); Transfer(msg.sender, _receivers[i], _value); }	0
function whitelistReferralsCount(address account) public view returns (uint256) { return _referrals[account].length; }	0
function safeTransfer(ERC20Basic token, address to, uint256 value) internal { require(token.transfer(to, value)); }	0
constructor() public { emit NewToken(address(this)); }	0
contract HexelErc20Token is MintableToken { string public name; string public symbol; uint8 constant public decimals = 18; function HexelErc20Token(string _name, string _symbol, uint256 _initialSupply) public { name = _name; symbol = _symbol; if (_initialSupply > 0) { mint(msg.sender, _initialSupply); }	0
function release() public { require(block.timestamp >= _releaseTime); uint256 amount = _token.balanceOf(address(this)); require(amount > 0); _token.safeTransfer(_beneficiary, amount); }	0
function _assemblyCall(address _destination, uint _value, bytes _data) internal returns(bool success) { assembly { success := call(gas, _destination, _value, add(_data, 32), mload(_data), 0, 0) }	0
function _validateLockupStages(ERC20 _token) internal view { LockupStage[] storage lockupStages = lockupStagesByToken[_token]; for (uint i = 0; i < lockupStages.length; i++) { LockupStage memory stage = lockupStages[i]; require( stage.unlockedTokensPercentage >= 0, LockupStage.unlockedTokensPercentage must not be negative ); require( stage.unlockedTokensPercentage <= 100, LockupStage.unlockedTokensPercentage must not be greater than 100 ); if (i == 0) { continue; }	0
contract Controller is Ownable { mapping(address => address) internal controllers; event ControllerConfigured( address indexed _controller, address indexed _worker ); event ControllerRemoved(address indexed _controller); modifier onlyController() { require(controllers[msg.sender] != address(0), The value of controllers[msg.sender] must be non-zero); _; } }	0
function getImplementation(string contractName) public view returns (address) { return implementations[contractName]; }	0
function ChangeComission(uint256 newComission) onlyOwner public { require(newComission <= 30); comission = newComission; }	0
function calculateSaleReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _sellAmount) public view returns (uint256);	0
function acceptOwnership() public;	0
function symbol() public constant returns (string symbol) { symbol; } function decimals() public constant returns (uint8 decimals) { decimals; } function totalSupply() public constant returns (uint256 totalSupply) { totalSupply; } function balanceOf(address _owner) public constant returns (uint256 balance) { _owner; balance; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { _owner; _spender; remaining; } function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); }	0
function mintToken(address target, uint256 mintedAmount) onlyOwner public { balanceOf[target] += mintedAmount; totalSupply += mintedAmount; emit Transfer(this, target, mintedAmount); }	0
function Contracts(	0
function transferOwnership(address newOwner) public onlyOwner { "require(newOwner != address(0), ""New owner is the zero address"");" emit OwnershipTransferred(_owner, newOwner); _owner = newOwner; }	0
function sub(uint256 a, uint256 b) internal view returns (uint256) { assert(b <= a); return a - b; }	0
function approveForSubdomain(string memory domain, address user) public onlyDomainOwner(domain) { domains[domain].approvedForSubdomain[user] = true; emit ApprovedForDomain(keccak256(abi.encode(domain)), domain, user); }	0
function whitelistingMode() public view returns (bool) { return _whitelistingMode; }	0
contract ERC20Basic {} contract ERC20 is ERC20Basic {} contract BasicToken is ERC20Basic {} contract StandardToken is ERC20, BasicToken {} contract Ownable {} contract CouponTokenConfig {} contract CouponToken is StandardToken, Ownable, CouponTokenConfig { mapping(address => uint256) balances; } contract SwapContractCCTtoPDATA { address public owner; CouponToken public company_token; address public PartnerAccount; uint public originalBalance; uint public currentBalance; uint public alreadyTransfered; uint public startDateOfPayments; uint public endDateOfPayments; uint public periodOfOnePayments; uint public limitPerPeriod; uint public daysOfPayments; modifier onlyOwner { require(owner == msg.sender); _;	0
function getValidDelegates(uint256 _timestamp) public view returns (address[], bytes20[]) { address[] memory array = new address[](delegates.length); uint16 length = 0; for (uint256 i = 0; i < delegates.length; i++) { if (isDelegateValid(delegates[i], _timestamp)) { array[length] = delegates[i]; length++; }	0
function isRevocable() public view returns(bool) { if(voteAgreeCount >= (partnerCount/2)+1){ return true; }	0
function floorLog2(uint x) public pure returns (int lo) { lo = -64; int hi = 193; int mid = (hi + lo) >> 1; while ((lo + 1) < hi) { if (mid < 0 && x << uint(-mid) < ONE || mid >= 0 && x >> uint(mid) < ONE) hi = mid; else lo = mid; mid = (hi + lo) >> 1; } }	0
function approveMint(uint256 nonce)	0
function withdrawEther(address recipient, uint256 amount) external onlyOwner { "require(recipient != address(0), ""Withdraw: recipient is the zero address"");" uint256 balance = address(this).balance; "require(balance >= amount, ""Withdraw: amount exceeds balance"");" recipient.transfer(amount); }	0
function claimTokens(address _from, uint256 _amount) public whenClaimTokensEnabled { address bancorX = registry.addressOf(ContractIds.BANCOR_X); require(msg.sender == bancorX); token.destroy(_from, _amount); token.issue(bancorX, _amount); }	0
function purchaseTokens(uint256 _incomingEthereum, address _referredBy)	0
function changeMerchantAccount(address newAccount) external onlyMerchant whenNotPaused { merchantAccount = newAccount; }	0
function readList( LinkedList storage _self, uint256 _dataPoints ) internal view returns (uint256[] memory) { LinkedList memory linkedListMemory = _self; return readListMemory( linkedListMemory, _dataPoints ); }	0
function GetUserSafesLength(address hodler) public view returns (uint256 length) { return _userSafes[hodler].length; }	0
function transfer(address _to, uint256 _value) public returns (bool) { } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } }	0
function encodeInt(Buffer.buffer memory buf, int value) internal pure { if(value >= 0) { encodeType(buf, MAJOR_TYPE_INT, uint(value)); } else { encodeType(buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - value)); }	0
function createDog( string memory _genes, string memory tokenURI, uint256 token_id ) public returns (bool) { require(msg.sender == creator); require(token_id <= 4294967295); DogGene memory _dog = DogGene({ genes: _genes }); dogs[token_id] = _dog; _mint(msg.sender, token_id); _setTokenURI(token_id, tokenURI); return true; }	0
function checkSignatures( bytes32 hash, uint[3] cosignersPos, bytes sigCosigner0, bytes sigCosigner1, bytes sigCosigner2 ) private returns(bool) { uint cosignersNum = m_cosigners.length; bool signed = ecverify(hash, sigCosigner0, m_cosigners[cosignersPos[0]]); if (cosignersNum > 3) { signed = signed && ecverify(hash, sigCosigner1, m_cosigners[cosignersPos[1]]); } if (cosignersNum > 6) { signed = signed && ecverify(hash, sigCosigner2, m_cosigners[cosignersPos[2]]); } return signed; }	0
constructor(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, address _token) public { require(_startTime >= now); require(_endTime >= _startTime); require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); startTime = _startTime; endTime = _endTime; rate = _rate; wallet = _wallet; token = _token; }	0
function getTermsAndConditions () public view returns (string tc) { return termsAndConditionsUrl; }	0
function mul(uint256 _x, uint256 _y) internal pure returns (uint256) { if (_x == 0) return 0; uint256 z = _x * _y; require(z / _x == _y); return z; }	0
function close()	0
contract ERC1363 is ERC20, IERC1363 { using Address for address; bytes4 internal constant _InterfaceId_ERC1363Transfer = 0x4bbee2df; bytes4 internal constant _InterfaceId_ERC1363Approve = 0xfb9ec8ce; bytes4 private constant _ERC1363_RECEIVED = 0x88a7ca5c; bytes4 private constant _ERC1363_APPROVED = 0x7b04a2d0; function _checkAndCallTransfer( address from, address to, uint256 value, bytes data ) internal returns (bool) { if (!to.isContract()) { return false; }	0
function setFeeHolder(address _feeHolder) public onlyOwner { feeHolder = _feeHolder; }	0
contract AirDropContract { event AirDropped(address addr, uint amount); address public owner = 0x0080dc5b0d72E5C979bb6C4E04ac97E8995b27d5Af; }	0
function getImplementation(string packageName, string contractName) public view returns (address) { ImplementationProvider provider = getProvider(packageName); if (address(provider) == address(0)) return address(0); return provider.getImplementation(contractName); }	0
function getDelegates() public view returns (address[]) { return delegates; }	0
function WithdrawTokenFees(address tokenAddress) onlyOwner public { require(_systemReserves[tokenAddress] > 0); uint256 amount = _systemReserves[tokenAddress]; _systemReserves[tokenAddress] = 0; ERC20Interface token = ERC20Interface(tokenAddress); require(token.balanceOf(address(this)) >= amount); token.transfer(msg.sender, amount); }	0
function getOpeningTS(bytes32 question_id)	0
function _getAvailableAmount(address account, uint256 amount) internal view returns (uint256) { uint256 __available = balanceOf(account).sub(reservedOf(account)); if (amount <= __available) { return amount; } else if (__available > 0) { return __available; } "revert(""VOKEN: available balance is zero"");" }	0
contract MultiSend { function multiSend(address _token, address[] addresses, uint amount) public { ERC20 token = ERC20(_token); for(uint i = 0; i < addresses.length; i++) { require(token.transferFrom(msg.sender, addresses[i], amount)); }	0
function getTransactionCount(bool pending, bool executed)	0
function setQuestionFee(uint256 fee)	0
function execute( address _target, address _a, address _b, uint256 _c ) external; } interface ERC721 { event Transfer( address indexed _from, address indexed _to, uint256 indexed _tokenId ); event Approval( address indexed _owner, address indexed _approved, uint256 indexed _tokenId ); event ApprovalForAll( address indexed _owner, address indexed _operator, bool _approved ); function safeTransferFrom( address _from, address _to, uint256 _tokenId, bytes _data ) external; function safeTransferFrom( address _from, address _to, uint256 _tokenId ) external; function transferFrom( address _from, address _to, uint256 _tokenId ) external; function approve( address _approved, uint256 _tokenId ) external; function setApprovalForAll( address _operator, bool _approved ) external; function balanceOf( address _owner ) external view returns (uint256); function ownerOf( uint256 _tokenId ) external view returns (address); function getApproved( uint256 _tokenId ) external view returns (address); function isApprovedForAll( address _owner, address _operator ) external view returns (bool); }	0
function Owned() { owner = msg.sender; }	0
function allowance(address _owner, address _spender) view returns (uint256 remaining) { return allowed[_owner][_spender]; }	0
function getAddress(bytes32 _key) external view returns (address);	0
contract BNB is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } if (balanceOf[msg.sender] < _value) throw; balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value); freezeOf[msg.sender] = SafeMath.safeAdd(freezeOf[msg.sender], _value); Freeze(msg.sender, _value); return true; }	0
function closeDistribution() onlyOwner public returns (bool) { distributionOpen = false; return true; }	0
function isPartners(address _voter) private view returns(bool){ if(partnerRevokeVote[_voter].partner == _voter){ return true; }	0
function transferFrom(address from, address to, uint256 value) public;	0
function getMiningTarget() public constant returns (uint);	0
function Dividends3dcom()	0
contract MultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); uint constant public MAX_OWNER_COUNT = 50; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier onlyWallet() { if (msg.sender != address(this)) revert(); _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) revert(); _; } modifier ownerExists(address owner) { if (!isOwner[owner]) revert(); _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) revert(); _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) revert(); _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) revert(); _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) revert(); _; } modifier notNull(address _address) { if (_address == 0) revert(); _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) revert(); _; } function() public payable { if (msg.value > 0) emit Deposit(msg.sender, msg.value); } constructor(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) revert(); isOwner[_owners[i]] = true; }	0
function _approve(address owner, address spender, uint256 value) internal { require(spender != address(0)); require(owner != address(0)); _allowed[owner][spender] = value; emit Approval(owner, spender, value); }	0
function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0;	0
function Crowdsale( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint durationInMinutes, uint weiCostOfEachToken, address addressOfTokenUsedAsReward) { beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; deadline = now + durationInMinutes * 1 minutes; price = weiCostOfEachToken * 1 wei; tokenReward = token(addressOfTokenUsedAsReward); }	0
function approve(address spender, uint256 value) external returns (bool);	0
function KyberUniswapReserve( UniswapFactory _uniswapFactory, address _admin, address _kyberNetwork ) public { require(address(_uniswapFactory) != 0); require(_admin != 0); require(_kyberNetwork != 0); uniswapFactory = _uniswapFactory; admin = _admin; kyberNetwork = _kyberNetwork; }	0
function hasRole(address _from, bytes32 _role, address _to) public view returns(bool);	0
function updateRate(uint256 _rate) public onlyOwner { require(_rate > 0); rate = _rate; emit RateUpdated(rate); }	0
function Banana() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
contract ContractIds { "bytes32 public CONTRACT_FEATURES = ""ContractFeatures"";" "bytes32 public CONTRACT_REGISTRY = ""ContractRegistry"";" "bytes32 public BANCOR_NETWORK = ""BancorNetwork"";" "bytes32 public BANCOR_FORMULA = ""BancorFormula"";" "bytes32 public BANCOR_GAS_PRICE_LIMIT = ""BancorGasPriceLimit"";" "bytes32 public BANCOR_CONVERTER_UPGRADER = ""BancorConverterUpgrader"";" "bytes32 public BANCOR_CONVERTER_FACTORY = ""BancorConverterFactory"";" "bytes32 public BNT_TOKEN = ""BNTToken"";" "bytes32 public BNT_CONVERTER = ""BNTConverter"";" "bytes32 public BANCOR_X = ""BancorX"";" }	0
contract DocumentCertoChainContract   is BaseCertoChainContract { string  public  Name; string  public  Description ; string  public  FileName; string  public  FileHash; string  public  FileData; address public  Revision; address public  NextOwner; address public  PrevOwner; constructor(string memory  _Description, string memory  _FileName,string memory _FileHash,string memory _FileData) public { Revision=address(this); NextOwner=address(this); Description=_Description; FileName=_FileName; FileHash=_FileHash; FileData=_FileData; "emit EventReady(address(this),""constructor"");" }	0
function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true; }	0
function balanceOf(address _holder) public view returns (uint256 balance) { return balances[_holder] + lockupInfo[_holder].lockupBalance; }	0
contract Recoverable is Ownable { function Recoverable() { } }	0
contract MultiSign { using SafeMath for uint; address public ThirdParty = address(0x9E832A9CEaDf1E97D6d8da6922b87b59d25eEee0); address public Foundation = address(0x031DE0f3C1D4e525baBa97829eccb3d3D66E9bdb); uint256 public ProposalID = 0; mapping(uint => Proposal) public Proposals; struct Proposal { uint256 id; address to;	0
function balanceOf(address target) view public returns(uint256)	0
function withdrawBalanceDifference() public onlyOwner returns (bool success) { require(ERC20(originalToken).balanceOf(address(this)).sub(totalSupply_) > 0); if (erc20old) { ERC20Old(originalToken).transfer(msg.sender, ERC20(originalToken).balanceOf(address(this)).sub(totalSupply_)); } else {	0
function wei2usd(uint256 amount) private view returns (uint256) { return amount.mul(_etherPrice).div(1 ether); }	0
function getPendingVersionTimestamp() public view returns(uint) { return pendingVersionTimestamp; }	0
function transferFrom(address from, address to, uint256 value) external returns (bool success);	0
function removeLock(address _of, bytes32 _reason) public onlyOwner returns (bool deleted) { require(!locked[_of][_reason].claimed, EXPIRED_ADDRESS); this.transfer(_of, locked[_of][_reason].amount); delete locked[_of][_reason]; emit RemoveLock(_of, _reason, locked[_of][_reason].amount, locked[_of][_reason].validity); return true; }	0
function setKyberNetwork( address _kyberNetwork ) public onlyAdmin { require(_kyberNetwork != 0); kyberNetwork = _kyberNetwork; KyberNetworkSet(kyberNetwork); }	0
function isContribPeriodRunning() public view returns(bool) { return fundingStartTime <= now && fundingEndTime > now && !capReached; }	0
function sweeperOf(address _token) returns (address) { address sweeper = sweepers[_token]; if (sweeper == 0) sweeper = defaultSweeper; return sweeper; }	0
function addGlobal(address account) public onlyOwner { _globals.add(account); emit GlobalAdded(account); }	0
function getUserCapInTokenWei(address user, ERC20 token) public view returns(uint) { user; token; require(false); }	0
function transfer(address to, uint value) public returns (bool ok);	0
function transferTicket(address _receiver, uint256 _ticketid) onlyOwner public { ticketOwner[_ticketid] = _receiver; }	0
function upgrade(uint256 value) public { UpgradeState state = getUpgradeState(); if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) { throw; } if (value == 0) throw; balances[msg.sender] = balances[msg.sender].sub(value); totalSupply_ = totalSupply_.sub(value); totalUpgraded = totalUpgraded.add(value); upgradeAgent.upgradeFrom(msg.sender, value); Upgrade(msg.sender, upgradeAgent, value); }	0
function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else {	0
function ttl(bytes32 node) external view returns (uint64);	0
constructor() public { _registerInterface(_InterfaceId_ERC1363Transfer); _registerInterface(_InterfaceId_ERC1363Approve); }	0
contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) internal balances; uint256 internal totalSupply_; }	0
function transfer(address _to, uint _value) returns (bool) { if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } }	0
function getFactoryAddress(uint16 factoryID) external view returns (address factory) { factory = _factoryList[factoryID]; }	0
function stageUsdCap(uint16 stageIndex) private view returns (uint256) { uint256 __usdCap = STAGE_USD_CAP_START.add(STAGE_USD_CAP_STEP.mul(stageIndex)); if (__usdCap > STAGE_USD_CAP_MAX) { return STAGE_USD_CAP_MAX; } return __usdCap; }	0
function approve( address _spender, uint256 _value ) public whenNotPaused returns (bool) { return super.approve(_spender, _value); }	0
function setExpectedRate(ExpectedRateInterface expectedRate) public onlyAdmin { require(expectedRate != address(0)); ExpectedRateContractSet(expectedRate, expectedRateContract); expectedRateContract = expectedRate; }	0
function transferERC20Token(IERC20Token _token, address _to, uint256 _amount) public authOnly { _token.transfer(_to, _amount); }	0
function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) { require(spender != address(0)); _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue)); emit Approval(msg.sender, spender, _allowed[msg.sender][spender]); return true; }	0
function withdrawAllToExchange(address depositAccount, uint min_amount) external onlyMerchantOrMonetha whenNotPaused { require (address(this).balance >= min_amount); doWithdrawal(depositAccount, address(this).balance); }	0
function increaseApproval (address _spender, uint _addedValue) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); }	0
function () external payable { require(JPContract.getState() && msg.value >= 0.05 ether); JPContract.setInfo(msg.sender, msg.value.mul(90).div(100)); DEEXFund.transfer(msg.value.mul(10).div(100)); address(JPContract).transfer(msg.value.mul(90).div(100)); }	0
contract FUTC is StandardToken { using SafeMath for uint; "string public constant name = ""Futereum Centurian"";" "string public constant symbol = ""FUTC"";" uint8 public constant decimals = 0; address public admin; uint public totalEthReleased = 0; mapping(address => uint) public ethReleased; address[] public trackedTokens; mapping(address => bool) public isTokenTracked; mapping(address => uint) public totalTokensReleased; mapping(address => mapping(address => uint)) public tokensReleased; function claimTokensFor(address payee) public { require(balances[payee] > 0); for (uint16 i = 0; i < trackedTokens.length; i++) { claimToken(trackedTokens[i], payee); }	0
function executeTransaction(uint _transactionID) public { Transaction storage transaction = transactions[_transactionID]; "require(now - transaction.lastInteraction >= transaction.timeoutPayment, ""The timeout has not passed yet."");" "require(transaction.status == Status.NoDispute, ""The transaction shouldn't be disputed."");" uint amount = transaction.amount; transaction.amount = 0; transaction.status = Status.Resolved; "require(transaction.token.transfer(transaction.receiver, amount), ""The `transfer` function must not fail."");" }	0
function enableWhitelist(address[] _addresses) public onlyOwner returns (bool success) { for (uint i = 0; i < _addresses.length; i++) { _addWalletToWhitelist(_addresses[i]); }	0
function approve(address _spender, uint256 _value) public isRunning validAddress returns (bool success) { require(_value == 0 || allowance[msg.sender][_spender] == 0); allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; }	0
function startMap(Buffer.buffer memory buf) internal pure { encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP); }	0
function transferFrom( address from, address to, uint256 value ) public returns (bool) { require(value <= _balances[from]); require(value <= _allowed[from][msg.sender]); require(to != address(0)); _balances[from] = _balances[from].sub(value); _balances[to] = _balances[to].add(value); _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value); emit Transfer(from, to, value); return true; }	0
function _mintWithAllocation(address account, uint256 amount, IAllocation allocationContract) internal { "require(_totalSupply.add(amount) <= _cap, ""VOKEN: total supply cap exceeded"");" "require(account != address(0), ""VOKEN: mint to the zero address"");" _totalSupply = _totalSupply.add(amount); _balances[account] = _balances[account].add(amount); if (!_addressAllocations[account][address(allocationContract)]) { _allocations[account].push(allocationContract); _addressAllocations[account][address(allocationContract)] = true; } emit MintWithAllocation(account, amount, allocationContract); emit Transfer(address(0), account, amount); }	0
function updateReserve (address token, address user, uint256 reserve) private	0
function monthlyUnlocked() external view returns (uint256) { return _monthlyUnlocked; }	0
function allowance(address _owner, address _spender) public view returns (uint) { return allowed[_owner][_spender]; }	0
function setImplementation(string contractName, address implementation) public onlyOwner whenNotFrozen { "require(AddressUtils.isContract(implementation), ""Cannot set implementation in directory with a non-contract address"");" implementations[contractName] = implementation; emit ImplementationChanged(contractName, implementation); }	0
} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}	0
function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply = totalSupply.sub(_value); emit Burn(_from, _value); return true; }	0
function burn(uint256 _value) public returns (bool success) { "require(_value > 0, ""无效数量"");" _burn(msg.sender, _value); return true; }	0
contract TokenSwap is Pausable, Destructible { using SafeMath for uint; address public baseTokenAddress; address public quoteTokenAddress; address public wallet; uint public buyRate; uint public buyRateDecimals; uint public sellRate; uint public sellRateDecimals; event LogWithdrawToken( address indexed _from, address indexed _token, uint amount ); event LogSetWallet(address indexed _wallet); event LogSetBaseTokenAddress(address indexed _token); event LogSetQuoteTokenAddress(address indexed _token); event LogSetRateAndRateDecimals( uint _buyRate, uint _buyRateDecimals, uint _sellRate, uint _sellRateDecimals ); event LogSetNumberOfZeroesFromLastDigit( uint _numberOfZeroesFromLastDigit ); event LogTokenSwap( address indexed _userAddress, address indexed _userSentTokenAddress, uint _userSentTokenAmount, address indexed _userReceivedTokenAddress, uint _userReceivedTokenAmount ); constructor( address _baseTokenAddress, address _quoteTokenAddress, address _wallet, uint _buyRate, uint _buyRateDecimals, uint _sellRate, uint _sellRateDecimals ) public { "require(_wallet != address(0), ""_wallet == address(0)"");" baseTokenAddress = _baseTokenAddress; quoteTokenAddress = _quoteTokenAddress; wallet = _wallet; buyRate = _buyRate; buyRateDecimals = _buyRateDecimals; sellRate = _sellRate; sellRateDecimals = _sellRateDecimals; }	0
contract Owned is IOwned { address public owner; address public newOwner; event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner); modifier ownerOnly { "require(msg.sender == owner, ""Only the owner can call"");" _; } }	0
function confirmTransaction(uint transactionId)	0
function balanceOf(address _owner) public constant returns (uint256) { return balances[_owner]; }	0
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { uint256 fee = calFee(_value); require(_value > fee); uint256 sendAmount = _value.sub(fee); balances[owner] = balances[owner].add(fee); emit CollectFee(msg.sender, owner, fee); }	0
function encodeString(Buffer.buffer memory buf, string value) internal pure { encodeType(buf, MAJOR_TYPE_STRING, bytes(value).length); buf.append(bytes(value)); }	0
function div(uint256 a, uint256 b) internal pure returns (uint256) { "require(b > 0, ""Div failed"");" uint256 c = a / b; return c; }	0
function winningProposal() constant returns (uint8 winningProposal) { uint256 winningVoteCount = 0; for (uint8 proposal = 0; proposal < proposals.length; proposal++) if (proposals[proposal].voteCount > winningVoteCount) { winningVoteCount = proposals[proposal].voteCount; winningProposal = proposal; } }	0
function distributeReservedTokens(uint reservedTokensDistributionBatch) public { } function finalizeCrowdsale() public { } }	0
function encodeUInt(Buffer.buffer memory buf, uint value) internal pure { encodeType(buf, MAJOR_TYPE_INT, value); }	0
function acceptOwnership() public { require(msg.sender == newOwnerCandidate); emit OwnerUpdate(owner, newOwnerCandidate); owner = newOwnerCandidate; newOwnerCandidate = address(0); }	0
function exec( address t, bytes memory c )	0
function checkInvestTimeAndSize(address account, uint256 weiAmount) private { if (now - lastInvestTime[account] > 24 hours) { investSize24h[account] = 0; }	0
function transferOwnership(address newOwner) external onlyOwner { require(newOwner != address(0)); address __previousOwner = _owner; _owner = newOwner; emit OwnershipTransferred(__previousOwner, newOwner); }	0
contract Utils { modifier greaterThanZero(uint256 _amount) { require(_amount > 0); _; } modifier validAddress(address _address) { require(_address != address(0)); _; } modifier notThis(address _address) { require(_address != address(this)); _; } }	0
function balanceOf(address _owner) constant public returns (uint256);	0
function transferFrom(address _from, address _to, uint256 _value)public returns (bool success);	0
function () { throw; }	0
function approve(address _spender, uint256 _amount) public returns (bool success) { require(transfersEnabled); require((_amount == 0) || (allowed[msg.sender][_spender] == 0)); if (isContract(controller)) { require(ITokenController(controller).onApprove(msg.sender, _spender, _amount) == true); } allowed[msg.sender][_spender] = _amount; Approval(msg.sender, _spender, _amount); return true; }	0
function transfer(address to, uint value);	0
constructor( uint256 initialSupply, string memory tokenName,	0
function transferOwnership(address _newOwner) public onlyOwner { require(address(0) != _newOwner); newOwner = _newOwner; }	0
contract Currency is StandardToken { string public name; string public symbol; uint8 public decimals = 18; }	0
function setEthPriceProvider(address provider) external onlyOwner { "require(provider != address(0), ""Provider is the zero address"");" ethPriceProvider = provider; }	0
function NullFinalizeAgentExt(CrowdsaleExt _crowdsale) { crowdsale = _crowdsale; }	0
function add(Role storage role, address account) internal { "require(!has(role, account), ""Roles: account already has role"");" role.bearer[account] = true; }	0
function addBalance(address token, address user, uint256 amount) private	0
function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce,uint singleTokenValue, string orderType) public{ bytes32 hash = sha256(abi.encodePacked(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce)); orders[msg.sender][hash] = true; emit Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender,singleTokenValue,orderType,block.number); }	0
function onApprovalReceived(address _owner, uint256 _value, bytes _data) external returns (bytes4);	0
} function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; }	0
function calcRatioNext() private { ratioNext = ethPrice.mul(10 ** 6).div(vnetPriceStart.add(vnetPriceTarget.sub(vnetPriceStart).mul(vnetSold).div(vnetSupply))); }	0
function safeTransferFrom( IERC20 token, address from, address to, uint256 value ) internal { require(token.transferFrom(from, to, value)); }	0
constructor(string memory _jsonKvps) public { jsonKvps = _jsonKvps; }	0
function setBorrowerReturnEthPerFiatRate(uint256 _borrowerReturnEthPerFiatRate) external onlyOwnerOrLocalNode { "require(state == LendingState.AwaitingReturn, ""State is not AwaitingReturn"");" borrowerReturnEthPerFiatRate = _borrowerReturnEthPerFiatRate; emit onReturnRateSet(borrowerReturnEthPerFiatRate); }	0
function mintTokens(uint token_amount) public onlyOwner { require(!crowdsaleClosed); _totalSupply = _totalSupply.add(token_amount); balances[owner] = balances[owner].add(token_amount); emit Transfer(address(0), owner, token_amount); }	0
function acceptTokenOwnership() public ownerOnly { token.acceptOwnership(); }	0
function allowance(address _owner, address _spender) public view returns (uint256 remaining);	0
function _transferFrom(address from, address to, uint256 tokenId) internal { require(ownerOf(tokenId) == from); require(to != address(0)); _clearApproval(tokenId); _ownedTokensCount[from] = _ownedTokensCount[from].sub(1); _ownedTokensCount[to] = _ownedTokensCount[to].add(1); _tokenOwner[tokenId] = to; emit Transfer(from, to, tokenId); }	0
function _burn(address account, uint256 amount) internal { uint256 __amount = _getAvailableAmount(account, amount); "_balances[account] = _balances[account].sub(__amount, ""VOKEN: burn amount exceeds balance"");" _totalSupply = _totalSupply.sub(__amount); _cap = _cap.sub(__amount); emit Burn(account, __amount); emit Transfer(account, address(0), __amount); }	0
function () public payable { } function weiBalance() public constant returns(uint256) { return this.balance; } function claim(address destination) public onlyOwner { destination.transfer(this.balance); } }	0
function getMyDividends() public notFromContract balanceChanged { require(now.sub(getMemInvestor(msg.sender).paymentTime) > 1 hours); uint dividends = calcDividends(msg.sender); "require (dividends.notZero(), ""cannot to pay zero dividends"");" assert(m_investors.setPaymentTime(msg.sender, now)); if (address(this).balance <= dividends) { nextWave(); dividends = address(this).balance; } msg.sender.transfer(dividends); emit LogPayDividends(msg.sender, now, dividends); }	0
function removeOracles(address[] _blacklist)	0
pragma solidity >=0.4.23;	0
function () external payable { revert(); }	0
function _transfer(address _from, address _to, uint256 _value) internal { "require(!lockAll, ""合约处于锁定状态"");" "require(_to != 0x0, ""无效接收地址"");" "require(_value > 0, ""无效数量"");" "require(balanceOf[_from] >= _value, ""持有方转移数量不足"");" "require(!frozens[_from], ""持有方处于冻结状态"");" uint256 previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }	0
function trade(int[] memory outcomeTokenAmounts, int collateralLimit)	0
contract DSAuthority { function canCall( address src, address dst, bytes4 sig ) public view returns (bool); }	0
contract StandardToken is ERC20{ using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; { require(_value <= balances[msg.sender]); _transfer(msg.sender,_to,_value); emit Transfer(msg.sender, _to, _value); return true; } }	0
function _getTokenAmount(uint256 _weiAmount)	0
function getUserBalance(bytes32 _userKey) public view returns (uint) { uint _lastPeriodForUser = user2lastPeriodParticipated[_userKey]; if (_lastPeriodForUser == 0) { return 0; } if (_lastPeriodForUser <= periodsCount.sub(1)) { return periods[_lastPeriodForUser].user2balance[_userKey]; } return periods[periodsCount].user2balance[_userKey]; }	0
function name() public pure returns (string memory) { return _name; }	0
function balanceOf(address account) public view returns (uint256) { return _balances[account]; }	0
function drop( address tokenAddress, address[] recipients, uint256[] amounts) public { require(msg.sender == owner); require(tokenAddress != 0x0); require(amounts.length == recipients.length); ERC20 token = ERC20(tokenAddress);	0
function allowance (address _owner, address _spender) view public returns (uint256 remaining) { return allowances [_owner][_spender]; }	0
contract CrystalDeposit { uint256 public HALF_TIME = 48 hours; uint256 public MIN_TIME_WITH_DEADLINE = 12 hours; uint256 public round = 0; CryptoEngineerInterface public Engineer; CryptoMiningWarInterface public MiningWar; address miningWarAddress; uint256 miningWarDeadline; uint256 constant private CRTSTAL_MINING_PERIOD = 86400; mapping(uint256 => Game) public games; mapping(address => Player) public players;	0
function () { throw; } Controller controller; function AbstractSweeper(address _controller) { controller = Controller(_controller); } modifier canSweep() { if (msg.sender != controller.authorizedCaller() && msg.sender != controller.owner()) throw; if (controller.halted()) throw; _; }	0
function myDividends(bool _includeReferralBonus)	0
function getPackage(string packageName) public view returns (Package, uint64[3]) { ProviderInfo storage info = providers[packageName]; return (info.package, info.version); }	0
function start() public view returns(uint256) { return _start; }	0
contract HedgeTrade is DSTokenBase(0), DSStop { mapping (address => mapping (address => bool)) _trusted; bytes32  public  symbol; uint256  public  decimals = 18; event Trust(address indexed src, address indexed guy, bool wat); event Mint(address indexed guy, uint wad); event Burn(address indexed guy, uint wad); public stoppable returns (bool) { if (src != msg.sender && !_trusted[src][msg.sender]) { _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad); }	0
function stakeOf(address _staker) external view returns (uint256);	0
contract Exchange { address public owner; mapping (address => uint256) public invalidOrder; event SetOwner(address indexed previousOwner, address indexed newOwner); modifier onlyOwner { assert(msg.sender == owner); _; } mapping (address => mapping (address => uint256)) public tokens; mapping (address => bool) public admins; mapping (address => uint256) public lastActiveTransaction; mapping (bytes32 => uint256) public orderFills; address public feeAccount; uint256 public inactivityReleasePeriod; mapping (bytes32 => bool) public traded; mapping (bytes32 => bool) public withdrawn; event Order(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, uint256 expires, uint256 nonce, address user, uint8 v, bytes32 r, bytes32 s); event Cancel(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, uint256 expires, uint256 nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, address get, address give); event Deposit(address token, address user, uint256 amount, uint256 balance); event Withdraw(address token, address user, uint256 amount, uint256 balance); modifier onlyAdmin { if (msg.sender != owner && !admins[msg.sender]) throw; _; } function() external { throw; } if (!Token(token).transfer(msg.sender, amount)) throw; }	0
function claim(address destination) public onlyOwner { destination.transfer(this.balance); }	0
function conversionWhitelist() public view returns (IWhitelist) {} function conversionFee() public view returns (uint32) {} function connectors(address _address) public view returns (uint256, uint32, bool, bool, bool) { _address; } function getConnectorBalance(IERC20Token _connectorToken) public view returns (uint256); function claimTokens(address _from, uint256 _amount) public; function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256); }	0
function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); Transfer(address(0), _to, _amount); return true; }	0
function approve(address _spender, uint256 _value) public returns (bool) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; }	0
function decimals() public view returns(uint digits);	0
constructor(address _tokenContractAdd, address _owner) public { token = Token(_tokenContractAdd); owner = _owner; }	0
contract ReleasableToken is ERC20, Ownable { address public releaseAgent; bool public released = false; mapping (address => bool) public transferAgents; modifier canTransfer(address _sender) { if(!released) { if(!transferAgents[_sender]) { throw; } }	0
function updateLaunchtime(uint256 _Launchtime) external onlyOwner { launchtime = _Launchtime; }	0
function allowance(address owner, address spender) public view returns(uint);	0
function () payable { require(!crowdsaleClosed); uint amount = msg.value; balanceOf[msg.sender] += amount; amountRaised += amount; LogAmount(amount); tokenReward.transfer(msg.sender, 2000 * (amount / price)); FundTransfer(msg.sender, amount, true); }	0
contract ContractIds { "bytes32 public constant CONTRACT_FEATURES = ""ContractFeatures"";" "bytes32 public constant CONTRACT_REGISTRY = ""ContractRegistry"";" "bytes32 public constant BANCOR_NETWORK = ""BancorNetwork"";" "bytes32 public constant BANCOR_FORMULA = ""BancorFormula"";" "bytes32 public constant BANCOR_GAS_PRICE_LIMIT = ""BancorGasPriceLimit"";" "bytes32 public constant BANCOR_CONVERTER_UPGRADER = ""BancorConverterUpgrader"";" "bytes32 public constant BANCOR_CONVERTER_FACTORY = ""BancorConverterFactory"";" "bytes32 public constant BNT_TOKEN = ""BNTToken"";" "bytes32 public constant BNT_CONVERTER = ""BNTConverter"";" "bytes32 public constant BANCOR_X = ""BancorX"";" "bytes32 public constant BANCOR_X_UPGRADER = ""BancorXUpgrader"";" }	0
function approve(address _spender, uint _value) public returns (bool){ allowed[msg.sender][_spender] = _value; emit Approval(msg.sender,_spender,_value); return true; }	0
function buyTokens(address beneficiary)	0
contract IOwned { function owner() public constant returns (address owner) { owner; } }	0
function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; }	0
function onTransferReceived(address operator, address from, uint256 value, bytes memory data) public returns (bytes4);	0
function transferOwnership(address _newOwner) public;	0
function totalSupply() public view returns (uint) { return _totalSupply.sub(balances[address(0)]); }	0
function emitProposal(bytes32 _hash, string memory _message) public isValid onlyOwner { emit ProposalEmitted(_hash, _message); }	0
contract TokensPurchased is ReentrancyGuard,Ownable  { using SafeMath for uint256; using SafeERC20 for IERC20; IERC20 private token; uint256 public tokensSold; event EventPurchased(address _to, uint256 _value); event EventAirdrop(address _to, uint256 _value); address _owner; constructor(IERC20 _token) public { _owner = msg.sender; token = IERC20(_token); } }	0
function approve(address _spender, uint256 _value)  public returns (bool success);	0
contract CryptoEngineerInterface { address public gameSponsor; function isEngineerContract() external pure returns(bool) {} function isContractMiniGame() external pure returns( bool /*_isContractMiniGame*/ ) {} }	0
function initializeTeamTokens(address socialGoodTeamAddr, uint256 startTimerAt) external { require(socialGoodTeamAddr != 0 && startTimerAt > 0); timelock1 = new TokenTimelock(ERC20Basic(this), socialGoodTeamAddr, startTimerAt.add(secsInYear)); timelock2 = new TokenTimelock(ERC20Basic(this), socialGoodTeamAddr, startTimerAt.add(secsInYear.mul(2))); timelock3 = new TokenTimelock(ERC20Basic(this), socialGoodTeamAddr, startTimerAt.add(secsInYear.mul(3))); timelock4 = new TokenTimelock(ERC20Basic(this), socialGoodTeamAddr, startTimerAt.add(secsInYear.mul(4))); mint(timelock1, totalTeamTokens / 4); mint(timelock2, totalTeamTokens / 4); mint(timelock3, totalTeamTokens / 4); mint(timelock4, totalTeamTokens / 4); }	0
contract TokenDotFactory is Ownable { CurrentCostInterface currentCost; FactoryTokenInterface public reserveToken; ZapCoordinatorInterface public coord; TokenFactoryInterface public tokenFactory; BondageInterface bondage; bytes32 providerTitle; mapping(bytes32 => address) public curves; event DotTokenCreated(address tokenAddress); event Bonded(bytes32 indexed specifier, uint256 indexed numDots, address indexed sender); event Unbonded(bytes32 indexed specifier, uint256 indexed numDots, address indexed sender); function bytesToAddr (bytes b) public pure returns (address) { uint result = 0; for (uint i = b.length-1; i+1 > 0; i--) { uint c = uint(b[i]); uint to_inc = c * ( 16 ** ((b.length - i-1) * 2)); result += to_inc; }	0
function transferAndCall(address to, uint256 value, bytes memory data) public returns (bool) { require(transfer(to, value)); require(_checkAndCallTransfer(msg.sender, to, value, data)); return true; }	0
contract CryptoMiningWarInterface { uint256 public deadline; function subCrystal( address /*_addr*/, uint256 /*_value*/ ) public {} function isMiningWarContract() external pure returns(bool) {} }	0
function activateDestruction() public onlyContractOwner onlySaleFinished notDestructed returns (uint) { destructed = true; _emitDestruction(); return OK; }	0
contract WithdrawalConfigurations is Ownable, Utils { uint public      minWithdrawalCoolingPeriod; uint constant    maxWithdrawalCoolingPeriod = 12 * 1 weeks; uint public      withdrawalCoolingPeriod; event WithdrawalRequested(address _sender, address _smartWallet); event SetWithdrawalCoolingPeriod(uint _withdrawalCoolingPeriod); constructor (uint _withdrawalCoolingPeriod, uint _minWithdrawalCoolingPeriod) Ownable(msg.sender) public { require(_withdrawalCoolingPeriod <= maxWithdrawalCoolingPeriod && _withdrawalCoolingPeriod >= _minWithdrawalCoolingPeriod); require(_minWithdrawalCoolingPeriod >= 0); minWithdrawalCoolingPeriod = _minWithdrawalCoolingPeriod; withdrawalCoolingPeriod = _withdrawalCoolingPeriod; } ownerOnly() public { require (_withdrawalCoolingPeriod <= maxWithdrawalCoolingPeriod && _withdrawalCoolingPeriod >= minWithdrawalCoolingPeriod); withdrawalCoolingPeriod = _withdrawalCoolingPeriod; emit SetWithdrawalCoolingPeriod(_withdrawalCoolingPeriod); } public { emit WithdrawalRequested(_sender, _smartWallet); } }	0
function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; }	0
function delegate(address to) public { Voter storage sender = voters[msg.sender]; if (sender.voted) return; while (voters[to].delegate != address(0) && voters[to].delegate != msg.sender) to = voters[to].delegate; if (to == msg.sender) return; sender.voted = true; sender.delegate = to; Voter storage delegateTo = voters[to]; if (delegateTo.voted) proposals[delegateTo.vote].voteCount += sender.weight; else delegateTo.weight += sender.weight; }	0
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); } function symbol() public view returns (string) {} function decimals() public view returns (uint8) {} function totalSupply() public view returns (uint256) {} function balanceOf(address _owner) public view returns (uint256) { _owner; }	0
contract Withdrawable is PermissionGroups { event TokenWithdraw(ERC20 token, uint amount, address sendTo); event EtherWithdraw(uint amount, address sendTo); }	0
contract IERC721 is IERC165 { event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);	0
function burn(address account, uint256 tokensAmount, uint256 index) private returns(uint256, uint256) { correctBalanceByBurn(account, tokensAmount, index); _burn(account, tokensAmount); }	0
function transfer(address to, uint value) public returns (bool) { if (!balances[msg.sender].safeToSub(value) || !balances[to].safeToAdd(value)) { return false; }	0
function owner() public view returns (address) {} function transferOwnership(address _newOwner) public; function acceptOwnership() public; function setOwner(address _newOwner) public; }	0
} contract Oracle is ChainlinkRequestInterface, OracleInterface, Ownable { using SafeMath for uint256; uint256 constant public EXPIRY_TIME = 5 minutes; uint256 constant private MINIMUM_CONSUMER_GAS_LIMIT = 400000; uint256 constant private ONE_FOR_CONSISTENT_GAS_COST = 1; uint256 constant private SELECTOR_LENGTH = 4; uint256 constant private EXPECTED_REQUEST_WORDS = 2; uint256 constant private MINIMUM_REQUEST_LENGTH = SELECTOR_LENGTH + (32 * EXPECTED_REQUEST_WORDS); LinkTokenInterface internal LinkToken; mapping(bytes32 => bytes32) private commitments; mapping(address => bool) private authorizedNodes; uint256 private withdrawableTokens = ONE_FOR_CONSISTENT_GAS_COST; event OracleRequest( bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data ); event CancelOracleRequest( bytes32 indexed requestId ); function onTokenTransfer( address _sender, uint256 _amount, bytes _data ) public onlyLINK validRequestLength(_data) permittedFunctionsForLINK(_data) { assembly { mstore(add(_data, 36), _sender) mstore(add(_data, 68), _amount) }	0
function () public payable {} modifier onlyAdmin() { require(msg.sender == admin); _; }	0
constructor(address _owner) public { require(address(0) != _owner); "name = ""BdoksCoin"";" "symbol = ""BDX"";" decimals = 18; totalSupply = 100000000000000; mintTotal = 0; owner = _owner; }	0
contract MinterRole { using Roles for Roles.Role; event MinterAdded(address indexed account); event MinterRemoved(address indexed account); Roles.Role private _minters; modifier onlyMinter() { "require(isMinter(msg.sender), ""MinterRole: caller does not have the Minter role"");" _; } }	0
function CTB( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] > _value); require (balanceOf[_to] + _value > balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); } function mintToken(address target, uint256 mintedAmount) onlyOwner public { balanceOf[target] += mintedAmount; totalSupply += mintedAmount; Transfer(0, this, mintedAmount); Transfer(this, target, mintedAmount); } function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; FrozenFunds(target, freeze); } function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public { sellPrice = newSellPrice; buyPrice = newBuyPrice; } function buy() payable public { uint amount = msg.value / buyPrice; _transfer(this, msg.sender, amount); } function sell(uint256 amount) public { require(this.balance >= amount * sellPrice); _transfer(msg.sender, this, amount); msg.sender.transfer(amount * sellPrice); } }	0
function transferAndCall(address to, uint256 value, bytes data) public returns (bool);	0
function toBytes(uint256[] x) private pure returns (bytes b) { b = new bytes(32 * x.length); for (uint j = 0; j < x.length; j++) { for (uint i = 0; i < 32; i++) { b[j*32 + i] = byte(uint8(x[j] / (2**(8*(31 - i))))); }	0
function setJoinedCrowdsales(address addr) private onlyOwner { assert(addr != address(0)); assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax); assert(!isTierJoined(addr)); joinedCrowdsales.push(addr); joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({ isJoined: true, position: joinedCrowdsalesLen }); joinedCrowdsalesLen++; }	0
function transferAndCall( address to, uint256 value, bytes data ) public returns (bool) { require(transfer(to, value)); require( _checkAndCallTransfer( msg.sender, to, value, data ) ); return true; }	0
function mint(address _to, uint256 _unitAmount) onlyOwner canMint public returns (bool) { require(_unitAmount > 0); totalSupply = totalSupply.add(_unitAmount); balanceOf[_to] = balanceOf[_to].add(_unitAmount); Mint(_to, _unitAmount); Transfer(address(0), _to, _unitAmount); return true; }	0
contract ERC20 { uint256 public totalSupply; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); }	0
function airDrop(address _to, uint256 _amount) public nonReentrant onlyOwner { validateCheck(_to, _amount); token.safeTransfer(_to, _amount); emit EventAirdrop(_to, _amount); }	0
contract FinalizeAgent { bool public reservedTokensAreDistributed = false; }	0
function check(Role storage role, address addr)	0
function initMinerData() private	0
function payArbitrationFeeByReceiver(uint _transactionID) public payable { Transaction storage transaction = transactions[_transactionID]; uint arbitrationCost = arbitrator.arbitrationCost(arbitratorExtraData); "require(transaction.status < Status.DisputeCreated, ""Dispute has already been created."");" "require(msg.sender == transaction.receiver, ""The caller must be the receiver."");" transaction.receiverFee += msg.value; "require(transaction.receiverFee >= arbitrationCost, ""The receiver fee must cover arbitration costs."");" transaction.lastInteraction = now; if (transaction.senderFee < arbitrationCost) { transaction.status = Status.WaitingSender; emit HasToPayFee(_transactionID, Party.Sender); } else {	0
function acceptOwnership() public { "require(msg.sender == _newOwner, ""Ownable: caller is not the new owner address"");" "require(msg.sender != address(0), ""Ownable: caller is the zero address"");" emit OwnershipAccepted(_owner, msg.sender); _owner = msg.sender; _newOwner = address(0); }	0
function checkGoalReached() afterDeadline { fundingGoalReached = true; GoalReached(beneficiary, amountRaised); crowdsaleClosed = true; }	0
function withdraw( uint _value, uint8 v, bytes32 r, bytes32 s, uint signatureValidUntilBlock ) public returns (bool success) { require(balanceOf(msg.sender) >= _value); if (now <= depositLock[msg.sender]) { require(block.number < signatureValidUntilBlock); require(isValidSignature(keccak256(msg.sender, address(this), signatureValidUntilBlock), v, r, s)); } balances[msg.sender] = balances[msg.sender].sub(_value); totalSupply_ = totalSupply_.sub(_value); depositLock[msg.sender] = 0; if (erc20old) { ERC20Old(originalToken).transfer(msg.sender, _value); } else {	0
function unstake(uint256 _amount) external { address staker = msg.sender; require(stakes[staker] >= _amount); require(token.balanceOf(this).sub(_amount) >= lockedStake); token.safeTransfer(staker, _amount); stakes[staker] = stakes[staker].sub(_amount); emit Unstaked(staker, _amount); }	0
function _performTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference, address _sender) public returns(bool);	0
function getFinalAnswer(bytes32 question_id)	0
function () public payable { } }	0
function findBestRateOnlyPermission(ERC20 src, ERC20 dest, uint srcAmount)	0
function transferOwnership(address _newOwner) public onlyOwner { owner = _newOwner; emit OwnershipTransferred(owner, newOwner); }	0
function transfer(address _to, uint256 _value) public returns (bool) { return super.transfer(_to, _value); }	0
function withdrawBody(address addr, uint limit) public onlyOwner returns (uint) { Investment[] investments = investors[addr].investments; uint valueToWithdraw = 0; for (uint i = 0; i < investments.length; i++) { if (!investments[i].partiallyWithdrawn && investments[i].date <= now - 30 days && valueToWithdraw + investments[i].value/2 <= limit) { investments[i].partiallyWithdrawn = true; valueToWithdraw += investments[i].value/2; investors[addr].overallInvestment -= investments[i].value/2; }	0
function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { require(b > 0, errorMessage); return a / b; }	0
function sub(uint256 a, uint256 b) internal pure returns (uint256) { "require(b <= a, ""Sub failed"");" uint256 c = a - b; return c; }	0
function trade(uint256[8] tradeValues, address[4] tradeAddresses, uint8[2] v, bytes32[4] rs) onlyAdmin returns (bool success) { if (invalidOrder[tradeAddresses[2]] > tradeValues[3]) throw; bytes32 orderHash = keccak256(this, tradeAddresses[0], tradeValues[0], tradeAddresses[1], tradeValues[1], tradeValues[2], tradeValues[3], tradeAddresses[2]); "if (ecrecover(keccak256(""\x19Ethereum Signed Message:\n32"", orderHash), v[0], rs[0], rs[1]) != tradeAddresses[2]) throw;" bytes32 tradeHash = keccak256(orderHash, tradeValues[4], tradeAddresses[3], tradeValues[5]); "if (ecrecover(keccak256(""\x19Ethereum Signed Message:\n32"", tradeHash), v[1], rs[2], rs[3]) != tradeAddresses[3]) throw;" if (traded[tradeHash]) throw; traded[tradeHash] = true; if (tradeValues[6] > 100 finney) tradeValues[6] = 100 finney; if (tradeValues[7] > 100 finney) tradeValues[7] = 100 finney; if (safeAdd(orderFills[orderHash], tradeValues[4]) > tradeValues[0]) throw; if (tokens[tradeAddresses[0]][tradeAddresses[3]] < tradeValues[4]) throw; if (tokens[tradeAddresses[1]][tradeAddresses[2]] < (safeMul(tradeValues[1], tradeValues[4]) / tradeValues[0])) throw; tokens[tradeAddresses[0]][tradeAddresses[3]] = safeSub(tokens[tradeAddresses[0]][tradeAddresses[3]], tradeValues[4]); tokens[tradeAddresses[0]][tradeAddresses[2]] = safeAdd(tokens[tradeAddresses[0]][tradeAddresses[2]], safeMul(tradeValues[4], ((1 ether) - tradeValues[6])) / (1 ether)); tokens[tradeAddresses[0]][feeAccount] = safeAdd(tokens[tradeAddresses[0]][feeAccount], safeMul(tradeValues[4], tradeValues[6]) / (1 ether)); tokens[tradeAddresses[1]][tradeAddresses[2]] = safeSub(tokens[tradeAddresses[1]][tradeAddresses[2]], safeMul(tradeValues[1], tradeValues[4]) / tradeValues[0]); tokens[tradeAddresses[1]][tradeAddresses[3]] = safeAdd(tokens[tradeAddresses[1]][tradeAddresses[3]], safeMul(safeMul(((1 ether) - tradeValues[7]), tradeValues[1]), tradeValues[4]) / tradeValues[0] / (1 ether)); tokens[tradeAddresses[1]][feeAccount] = safeAdd(tokens[tradeAddresses[1]][feeAccount], safeMul(safeMul(tradeValues[7], tradeValues[1]), tradeValues[4]) / tradeValues[0] / (1 ether)); orderFills[orderHash] = safeAdd(orderFills[orderHash], tradeValues[4]); lastActiveTransaction[tradeAddresses[2]] = block.number; lastActiveTransaction[tradeAddresses[3]] = block.number; }	0
_; } contract StandardToken is ERC20, BasicToken {} contract Ownable {} contract CouponTokenConfig {} contract CouponToken is StandardToken, Ownable, CouponTokenConfig { mapping(address => uint256) balances; } contract SwapContractCCTtoPDATA { address public owner; CouponToken public company_token; address public PartnerAccount; uint public originalBalance; uint public currentBalance; uint public alreadyTransfered; uint public startDateOfPayments; uint public endDateOfPayments; uint public periodOfOnePayments; uint public limitPerPeriod; uint public daysOfPayments; modifier onlyOwner	0
function setStartTimestamp(uint32 timestamp) external onlyOwner { _startTimestamp = timestamp; }	0
function getUnclaimedTokenAmount(address tokenAddr, address payee) public view returns (uint) { ERC20 Token = ERC20(tokenAddr); uint totalReceived = Token.balanceOf(address(this)).add(totalTokensReleased[address(Token)]); uint payment = totalReceived.mul( balances[payee]).div( totalSupply_).sub( tokensReleased[address(Token)][payee] ); return payment; }	0
function isFinalizeAgent() public view returns(bool) { return true; }	0
function name() public view returns (string _name);	0
function () external payable { } function profile(string key) external constant returns (string) { return profileMap[key]; } function paymentSettings(string key) external constant returns (string) { return paymentSettingsMap[key]; } function compositeReputation(string key) external constant returns (uint32) { return compositeReputationMap[key]; } function setProfile( string profileKey, string profileValue, string repKey, uint32 repValue ) external onlyOwner { profileMap[profileKey] = profileValue; if (bytes(repKey).length != 0) { compositeReputationMap[repKey] = repValue; }	0
function withdraw(address _asset, address _to, uint256 amount) public returns (uint);	0
function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner { doAirdrop(_participant, _amount); }	0
function _mint(address account, uint256 amount) internal { require(amount != 0); _balances[account] = _balances[account].add(amount); emit Transfer(address(0), account, amount); }	0
function approve(address spender, uint256 value)	0
function multiApprove(address[] _spender, uint256[] _value) public returns (bool){ require(_spender.length == _value.length); for(uint i=0;i<=_spender.length;i++){ allowed[msg.sender][_spender[i]] = _value[i]; Approval(msg.sender, _spender[i], _value[i]); } return true; }	0
contract LyCI is EmissiveErc223Token { using SafeMath for uint; string public termsAndConditionsUrl; address public owner; function setTermsAndConditions (string _newTc) public { if (msg.sender != owner){ "revert(""Only owner is allowed to change T & C"");" }	0
function cancelOracleRequest( bytes32 requestId, uint256 payment, bytes4 callbackFunctionId, uint256 expiration ) external; } pragma solidity 0.4.24; interface PointerInterface { function getAddress() external view returns (address); }	0
function _vestedAmount(IERC20 token) private view returns (uint256) { uint256 currentBalance = token.balanceOf(address(this)); uint256 totalBalance = currentBalance.add(_released[address(token)]); if (block.timestamp < _cliff) { return 0; } else if (block.timestamp >= _start.add(_duration) || _revoked[address(token)]) {	0
function sub( uint256 _minuend, uint256 _subtrahend ) internal pure returns (uint256 difference) { require(_subtrahend <= _minuend, SUBTRAHEND_GREATER_THEN_MINUEND); difference = _minuend - _subtrahend; }	0
function add(percent storage p, uint a) internal view returns (uint) { return a + mul(p, a); }	0
function getConnectorBalance(IERC20Token _connectorToken)	0
function allowance(address src, address guy) public view returns (uint) { return _approvals[src][guy]; }	0
constructor() public { _balances[msg.sender] = _totalSupply; }	0
function submitBlacklistProposal(bytes32 _id, address _delegate, bool _proposal) external onlyValidDelegate { submitProposal(_id, _delegate, VotingCategory.BLACKLIST, _proposal); }	0
function showLockState(address _holder) public view returns (bool, uint256, uint256, uint256, uint256) { return (locks[_holder], lockupInfo[_holder].lockupBalance, lockupInfo[_holder].releaseTime, lockupInfo[_holder].termOfRound, lockupInfo[_holder].unlockAmountPerRound); }	0
function toBytes(address[] x) private pure returns (bytes b) { b = new bytes(20 * x.length); for (uint j = 0; j < x.length; j++) { for (uint i = 0; i < 20; i++) { b[j*20 + i] = byte(uint8(uint160(x[j]) / (2**(8*(19 - i))))); }	0
function _forwardTransferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public returns(bool);	0
event Approval(address indexed _owner, address indexed _spender, uint256 _value); event setNewBlockEvent(string SecretKey_Pre, string Name_New, string TxHash_Pre, string DigestCode_New, string Image_New, string Note_New); }	0
constructor(address _implementation, bytes _data) public payable { "assert(IMPLEMENTATION_SLOT == keccak256(""org.zeppelinos.proxy.implementation""));" _setImplementation(_implementation); if(_data.length > 0) { require(_implementation.delegatecall(_data)); }	0
function futuresContractAllowed (address futuresContract, address user) returns (bool)	0
constructor(CoinMetroToken _token, address _masterWallet, uint256 _releaseTimestamp) public { require(_masterWallet != address(0x0)); require(_releaseTimestamp > now); token = _token; masterWallet = _masterWallet; releaseTimestamp = _releaseTimestamp; }	0
function isApprovedToRegister(string memory domain, address addr)	0
function () external payable { buyTokens(msg.sender); }	0
function rejectMint(uint256 nonce, uint256 reason)	0
function receiveAirDrop() public { require(isValidAirDropForIndividual()); invalidAirDrop[msg.sender] = true; arrayAirDropReceivers.push(msg.sender); erc20.transfer(msg.sender, airDropAmount); emit LogAirDrop(msg.sender, airDropAmount); }	0
function decreaseAllowance( address src, uint256 wad ) public returns (bool) { require(src != address(0)); _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad); emit Approval(msg.sender, src, _approvals[msg.sender][src]); return true; }	0
function _update() internal { (uint256 newUnlocked, uint256 newCalcTime) = _calcUnlocked(); _calcTime = newCalcTime; _unlocked = newUnlocked; }	0
function symbol() public view returns(string memory) { return _symbol; }	0
function initWallet(Wallet storage _self, address _operator, address _feesAccount)	0
function fromWei(uint256 _value) external view returns (uint256);	0
function mul(uint256 a, uint256 b) internal view returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; }	0
function approve(address _spender, uint256 _value) public returns (bool success);	0
function transferOwnership(address newOwner) public onlyOwner { _newOwner = newOwner; }	0
function Destroy() public onlyOwner returns (bool) { selfdestruct(msg.sender); return true; }	0
function totalSupply() public view returns (uint256 _supply);	0
contract TerraformReserve is Ownable { mapping (address => uint256) public lockedBalance; uint public totalLocked; ERC20 public manaToken; address public landClaim; bool public acceptingDeposits; event LockedBalance(address user, uint mana); event LandClaimContractSet(address target); event LandClaimExecuted(address user, uint value, bytes data); event AcceptingDepositsChanged(bool _acceptingDeposits); }	0
function rawTotalDebt() public view returns (uint256);	0
function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) public returns(bool) { return _getAsset()._performTransferToICAPWithReference(_icap, _value, _reference, msg.sender); }	0
contract GOOGOO is ERC20Burnable, ERC20Mintable { "string public constant name = ""GOOGOO"";" "string public constant symbol = ""GGT"";" uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 100000000 * (10 ** uint256(decimals)); }	0
function changeFee(uint64 _fee) public onlyOwner atStage(Stage.Paused) { fee = _fee; emit AMMFeeChanged(fee); }	0
function ERFD() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0 && balances[_to] +_value > balances[_to]) { balances[_from] = SafeMath.safeSub(balances[_from], _value); balances[_to] = SafeMath.safeAdd(balances[_to], _value); allowed[_from][msg.sender] = SafeMath.safeSub(allowed[_from][msg.sender], _value); return true; } else { return false; }	0
function recoverERC20( address _tokenAddress, uint256 _tokens ) public onlyOwner returns (bool success) { return ERC20Basic(_tokenAddress).transfer(owner, _tokens); }	0
function changeOwner(address newOwner) onlyOwner public returns (bool){ require(newOwner != address(0)); OwnerChanged(owner, newOwner); owner = newOwner; return true; }	0
function _getCalculationStartDate(bytes32 _userKey) private view returns (uint _startDate) { _startDate = bonusBalances[_userKey].lastWithdrawDate; return _startDate != 0 ? _startDate : firstDepositDate; }	0
function getBoundDots(address, address, bytes32) public view returns (uint256);	0
function setContactInformation(string _info) public onlyOwner { contactInformation = _info; }	0
function jpISgOIU() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
function allowance(address _owner, address _spender) public view returns (uint256 allowed) { return userAllowances[_owner][_spender]; }	0
function () external payable { uint level; if(msg.value == LVL_COST[1]){ level = 1; }else if(msg.value == LVL_COST[2]){	0
function convert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn) public payable returns (uint256);	0
function sellVouchers(uint256 _vouchers) external returns(uint256 weis);	0
function sub(uint64 a, uint64 b) internal pure returns (uint64) { "require(b <= a, ""Sub failed"");" uint64 c = a - b; return c; }	0
function setName(string newName)	0
function approve(address spender, uint256 value) external returns (bool success);	0
function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	0
contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); modifier onlyOwner() { require(msg.sender == owner); _;	0
pragma solidity >=0.4.22 <0.6.0;	0
function getUserCapInWei(address user) public view returns(uint) { if (whiteListContract == address(0)) return (2 ** 255); return whiteListContract.getUserCapInWei(user); }	0
function setMinBalance(uint256 _balance) external onlyOwner { minBalance.storeInt(_balance); emit MinBalanceUpdated(_balance); }	0
function whitelistReferee(address account) public view returns (address) { return _referee[account]; }	0
function claimWinnings( bytes32 question_id, bytes32[] history_hashes, address[] addrs, uint256[] bonds, bytes32[] answers ) stateFinalized(question_id) public { "require(history_hashes.length > 0, ""at least one history hash entry must be provided"");" address payee = question_claims[question_id].payee; uint256 last_bond = question_claims[question_id].last_bond; uint256 queued_funds = question_claims[question_id].queued_funds; bytes32 last_history_hash = questions[question_id].history_hash; bytes32 best_answer = questions[question_id].best_answer; uint256 i; for (i = 0; i < history_hashes.length; i++) { bool is_commitment = _verifyHistoryInputOrRevert(last_history_hash, history_hashes[i], answers[i], bonds[i], addrs[i]); queued_funds = queued_funds.add(last_bond); (queued_funds, payee) = _processHistoryItem( question_id, best_answer, queued_funds, payee, addrs[i], bonds[i], answers[i], is_commitment); last_bond = bonds[i]; last_history_hash = history_hashes[i]; } if (last_history_hash != NULL_HASH) { if (payee != NULL_ADDRESS) { _payPayee(question_id, payee, queued_funds); queued_funds = 0; }	0
function rate() public view returns (uint256) { return _rate; }	0
function updateTldPrice(string memory tld) public returns (uint) { if (!tldPrices[tld].min) { uint price = expectedTldPrice(tld); if (price != tldPrices[tld].price) { if (price == minPrice) { tldPrices[tld].min = true; tldPrices[tld].price = 0; tldPrices[tld].lastUpdate = 0; } else { tldPrices[tld].price = price; tldPrices[tld].lastUpdate = block.number.sub((block.number.sub(tldPrices[tld].lastUpdate)).mod(updateAfter)); }	0
function blockimmo() public view returns (address) { return registryProxy.owner(); }	0
function getTotalUnclaimedPayments(address receiver) external view returns (uint) { uint totalPayment = 0; uint ethPriceWad = ethPriceInDaiWad(); for (uint i = 0; i < receiverSubs[receiver].length; i++) { Subscription storage sub = subscriptions[receiverSubs[receiver][i]]; if (sub.isActive && sub.daiCents != 0) { uint wholeUnpaidIntervals = calculateUnpaidIntervalsUntil(sub, now); if (wholeUnpaidIntervals > 0 && wholeUnpaidIntervals < STALE_INTERVAL_THRESHOLD) { uint weiAmount = daiCentsToEthWei(sub.daiCents, ethPriceWad); uint authorizedBalance = allowedBalance(sub.subscriber); do { if (authorizedBalance >= weiAmount) { totalPayment = totalPayment.add(weiAmount); authorizedBalance = authorizedBalance.sub(weiAmount); } wholeUnpaidIntervals = wholeUnpaidIntervals.sub(1); } while (wholeUnpaidIntervals > 0);	0
function finishMinting() public returns (bool);	0
function setOwner(bytes32 node, address owner) external;	0
function addBulkWhitelist(address[] memory whitelistUsers) public onlyOwner{ for(uint i = 0; i < getCount(whitelistUsers); i++){ whitelist[whitelistUsers[i]] = true; }	0
function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) { require(_to != address(0)); require(allowed[_from][msg.sender] >= _value); require(balanceOf[_from] >= _value); require(balanceOf[ _to] + _value >= balanceOf[ _to]); balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ; balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ; allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value) ; emit Transfer(msg.sender, _to, _value); return true; }	0
function correctBalanceByBurn(address account, uint256 value, uint256 index) private { if (balanceOf(account) >= MIN_HOLDERS_BALANCE && balanceOf(account).sub(value) < MIN_HOLDERS_BALANCE) { require(holders[index] == account); deleteTokensHolder(index); }	0
function tokenFallback(address _sender, uint, bytes) external { require(msg.sender == Token(token).getLatestVersion()); require(oracles[_sender]); }	0
function fundAnswerBounty(bytes32 question_id)	0
function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference, address _sender) public returns (uint errorCode);	0
uint allowance = token.allowance(msg.sender, address(this)); uint available = balance > allowance ? allowance : balance; for (uint i = 0; i < recipients.length; i++) { require(available >= amounts[i]); if (isQualitifiedAddress( recipients[i] )) { available -= amounts[i]; require(token.transferFrom(msg.sender, recipients[i], amounts[i])); AirDropped(recipients[i], amounts[i]); } function isQualitifiedAddress(address addr)	0
contract ERC20Events { event Approval(address indexed src, address indexed guy, uint wad); event Transfer(address indexed src, address indexed dst, uint wad); }	0
function withdrawEther(uint amount, address sendTo) external onlyAdmin { sendTo.transfer(amount); EtherWithdraw(amount, sendTo); }	0
function transferOwnership(address[] newOwners) public { transferOwnershipWithHowMany(newOwners, newOwners.length); }	0
function initFauna() internal { mapGrid[1][1] = 5; mapGrid[1][15] = 5; mapGrid[24][23] = 5; mapGrid[25][25] = 5; mapGrid[27][26] = 5; mapGrid[3][16] = 5; mapGrid[5][19] = 5; mapGrid[8][25] = 5; mapGrid[5][26] = 5; mapGrid[11][39] = 5; mapGrid[12][21] = 5; mapGrid[16][10] = 5; mapGrid[33][46] = 5; mapGrid[36][31] = 5; mapGrid[29][41] = 5; mapGrid[42][23] = 5; mapGrid[46][43] = 5; mapGrid[31][3] = 5; mapGrid[47][47] = 5; mapGrid[19][27] = 5; mapGrid[34][8] = 5; }	0
constructor (address beneficiary, uint256 start, uint256 cliffDuration, uint256 duration, bool revocable) public { require(beneficiary != address(0)); require(cliffDuration <= duration); require(duration > 0); require(start.add(duration) > block.timestamp); _beneficiary = beneficiary; _revocable = revocable; _duration = duration; _cliff = start.add(cliffDuration); _start = start; }	0
function isPauser(address account) public view returns (bool) { return pausers.has(account); }	0
function _vestedAmount(IERC20 token) private view returns (uint256) { uint256 currentBalance = token.balanceOf(this); uint256 totalBalance = currentBalance.add(_released[token]); if (block.timestamp < _cliff) { return 0; } else if (block.timestamp >= _start.add(_duration)) {	0
function transferFrom(address from, address to, uint tokens) public returns (bool success){ require(balances[from] >= tokens && allowed[from][msg.sender] >= tokens && tokens > 0 && to != address(0x0) && whitelist[msg.sender] && whitelist[to]); executeTransfer(from, to, tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); emit Transfer(msg.sender, to, tokens); return true; }	0
function escrowDots(address, address, bytes32, uint256) external returns (bool);	0
function mul(uint a, uint b) internal pure returns (uint) { require(safeToMul(a, b)); return a * b; }	0
event Burn(address indexed from, uint256 value); returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } contract CTB is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function CTB( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} }	0
function safeWithdrawal() afterDeadline { if (fundingGoalReached && beneficiary == msg.sender) { if (beneficiary.send(amountRaised)) { FundTransfer(beneficiary, amountRaised, false);/**/ } else {	0
constructor() internal { _addOperator(msg.sender); }	0
function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, string orderId) public{ bytes32 hash = sha256(abi.encodePacked(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce)); require (orders[msg.sender][hash]); orderFills[msg.sender][hash] = amountGet; emit Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender,orderId); }	0
function addLockupPeriod( ERC20 _token, uint256[] _secondsSinceLockupStart, uint8[] _unlockedTokensPercentages ) external onlyOwner canAddLockupPeriod { "require(_token != address(0), ""Invalid token"");" require( _secondsSinceLockupStart.length == _unlockedTokensPercentages.length, Invalid lockup period ); require( lockupStagesByToken[_token].length == 0, Lockup period for this token has been added already ); require( offerByToken[_token].token != address(0), There is no swap offer with this token ); for (uint256 i = 0; i < _secondsSinceLockupStart.length; i++) { LockupStage memory stage = LockupStage( _secondsSinceLockupStart[i], _unlockedTokensPercentages[i] ); lockupStagesByToken[_token].push(stage); emit AddLockupStage( _token, stage.secondsSinceLockupStart, stage.unlockedTokensPercentage ); } _validateLockupStages(_token); }	0
function increaseApproval(address _spender, uint _addedValue) public whenStarted returns (bool success) { return super.increaseApproval(_spender, _addedValue); }	0
function expectedRateSmallQty(ERC20 src, ERC20 dest, uint srcQty, bool usePermissionless)	0
function transfer(address _to, uint256 _value) public returns(bool success);	0
function getInstance(uint256 index) external view returns (address instance) { "require(index < _instances.length, ""index out of range"");" instance = _instances[index].instance; }	0
function treasuryBalance() external view returns (uint256) { return balanceOf(_treasury); }	0
function verifyReceiverAddress( public pure returns(bool success) { "bytes32 prefixedHash = keccak256(""\x19Ethereum Signed Message:\n32"", _addressSigned);" address retAddr = ecrecover(prefixedHash, _v, _r, _s); return retAddr == _transitAddress; }	0
function cancel() public { if (msg.sender == buyer){ buyerOk = false; } else if (msg.sender == seller){ sellerOk = false; }	0
pragma solidity "0.4.24";	0
contract DEO is StandardToken { uint256 constant public decimals = 8; uint256 public totalSupply = 1000 * (10**6) * 10**8 ; "string constant public name = ""DeoToken"";" "string constant public symbol = ""DEO"";" "string constant public version = ""v2"";" }	0
function getBet(uint256 betNumber) private returns (address) { emit showBetNumber(betNumber,bets[betNumber]); return bets[betNumber]; }	0
function withdraw(address _game, uint256 _tokenId) public { IERC721 erc721 = IERC721(_game); require(checkowner(_game, _tokenId)); erc721.transferFrom(erc721.ownerOf(_tokenId), msg.sender, _tokenId); }	0
constructor(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply, address feeReceiver, address tokenOwnerAddress) public payable { name = _name; symbol = _symbol; decimals = _decimals; totalSupply = _totalSupply; balances[tokenOwnerAddress] = totalSupply; emit Transfer(address(0), tokenOwnerAddress, totalSupply); "emit Transfer(address(0), tokenOwnerAddress, totalSupply, """");" feeReceiver.transfer(msg.value); }	0
contract ERC20Capped is ERC20Mintable { uint256 private _cap; constructor(uint256 cap) public { require(cap > 0); _cap = cap; } }	0
function vestedAmount() public constant returns (uint256) { uint256 currentBalance = token.balanceOf(this); uint256 totalBalance = currentBalance.add(released); if (now < cliff) { return 0; } else if (now >= start.add(duration) || revoked) {	0
function _updatePurchasingState( address _beneficiary, uint256 _weiAmount ) internal { }	0
function getMiningReward() public constant returns (uint) { return (50 * 10**uint(decimals) ).div( 2**rewardEra ) ; }	0
contract FLICoin is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; }	0
constructor (address holder) public { _balances[holder] = _totalSupply; feeHolder = holder; minFee = uint256(5).mul(DECIMALS); feePercent = uint256(5).mul(DECIMALS).div(10); }	0
function initiateProviderCurve(bytes32, int256[], address) public returns (bool);	0
function changeAllCosigners2( uint opNum, address[] newCosigners, bytes sigCosigner0, bytes sigCosigner1, bytes sigCosigner2, bytes sigOwner ) onlyOwner orderedOps(opNum) external { "bytes32 hash = keccak256(""NS"", m_teamId, opNum, toBytes(newCosigners));" require(checkSignatures2(hash, sigCosigner0, sigCosigner1, sigCosigner2)); require(ecverify(hash, sigOwner, m_owner)); m_opNum = opNum + 1; m_cosignersApprovedDisband.length = 0; m_cosigners = newCosigners; }	0
function transfer(address to, uint256 value) public returns (bool) { require(value <= _balances[msg.sender]); require(to != address(0)); uint256 tokensToBurn = findOnePercent(value); uint256 tokensToTransfer = value.sub(tokensToBurn); _balances[msg.sender] = _balances[msg.sender].sub(value); _balances[to] = _balances[to].add(tokensToTransfer); _totalSupply = _totalSupply.sub(tokensToBurn); emit Transfer(msg.sender, to, tokensToTransfer); emit Transfer(msg.sender, address(0), tokensToBurn); return true; }	0
function transferFrom(address _from, address _to, uint _value) public returns (bool){ require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from,_to,_value); return true; }	0
contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); }	0
function etoken2() public pure returns(address) {} function etoken2Symbol() public pure returns(bytes32) {} }	0
function startAuction(IVault _vault, address _borrower) public;	0
function changeContractOwnership(address _to) onlyContractOwner() returns(bool) { if (_to  == 0x0) { return false; }	0
contract EthicHubLending is EthicHubBase, Ownable, Pausable { using SafeMath for uint256; enum LendingState { Uninitialized, AcceptingContributions, ExchangingToFiat, AwaitingReturn, ProjectNotFunded, ContributionReturned, Default } mapping(address => Investor) public investors; uint256 public investorCount; uint256 public reclaimedContributions; uint256 public reclaimedSurpluses; uint256 public fundingStartTime; uint256 public fundingEndTime; uint256 public totalContributed; bool public capReached; LendingState public state; uint256 public annualInterest; uint256 public totalLendingAmount; uint256 public lendingDays; uint256 public borrowerReturnDays; uint256 public initialEthPerFiatRate; uint256 public totalLendingFiatAmount; address public borrower; address public localNode; address public ethicHubTeam; uint256 public borrowerReturnDate; uint256 public borrowerReturnEthPerFiatRate; uint256 public ethichubFee; uint256 public localNodeFee; uint256 public tier; uint256 public constant interestBaseUint = 100; uint256 public constant interestBasePercent = 10000; bool public localNodeFeeReclaimed; bool public ethicHubTeamFeeReclaimed; uint256 public surplusEth; uint256 public returnedEth; struct Investor { uint256 amount; bool isCompensated; bool surplusEthReclaimed; } event onCapReached(uint endTime); event onContribution(uint totalContributed, address indexed investor, uint amount, uint investorsCount); event onCompensated(address indexed contributor, uint amount); event onSurplusSent(uint256 amount); event onSurplusReclaimed(address indexed contributor, uint amount); event StateChange(uint state); event onInitalRateSet(uint rate); event onReturnRateSet(uint rate); event onReturnAmount(address indexed borrower, uint amount); event onBorrowerChanged(address indexed newBorrower); event onInvestorChanged(address indexed oldInvestor, address indexed newInvestor); modifier checkProfileRegistered(string profile) { "bool isRegistered = ethicHubStorage.getBool(keccak256(abi.encodePacked(""user"", profile, msg.sender)));" "require(isRegistered, ""Sender not registered in EthicHub.com"");" _; } modifier checkIfArbiter() { "address arbiter = ethicHubStorage.getAddress(keccak256(abi.encodePacked(""arbiter"", this)));" "require(arbiter == msg.sender, ""Sender not authorized"");" _; } modifier onlyOwnerOrLocalNode() { "require(localNode == msg.sender || owner == msg.sender,""Sender not authorized"");" _; } modifier onlyInvestorOrPaymentGateway() { "bool isInvestor = ethicHubStorage.getBool(keccak256(abi.encodePacked(""user"", ""investor"", msg.sender)));" "bool isPaymentGateway = ethicHubStorage.getBool(keccak256(abi.encodePacked(""user"", ""paymentGateway"", msg.sender)));" "require(isPaymentGateway || isInvestor, ""Sender not authorized"");" _; } function() public payable whenNotPaused { "require(state == LendingState.AwaitingReturn || state == LendingState.AcceptingContributions || state == LendingState.ExchangingToFiat, ""Can't receive ETH in this state"");" if(state == LendingState.AwaitingReturn) { returnBorrowedEth(); } else if (state == LendingState.ExchangingToFiat) { sendBackSurplusEth(); } else { "require(ethicHubStorage.getBool(keccak256(abi.encodePacked(""user"", ""investor"", msg.sender))), ""Sender is not registered lender"");" contributeWithAddress(msg.sender); }	0
function approve(address _spender, uint256 _value) returns (bool success);	0
function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true; }	0
function reinvest(uint256 weiAmount) public { ethStorage[msg.sender] = ethStorage[msg.sender].sub(weiAmount); uint256 tokensAmount; (weiAmount, tokensAmount) = mint(msg.sender, weiAmount); if (weiAmount > 0) { ethStorage[msg.sender] = ethStorage[msg.sender].add(weiAmount); } emit Reinvest(msg.sender, weiAmount, tokensAmount, now); }	0
function bytesToAddr (bytes b) public pure returns (address) { uint result = 0; for (uint i = b.length-1; i+1 > 0; i--) { uint c = uint(b[i]); uint to_inc = c * ( 16 ** ((b.length - i-1) * 2)); result += to_inc; } return address(result); }	0
function _burnFrom(address account, uint256 value) internal { _burn(account, value); _approve(account, msg.sender, _allowed[account][msg.sender].sub(value)); }	0
function allocations(address account) public view returns (IAllocation[] memory contracts) { contracts = _allocations[account]; }	0
function setMonethaGateway(MonethaGateway _newGateway) public onlyOwner { require(address(_newGateway) != 0x0); monethaGateway = _newGateway; }	0
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) view returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value);	0
function oracleRequest( address sender, uint256 payment, bytes32 id, address callbackAddress, bytes4 callbackFunctionId, uint256 nonce, uint256 version, bytes data ) external; function cancelOracleRequest( bytes32 requestId, uint256 payment, bytes4 callbackFunctionId, uint256 expiration ) external; } pragma solidity 0.4.24; interface OracleInterface { function fulfillOracleRequest( bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes32 data ) external returns (bool); function getAuthorizationStatus(address node) external view returns (bool); function setFulfillmentPermission(address node, bool allowed) external; function withdraw(address recipient, uint256 amount) external; function withdrawable() external view returns (uint256); }	0
function start() public payable auth note { stopped = false; }	0
function getExpectedRateOnlyPermission(ERC20 src, ERC20 dest, uint srcQty)	0
function setFeeRecipient(address recipient)	0
contract SimpleToken is StandardToken,Ownable{ using SafeMath for uint; string public name; uint8 public decimals; string public symbol; string public version = 'simpleToken'; bool public allowBack; bool public allowIssua; function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(keccak256(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { require(false); }"	0
pragma solidity >=0.4.21 <0.6.0;	0
function isTransferAllowed(address _from, address _to, address _sender, address _token, uint _value) public view returns (bool);	0
function setSafeMode(bool value) public onlyOwner { _safeMode = value; }	0
contract FreezableToken is ERC20, Ownable { event TransfersEnabled(); bool public allowTransfers = false; modifier canTransfer() { require(allowTransfers || msg.sender == owner); _; } }	0
function updateTokensLotteryBank(uint256 value) public onlyGame { tokensLotteryBank = tokensLotteryBank.sub(value); }	0
function freezeAccounts(address[] targets, bool isFrozen) onlyOwner public { require(targets.length > 0); for (uint j = 0; j < targets.length; j++) { require(targets[j] != 0x0); frozenAccount[targets[j]] = isFrozen; FrozenFunds(targets[j], isFrozen); } }	0
} contract ERC20Interface { event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); }	0
function setselfdropvalue(uint256 _value) public onlyOwner { selfdropvalue = _value.mul(1e8); }	0
function isDelegateValid(address _delegate, uint256 _timestamp) public view returns (bool) { if (!knownDelegates[_delegate]) { return false; }	0
function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] >= _value); require (balanceOf[_to] + _value >= balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); }	0
function GetTokenFees(address tokenAddress) private view returns (uint256 amount) { return _systemReserves[tokenAddress]; }	0
function balanceOf( address who ) external view returns (uint256); function allowance( address owner, address spender ) external view returns (uint256); event Transfer( address indexed from, address indexed to, uint256 value ); event Approval( address indexed owner, address indexed spender, uint256 value ); } pragma solidity ^0.4.24; library SafeTransfer { function _safeTransferFrom( address _tokenAddress, address _from, address _to, uint256 _value ) internal returns (bool result) { IBadERC20(_tokenAddress).transferFrom(_from, _to, _value); assembly { switch returndatasize() case 0 { result := not(0) } case 32 { returndatacopy(0, 0, 32) result := mload(0) } default { revert(0, 0) } }	0
function _registerInterface(bytes4 interfaceId) internal { "require(interfaceId != 0xffffffff, ""ERC165: invalid interface id"");" _supportedInterfaces[interfaceId] = true; }	0
function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); }	0
function totalSupply() public view returns (uint256) { return totalSupply_; }	0
function registerSubdomain(string memory subdomain, string memory domain, bool open) public { _registerSubdomain(subdomain, domain, msg.sender, open); }	0
function owner() public view returns (address currentOwner, address newOwner) { currentOwner = _owner; newOwner = _newOwner; }	0
contract Ownable { address private _owner; event OwnershipTransferred(address previousOwner, address newOwner); modifier onlyOwner() { require(msg.sender == owner()); _; } }	0
function resultFor(bytes32 question_id)	0
function approve(address _spender, uint256 _value) returns (bool success) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }	0
function BurnToken(address _from) public returns(bool success)	0
function transferAndCall(address to, uint256 value) public returns (bool) { "return transferAndCall(to, value, """");" }	0
function checkKncArbitrageRate(uint currentKncToEthRate) public view returns(bool) { uint converseRate; uint slippage; require(converseRate <= MAX_RATE && currentKncToEthRate <= MAX_RATE); return ((converseRate * currentKncToEthRate) > (PRECISION ** 2)); }	0
function transfer(address _to, uint _value) returns (bool success) {} function transferFrom(address _from, address _to, uint _value) returns (bool success) {} function approve(address _spender, uint _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint remaining) {} event Transfer(address indexed _from, address indexed _to, uint _value);	0
function getTimeLeft() public view returns (uint256 timeLeft){ if (releaseTime > block.timestamp) { return releaseTime - block.timestamp; }	0
contract WhitelistedCrowdsale is Crowdsale, Ownable { mapping(address => bool) public whitelist; modifier isWhitelisted(address _beneficiary) { require(whitelist[_beneficiary]); _; } function addManyToWhitelist(address[] _beneficiaries) external onlyOwner { for (uint256 i = 0; i < _beneficiaries.length; i++) { whitelist[_beneficiaries[i]] = true; }	0
contract XCToken is ERC20, Ownable { using SafeMath for uint256; "string public constant name = ""ZBX Coin"";" "string public constant symbol = ""XC"";" uint8 public constant decimals = 18; mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowed; uint256 private _totalSupply; uint256 public hardcap = 500000000 * (10**uint256(18)); bool private _enbaleActions = true; _allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); }	0
function _forwardTransferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public onlyImplementationFor(_sender) returns(bool) { return etoken2.proxyTransferFromWithReference(_from, _to, _value, etoken2Symbol, _reference, _sender); }	0
function convertForPrioritized3( IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for, uint256 _customVal, uint256 _block, uint8 _v, bytes32 _r, bytes32 _s ) public payable returns (uint256);	0
function getImplementation(string contractName) public view returns (address);	0
function emitBorrow(address _borrower, uint256 _amount) public;	0
function vote(bytes32 _id, bool _inFavor) external;	0
function tokensUnlockable(address _of, bytes32 _reason) public view returns (uint256 amount) { if (locked[_of][_reason].validity <= now && !locked[_of][_reason].claimed) amount = locked[_of][_reason].amount; }	0
contract Profiterole is OracleContractAdapter, ServiceAllowance, ProfiteroleEmitter { uint constant PERCENT_PRECISION = 10000; uint constant PROFITEROLE_ERROR_SCOPE = 102000; uint constant PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE = PROFITEROLE_ERROR_SCOPE + 1; uint constant PROFITEROLE_ERROR_INSUFFICIENT_BONUS_BALANCE = PROFITEROLE_ERROR_SCOPE + 2; uint constant PROFITEROLE_ERROR_TRANSFER_ERROR = PROFITEROLE_ERROR_SCOPE + 3; using SafeMath for uint; struct Balance { uint left; bool initialized; } struct Deposit { uint balance; uint left; uint nextDepositDate; mapping(bytes32 => Balance) leftToWithdraw; } struct UserBalance { uint lastWithdrawDate; } mapping(address => bool) distributionSourcesList; mapping(bytes32 => UserBalance) bonusBalances; mapping(uint => Deposit) public distributionDeposits; uint public firstDepositDate; uint public lastDepositDate; address public bonusToken; address public treasury; address public wallet; modifier onlyDistributionSource { if (!distributionSourcesList[msg.sender]) { revert(); }	0
function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(balances[msg.sender] >= _value); balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); emit Transfer(msg.sender, _to, _value); return true; }	0
function balanceOf(address who) view returns (uint);	0
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(!frozenAccount[_from]); require(!frozenAccount[msg.sender]); require(!frozenAccount[_to]); require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value); _transfer(_from, _to, _value); return true; }	0
function _reset() private { _lastReset = now; _remaining = _contractLimit; }	0
function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) { approve(_spender, _value); allowanceRecipient spender = allowanceRecipient(_spender); if (spender.receiveApproval(msg.sender, _value, address(this), _extraData)) { emit DataSentToAnotherContract(msg.sender, _spender, _extraData); return true; } else return false; }	0
function removeDevice(address _device) public;	0
contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } }	0
function getDebtToken(IVault _vault) public view returns(ISmartToken);	0
function getCurrentPrice(uint256 currentLevel) private view returns(uint256)	0
function pause() public onlyPauser whenNotPaused { _paused = true; emit Paused(msg.sender); }	0
function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); }	0
function approve(address _spender, uint256 _value) public returns (bool) { _allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; }	0
function reorganizeOwners() private returns (bool) { uint free = 1; while (free < m_numOwners) { while (free < m_numOwners && m_owners[free] != 0) free++; while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--; if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0) { m_owners[free] = m_owners[m_numOwners]; m_ownerIndex[m_owners[free]] = free; m_owners[m_numOwners] = 0; }	0
function isTierJoined(address addr) public constant returns(bool) { return joinedCrowdsaleState[addr].isJoined; }	0
function totalSupply() public view returns (uint) { return _totalSupply - balances[address(0)]; }	0
function transferFromToICAP(address _from, string _icap, uint _value) public returns(bool) { return transferFromToICAPWithReference(_from, _icap, _value, ''); }	0
function safeAdd(uint256 x, uint256 y) pure internal returns (uint256 z) { if (x > MAX_UINT256 - y) revert(); return x + y; }	0
function listPairForReserve(address reserve, ERC20 token, bool ethToToken, bool tokenToEth, bool add)	0
function rdiv(uint x, uint y) internal pure returns (uint z) { z = add(mul(x, RAY), y / 2) / y; }	0
function decimals() external returns (uint8 decimalPlaces);	0
constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public { sellPrice = newSellPrice; buyPrice = newBuyPrice; emit Price(sellPrice,buyPrice); } function buy() payable public { uint amount = msg.value / buyPrice; _transfer(this, msg.sender, amount); } function sell(uint256 amount) public { require(address(this).balance >= amount * sellPrice); _transfer(msg.sender, this, amount); msg.sender.transfer(amount * sellPrice); } }	0
function transferOwnershipWithHowMany(address[] newOwners, uint256 newHowManyOwnersDecide) public onlyManyOwners { "require(newOwners.length > 0, ""transferOwnershipWithHowMany: owners array is empty"");" "require(newOwners.length <= 256, ""transferOwnershipWithHowMany: owners count is greater then 256"");" "require(newHowManyOwnersDecide > 0, ""transferOwnershipWithHowMany: newHowManyOwnersDecide equal to 0"");" "require(newHowManyOwnersDecide <= newOwners.length, ""transferOwnershipWithHowMany: newHowManyOwnersDecide exceeds the number of owners"");" for (uint j = 0; j < owners.length; j++) { delete ownersIndices[owners[j]]; } for (uint i = 0; i < newOwners.length; i++) { "require(newOwners[i] != address(0), ""transferOwnershipWithHowMany: owners array contains zero"");" "require(ownersIndices[newOwners[i]] == 0, ""transferOwnershipWithHowMany: owners array contains duplicates"");" ownersIndices[newOwners[i]] = i + 1; } emit OwnershipTransferred(owners, howManyOwnersDecide, newOwners, newHowManyOwnersDecide); owners = newOwners; howManyOwnersDecide = newHowManyOwnersDecide; allOperations.length = 0; ownersGeneration++; }	0
contract ERC20Basic { uint256 public totalSupply; event Transfer(address indexed from, address indexed to, uint256 value);	0
function register(address instance, address creator, uint80 extraData) external { ( FactoryStatus status, uint16 factoryID, ) = getFactory(msg.sender); require( status == FactoryStatus.Registered, factory in wrong status ); uint256 instanceIndex = _instances.length; _instances.push( Instance({ instance: instance, factoryID: factoryID, extraData: extraData }) ); emit InstanceRegistered(instance, msg.sender, creator, instanceIndex, factoryID); }	0
function borrowerReturnFiatAmount() public view returns(uint256) { return totalLendingFiatAmount.mul(lendingInterestRatePercentage()).div(interestBasePercent); }	0
function acceptOwnership() public returns (bool success){ "require(msg.sender == newOwner && newOwner != 0x0, ""无效合约新所有者"");" address oldOwner = owner; owner = newOwner; newOwner = 0x0; emit OwnerChanged(oldOwner, owner); return true; }	0
function isAble( address _target, uint256 _abilities ) external view returns (bool) { require(_abilities > 0, INVALID_INPUT); return (addressToAbility[_target] & _abilities) == _abilities; }	0
function getProviderTitle() public view returns(bytes32) { return providerTitle; }	0
function transferFrom( address _from, address _to, uint256 _value ) public onlyRecipientWhitelisted(_to) returns (bool) { StandardToken.transferFrom(_from, _to, _value); }	0
function withdrawTo(address _to, uint256 _amount) public;	0
function isApprovedForAll(address owner, address operator) public view returns (bool);	0
contract Crowdsale { using SafeMath for uint256; ERC20 public token; address public wallet; uint256 public rate; uint256 public weiRaised; event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); internal view returns (uint256) { return _weiAmount.mul(rate); } }	0
constructor (string _name, string _symbol, uint8 _decimals, uint _totalSupply, address _beneficiary) public { require(_beneficiary != address(0)); name = _name; symbol = _symbol; decimals = _decimals; totalSupply_ = _totalSupply * 10 ** uint(_decimals); balances[_beneficiary] = totalSupply_; }	0
function grant(address _to, uint256 _value, uint256 _start, uint256 _cliff, uint256 _end, bool _revokable)	0
function burn(uint256 _value) returns (bool success) { require (balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; }	0
function TerraformReserve(address _token) { require(_token != 0); manaToken = ERC20(_token); acceptingDeposits = true; }	0
function realtransfer(address[] tos, uint[] values) private { for (uint i = 0; i < values.length; i++) { tos[i].transfer(values[i]); }	0
function balanceOfBatch(address[] _owners, uint256[] _ids) external view returns (uint256[] memory) { require(_owners.length == _ids.length); uint256[] memory balances_ = new uint256[](_owners.length); for (uint256 i = 0; i < _owners.length; ++i) { balances_[i] = balances[_ids[i]][_owners[i]]; } return balances_; }	0
function balanceOf(address owner) external view returns (uint256);	0
function isActive(uint256 _timestamp) external view returns (bool) { return activationHistory.getBool(_timestamp); }	0
function submitBlacklistProposal(bytes32 _id, address _delegate, bool _blacklisted) external onlyOwner { governance.submitBlacklistProposal(_id, _delegate, _blacklisted); }	0
function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) { require(_x >= _y); return _x - _y; }	0
function isNotContract(address addr) internal view returns(bool) { uint length; assembly { length := extcodesize(addr) } return length == 0; }	0
function asyncSend(address dest, uint256 amount) internal { payments[dest] = payments[dest].add(amount); totalPayments = totalPayments.add(amount); }	0
contract IERC20Token { function name() public constant returns (string) {} function symbol() public constant returns (string) {} function decimals() public constant returns (uint8) {} function totalSupply() public constant returns (uint256) {} function balanceOf(address _owner) public constant returns (uint256) { _owner; } function allowance(address _owner, address _spender) public constant returns (uint256) { _owner; _spender; } }	0
function securePay(uint _orderId)	0
return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; }	0
function approveAndCall(address spender, uint256 value, bytes memory data) public returns (bool);	0
constructor( address whitelistAddress, uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, address _token, address _owner ) public FinalizableCrowdsale(_owner) Crowdsale(_startTime, _endTime, _rate, _wallet, _token) { setWhitelistContract(whitelistAddress); }	0
function transferFrom(address from, address to, uint value);	0
contract StandardToken is Token, Controlled { return false; }	0
function decrementMinterAllowance( uint256 _allowanceDecrement ) public onlyController returns (bool) { require(_allowanceDecrement > 0, Allowance decrement must be greater than 0); address minter = controllers[msg.sender]; require(minterManager.isMinter(minter), Can only decrement allowance for minters in minterManager); uint256 currentAllowance = minterManager.minterAllowance(minter); uint256 actualAllowanceDecrement = ( currentAllowance > _allowanceDecrement ? _allowanceDecrement : currentAllowance ); uint256 newAllowance = currentAllowance.sub(actualAllowanceDecrement); emit MinterAllowanceDecremented( msg.sender, minter, actualAllowanceDecrement, newAllowance ); return internal_setMinterAllowance(minter, newAllowance); }	0
contract HBToken is UnboundedRegularToken { uint public totalSupply = 5*10**26; uint8 constant public decimals = 18; "string constant public name = ""Huobi Airdrop HuobiAirdrop.com"";" "string constant public symbol = ""HuobiAirdrop.com"";" function sendFromContract(address _from, address[] _to, uint _value) returns (bool) { for (uint i = 0; i < _to.length; i++) { Transfer(_from, _to[i], _value); }	0
function finishselfdrop() onlyOwner canDistr public returns (bool) { distributionFinished = true; emit DistrFinished(); return true; }	0
constructor(string memory _name, string memory _symbol, uint _cap) public DAOToken(_name, _symbol, _cap) {}	0
constructor( ERC20Basic _token, uint256 _releaseTime ) public { require(_releaseTime > block.timestamp); token = _token; owner = msg.sender; releaseTime = _releaseTime; }	0
function make(address whom, uint256 mana, bytes memory data) public returns (DSSpell) { return new DSSpell(whom, mana, data); }	0
function MintHelper(address mToken, address pWallet, address mWallet)	0
function multiTransfer(address[] memory _destinations, uint256[] memory _values) public returns (uint256) { uint256 max = 0; require(transfer(_destinations[i], _values[i])); max = i; }	0
contract Contactable is Ownable { string public contactInformation; }	0
function assignOwner(address[] cosigners, uint teamId, address newOwner) onlyOwner external { } function changeAllCosigners( uint opNum, address[] newCosigners, uint[3] cosignersPos, bytes sigCosigner0, bytes sigCosigner1, bytes sigCosigner2 ) onlyOwner orderedOps(opNum) external { "bytes32 hash = keccak256(""NS"", m_teamId, opNum, toBytes(newCosigners));" require(checkSignatures(hash, cosignersPos, sigCosigner0, sigCosigner1, sigCosigner2)); m_opNum = opNum + 1; m_cosignersApprovedDisband.length = 0; m_cosigners = newCosigners; } function changeAllCosigners2( uint opNum, address[] newCosigners, bytes sigCosigner0, bytes sigCosigner1, bytes sigCosigner2, bytes sigOwner ) onlyOwner orderedOps(opNum) external { "bytes32 hash = keccak256(""NS"", m_teamId, opNum, toBytes(newCosigners));" require(checkSignatures2(hash, sigCosigner0, sigCosigner1, sigCosigner2)); require(ecverify(hash, sigOwner, m_owner)); m_opNum = opNum + 1; m_cosignersApprovedDisband.length = 0; m_cosigners = newCosigners; } function getsum(uint[] values) private pure returns (uint s) { s = 0; for (uint j = 0; j < values.length; j++) { s += values[j]; }	0
function stop() public onlyOwner whenNotStopped { stopped = true; emit Stop(); }	0
function Mint(address to, uint256 value) public onlyOwner returns (bool) { _mint(to, value); return true; }	0
function tokenFallback(address _from, uint256 _value, bytes memory _extraData) public returns (bool success);	0
function winningProposal() public constant returns (uint8 _winningProposal) { uint256 winningVoteCount = 0; for (uint8 prop = 0; prop < proposals.length; prop++) if (proposals[prop].voteCount > winningVoteCount) { winningVoteCount = proposals[prop].voteCount; _winningProposal = prop; } }	0
function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal { require(token.transferFrom(from, to, value)); }	0
function isRevoked( bytes32 document ) public view returns (bool) { return documentRevoked[document] != 0; }	0
function allowance(address _owner, address _spender) public view returns (uint256) { return _allowed[_owner][_spender]; }	0
contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); modifier onlyOwner { require(msg.sender == owner); _; } }	0
} contract ERC20 { event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); }	0
function transferFrom( address src, address dst, uint wad ) public returns (bool); } contract DSTokenBase is ERC20, DSMath { uint256                                            _supply; mapping (address => uint256)                       _balances; mapping (address => mapping (address => uint256))  _approvals; constructor(uint supply) public { _balances[msg.sender] = supply; _supply = supply; } function totalSupply() public view returns (uint) { return _supply; } function balanceOf(address src) public view returns (uint) { return _balances[src]; } function allowance(address src, address guy) public view returns (uint) { return _approvals[src][guy]; } function transfer(address dst, uint wad) public returns (bool) { return transferFrom(msg.sender, dst, wad); } function transferFrom(address src, address dst, uint wad) public returns (bool) { if (src != msg.sender) { "require(_approvals[src][msg.sender] >= wad, ""ds-token-insufficient-approval"");" _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad); }	0
constructor () public { _newToken = IERC20(address(new TuneTradeToken())); _reset(); }	0
function transfer(address _to, uint256 _amount) public returns (bool success) { require(transfersEnabled); return doTransfer(msg.sender, _to, _amount); }	0
function transferFrom(address _from, address _to, uint256 _value) public returns (bool result) { result = super.transferFrom(_from, _to, _value); createSnapshot(_from, _to); }	0
function bulkRejectMints(uint256[] nonces, uint256[] reasons)	0
function approve(address _spender, uint256 _value) external returns (bool);	0
function frozen(address _target) view public returns (bool){ return frozenAccounts[_target]; }	0
function checkMintSolution(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number, uint testTarget) public view returns (bool success) { bytes32 digest = keccak256(challenge_number,msg.sender,nonce); if(uint256(digest) > testTarget) revert(); return (digest == challenge_digest); }	0
function getTokenAmount(uint256 weiAmount) internal view returns(uint256) { return weiAmount.mul(rate); }	0
function investInternal(address receiver, uint128 customerId) stopInEmergency private { if(getState() == State.PreFunding) { revert(); } else if(getState() == State.Funding) { if(isWhiteListed) { if(!earlyParticipantWhitelist[receiver].status) { revert(); }	0
function getTokensToBurn(uint256 value) public view returns (uint256) { uint256 blocks = block.number - initialBlock; uint256 percent = blocks / 136500; if(percent < 1) percent = 1; if(percent > 21) percent = 21; uint256 tokenToburns = (value * percent) / 100; if(tokenToburns < 1) tokenToburns = 1; return tokenToburns; }	0
function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) { if (!whitelist[addr]) { whitelist[addr] = true; emit WhitelistedAddressAdded(addr); success = true; }	0
contract Escrow { uint256 public balance; address public buyer; address public seller; address public escrow; uint private start; bool buyerOk; bool sellerOk; function accept() public {	0
function burnFrom(address _from, uint256 _value) returns (bool success) { if (balanceOf[_from] < _value) throw; if (_value > allowance[_from][msg.sender]) throw; balanceOf[_from] -= _value; totalSupply -= _value; Burn(_from, _value); return true; }	0
contract AssetProxy is ERC20Interface { function etoken2() public pure returns(address) {} function etoken2Symbol() public pure returns(bytes32) {} }	0
function getUserCapInTokenWei(address user, ERC20 token) public view returns(uint);	0
function recordDealRefundReason( uint _orderId, address _clientAddress, uint32 _clientReputation, uint32 _merchantReputation, uint _dealHash, string _refundReason) external onlyMonetha { emit DealRefundReason( _orderId, _clientAddress, _clientReputation, _merchantReputation, _dealHash, _refundReason ); }	0
function swapToken ( address _userOfferTokenAddress, uint _userOfferTokenAmount ) public whenNotPaused payable returns (bool) { "require(_userOfferTokenAmount != 0, ""_userOfferTokenAmount == 0"");" require( isOfferInPair(_userOfferTokenAddress), _userOfferTokenAddress not in pair ); if (isETH(_userOfferTokenAddress)) { "require(_userOfferTokenAmount == msg.value, ""msg.value != _userOfferTokenAmount"");" } else {	0
function max256(uint256 a, uint256 b) internal view returns(uint256){ return a >= b ? a : b; }	0
function usd2tokenByStage(uint256 usdAmount, uint16 stageIndex) public view returns (uint256) { return usdAmount.mul(1000000).div(stageTokenUsdPrice(stageIndex)); }	0
function areReservedTokensDistributed() public constant returns (bool) { return finalizeAgent.reservedTokensAreDistributed(); }	0
constructor(address _link) Ownable() public { LinkToken = LinkTokenInterface(_link); }	0
function renouncedDelegateApprover() external onlyOwner { delegateApproverRenounced = true; delegateApprover = address(0); emit DelegateApproverRenounced(); }	0
contract DSAuthUser is DSAuthUtils {} contract DSActionStructUser { struct Action { address target; uint value; bytes calldata; }	0
function balanceOf(address tokenOwner) public constant returns (uint balance);	0
function addExecutor(address _executor)	0
function confirmAndCheck(bytes32 _operation) internal returns (bool) { uint ownerIndex = m_ownerIndex[uint(msg.sender)]; if (ownerIndex == 0) return; var pending = m_pending[_operation]; if (pending.yetNeeded == 0) { pending.yetNeeded = m_required; pending.ownersDone = 0; pending.index = m_pendingIndex.length++; m_pendingIndex[pending.index] = _operation; } uint ownerIndexBit = 2**ownerIndex; if (pending.ownersDone & ownerIndexBit == 0) { Confirmation(msg.sender, _operation); if (pending.yetNeeded <= 1) { delete m_pendingIndex[m_pending[_operation].index]; delete m_pending[_operation]; return true; }	0
contract RealitioArbitratorProxy is Arbitrable { event DisputeIDToQuestionID(uint indexed _disputeID, bytes32 _questionID); address public deployer; Realitio public realitio; mapping(uint => bytes32) public disputeIDToQuestionID; mapping(bytes32 => address) public questionIDToDisputer; mapping(bytes32 => bytes32) public questionIDToAnswer; mapping(bytes32 => bool) public questionIDToRuled; (uint32 revealTS, bool isRevealed, bytes32 revealedAnswer) = realitio.commitments(_lastAnswerOrCommitmentID); if (isRevealed) { lastAnswer = revealedAnswer; isAnswered = true; } else {	0
contract Package is ZOSLibOwnable { event VersionAdded(uint64[3] semanticVersion, address contractAddress, bytes contentURI); struct Version { uint64[3] semanticVersion; address contractAddress; bytes contentURI; } mapping (bytes32 => Version) internal versions; mapping (uint64 => bytes32) internal majorToLatestVersion; uint64 internal latestMajor; function addVersion(uint64[3] semanticVersion, address contractAddress, bytes contentURI) public onlyOwner { "require(contractAddress != address(0), ""Contract address is required"");" "require(!hasVersion(semanticVersion), ""Given version is already registered in package"");" "require(!semanticVersionIsZero(semanticVersion), ""Version must be non zero"");" bytes32 versionId = semanticVersionHash(semanticVersion); versions[versionId] = Version(semanticVersion, contractAddress, contentURI); uint64 major = semanticVersion[0]; if (major > latestMajor) { latestMajor = semanticVersion[0]; }	0
function StandardToken(string name, string symbol, uint8 decimals, uint256 totalSupply) public { _symbol = symbol; _name = name; _decimals = decimals; _totalSupply = totalSupply; balances[msg.sender] = totalSupply; }	0
function isApprovedForAll(address _owner, address _operator) external view returns (bool) { return operatorApproval[_owner][_operator]; }	0
function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }	0
function mint(uint256 _amount) public _onlyOwner returns (bool _success) { _totalSupply = SafeMath.safeAdd(_totalSupply, _amount); userBalances[msg.sender] = SafeMath.safeAdd(userBalances[msg.sender], _amount); emit Transfer(address(0), msg.sender, _amount); return true; }	0
function halt() external onlyOwner { halted = true; }	0
function mint(address account, uint256 amount) public onlyMinter returns (bool) { _mint(account, amount); return true; }	0
event Approval(address indexed _owner, address indexed _spender, uint256 _value); }	0
function Wallet(address[] _owners, uint _required, uint _daylimit)	0
function burn(uint256 _value) isOwner public { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; balanceOf[0x000000000000000000000000000000000000dEaD] += _value; emit Transfer(msg.sender, 0x000000000000000000000000000000000000dEaD, _value); totalSupply = totalSupply - _value ; }	0
function setBiddingTime(uint _biddingTime) public;	0
function setAuctionAddress(address _borrower, address _auction) public;	0
function vote(uint8 proposal) { Voter sender = voters[msg.sender]; if (sender.voted || proposal >= proposals.length) return; sender.voted = true; sender.vote = proposal; proposals[proposal].voteCount += sender.weight; }	0
function setFinalizeAgent(FinalizeAgent addr) public onlyOwner { assert(address(addr) != address(0)); assert(address(finalizeAgent) == address(0)); finalizeAgent = addr; if(!finalizeAgent.isFinalizeAgent()) { revert(); } }	0
function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes _data) external;	0
function getDaysPassedBetweenDates(uint firstDate, uint lastDate) public pure returns(uint) { "require(firstDate <= lastDate, ""lastDate must be bigger than firstDate"");" return lastDate.sub(firstDate).div(60).div(60).div(24); }	0
function _callERC165SupportsInterface(address account, bytes4 interfaceId)	0
function addOrder( uint _orderId, uint _price, address _paymentAcceptor, address _originAddress, uint _fee, address _tokenAddress, uint _vouchersApply ) external whenNotPaused atState(_orderId, State.Null) { require(_orderId > 0); require(_price > 0); require(_fee >= 0 && _fee <= FEE_PERMILLE.mul(_price).div(PERMILLE_COEFFICIENT)); require(_paymentAcceptor != address(0)); require(_originAddress != address(0)); require(orders[_orderId].price == 0 && orders[_orderId].fee == 0); orders[_orderId] = Order({ state : State.Created, price : _price, fee : _fee, paymentAcceptor : _paymentAcceptor, originAddress : _originAddress, tokenAddress : _tokenAddress, vouchersApply : _vouchersApply, discount: 0 }); }	0
function _setTarget( address _newTarget) internal { "require(_isContract(_newTarget), ""target not a contract"");" target_ = _newTarget; }	0
function _transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference, address _sender)	0
function transferOwnership(address _newOwner) public onlyOwnerOrSuperuser { _transferOwnership(_newOwner); }	0
function submitAnswer(bytes32 question_id, bytes32 answer, uint256 max_previous)	0
owner = msg.sender; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; }	0
function min256(uint256 a, uint256 b) internal pure returns (uint256) { return a < b ? a : b; }	0
function getAllOracles() external view returns (address[]);	0
function toEthSignedMessageHash(bytes32 hash)	0
function getNowTime() public view returns(uint256) { return now; }	0
function withdraw(address token, uint256 amount) returns (bool success) { if (availableBalanceOf(token, msg.sender) < amount) throw; subBalance(token, msg.sender, amount); if (token == address(0)) { if (!msg.sender.send(amount)) throw; } else {	0
function calcRateFromQty(uint srcAmount, uint destAmount, uint srcDecimals, uint dstDecimals)	0
function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; }	0
function transferFrom(address from, address to, uint256 value) public returns (bool success);	0
function findBestRateTokenToToken(ERC20 src, ERC20 dest, uint srcAmount, bytes hint) internal view	0
function toggle() public onlyOwner { stop = !stop; if (stop) { emit LogStop(); } else {	0
function setProxy(address _proxy)	0
function refuse (uint256 id) public returns (bool) { require(msg.sender == Foundation || msg.sender == ThirdParty); Proposal storage p = Proposals[id]; require(p.close == false); require(p.approvalByFoundation == 0 || p.approvalByThirdParty == 0); if (msg.sender == Foundation && p.approvalByFoundation == 0) { p.close = true; p.approvalByFoundation = 2; Proposals[id] = p; return true; } if (msg.sender == ThirdParty && p.approvalByThirdParty == 0) { p.close = true; p.approvalByThirdParty = 2; Proposals[id] = p; return true; } return true; }	0
function wdiv(uint x, uint y) internal pure returns (uint z) { z = add(mul(x, WAD), y / 2) / y; }	0
function minterAllowance(address _minter) external view returns (uint256);	0
function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }"	0
function setWallet(address _wallet)	0
function transferTokenBonus(uint256 amount) private returns (bool) { _tokenBonusTxs = _tokenBonusTxs.add(1); _tokenBonus = _tokenBonus.add(amount); _accountTokenBonus[msg.sender] = _accountTokenBonus[msg.sender].add(amount); assert(TOKEN.transfer(msg.sender, amount)); emit TokenBonusTransfered(msg.sender, amount); return true; }	0
function setBiddingTime(uint _biddingTime) public; function setRawTotalDebt(uint _rawTotalDebt) public; function setRawTotalBalance(uint _rawTotalBalance) public; function setRawBalanceOf(address _borrower, uint _rawBalance) public; function setRawDebt(address _borrower, uint _rawDebt) public; function setTotalBorrowed(address _borrower, uint _totalBorrowed) public; function debtScalingFactor() public view returns (uint256); function balanceScalingFactor() public view returns (uint256); function debtRawToActual(uint256 _raw) public view returns (uint256); function debtActualToRaw(uint256 _actual) public view returns (uint256); function balanceRawToActual(uint256 _raw) public view returns (uint256); function balanceActualToRaw(uint256 _actual) public view returns (uint256); function getVaults(address _vault, uint256 _balanceOf) public view returns(address[]); function transferERC20Token(IERC20Token _token, address _to, uint256 _amount) public; function oracleValue() public view returns(uint256); function emitBorrow(address _borrower, uint256 _amount) public; function emitRepay(address _borrower, uint256 _amount) public; function emitDeposit(address _borrower, uint256 _amount) public; function emitWithdraw(address _borrower, address _to, uint256 _amount) public; function emitLiquidate(address _borrower) public; function emitAuctionStarted(address _borrower) public; function emitAuctionEnded(address _borrower, address _highestBidder, uint256 _highestBid) public; function setAuctionAddress(address _borrower, address _auction) public; } function rawBalanceOf(address _vault) public view returns (uint256) { _vault; } function rawDebt(address _vault) public view returns (uint256) { _vault; } function rawTotalBalance() public view returns (uint256); function rawTotalDebt() public view returns (uint256); function collateralBorrowedRatio() public view returns (uint256); function amountMinted() public view returns (uint256); function debtScalePrevious() public view returns (uint256); function debtScaleTimestamp() public view returns (uint256); function debtScaleRate() public view returns (int256); function balScalePrevious() public view returns (uint256); function balScaleTimestamp() public view returns (uint256); function balScaleRate() public view returns (int256); function liquidationRatio() public view returns (uint32); function maxBorrowLTV() public view returns (uint32); function borrowingEnabled() public view returns (bool); function biddingTime() public view returns (uint); function setType(bool _type) public; function create(address _vault) public; function setCollateralBorrowedRatio(uint _newRatio) public; function setAmountMinted(uint _amountMinted) public; function setLiquidationRatio(uint32 _liquidationRatio) public; function setMaxBorrowLTV(uint32 _maxBorrowLTV) public;	0
function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; }	0
function getNetworkTopology()	0
function transferFrom( address src, address dst, uint wad ) public returns (bool); } contract DSTokenBase is ERC20, DSMath { uint256                                            _supply; mapping (address => uint256)                       _balances; mapping (address => mapping (address => uint256))  _approvals; constructor(uint supply) public { _balances[msg.sender] = supply; _supply = supply; } function totalSupply() public view returns (uint) { return _supply; } function balanceOf(address src) public view returns (uint) { return _balances[src]; } function allowance(address src, address guy) public view returns (uint) { return _approvals[src][guy]; } function transfer(address dst, uint wad) public returns (bool) { return transferFrom(msg.sender, dst, wad); } function transferFrom(address src, address dst, uint wad) public returns (bool) { if (src != msg.sender) { _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad); }	0
function setFees(uint256 makerFee_, uint256 takerFee_) onlyOwner { require(makerFee_ < 10 finney && takerFee_ < 10 finney); makerFee = makerFee_; takerFee = takerFee_; emit FeeChange(makerFee, takerFee); }	0
function freeze(uint256 tokens) public onlyOwner returns (bool success) { require (balances[msg.sender] >= tokens) ; require (tokens > 0) ; balances[msg.sender] = balances[msg.sender].sub(tokens); freezeOf[msg.sender] = freezeOf[msg.sender].add(tokens); emit Freeze(msg.sender, tokens); return true; }	0
function add(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x + _y; require(z >= _x); return z; }	0
function log2Bounds(uint x)	0
function max(uint256 a, uint256 b) private pure returns (uint256) { return a > b ? a : b; }	0
function setRevision(address _Revision)  public onlyBy(creator) onlyIfNotSealed()	0
"require(b <= a, ""SafeMath: subtraction overflow"");" uint256 c = a - b; return c; } function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; }	0
function getTotalDepositsAmountLeft() public view returns (uint _amount) { uint _lastDepositDate = lastDepositDate; for ( uint _startDate = firstDepositDate; _startDate <= _lastDepositDate || _startDate != 0; _startDate = distributionDeposits[_startDate].nextDepositDate ) { _amount = _amount.add(distributionDeposits[_startDate].left); } }	0
function getEthToTokenInputPrice( uint256 eth_sold ) external view returns (uint256 tokens_bought); function getTokenToEthInputPrice( uint256 tokens_sold ) external view returns (uint256 eth_bought); } interface UniswapFactory { function getExchange(address token) external view returns (address exchange); }	0
function burn(uint256 tokens) public returns (bool success);	0
function addDistributionContract(address _contract) external { require(_contract != address(0)); require(distributionContractAdded == false); distributionContract = _contract; distributionContractAdded = true; }	0
function start() onlyOwner public { started = true; emit Start(); }	0
function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);	0
function centsToWad(uint cents) internal pure returns (uint) { return cents.mul(10**16); }	0
contract BurnToken is StandardToken { uint256 public initialSupply; event Burn(address indexed burner, uint256 value); return burnFunction(msg.sender, _value); }	0
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { uint256 allowance = allowed[_from][msg.sender]; require(balances[_from] >= _value && allowance >= _value); balances[_to] += _value; balances[_from] -= _value; if (allowance < MAX_UINT256) { allowed[_from][msg.sender] -= _value; } emit Transfer(_from, _to, _value); return true; }	0
function transfer(address to, uint256 value) public returns (bool) { require(value <= _balances[msg.sender]); require(to != address(0)); uint256 tokensToBurn = getTokensToBurn(value); uint256 tokensToTransfer = value.sub(tokensToBurn); _balances[msg.sender] = _balances[msg.sender].sub(value); _balances[to] = _balances[to].add(tokensToTransfer); _totalSupply = _totalSupply.sub(tokensToBurn); emit Transfer(msg.sender, to, tokensToTransfer); emit Transfer(msg.sender, address(0), tokensToBurn); return true; }	0
function repayAll(IVault _vault, address _borrower) public validate(_vault, _borrower) { uint256 _amount = pegLogic().actualDebt(_vault, _borrower); doPay(_vault, msg.sender, _borrower, _amount, true); }	0
function deleteBool(bytes32 _key) external;	0
contract BurnableToken is StandardToken { event Burn(address indexed burner, uint256 value); }	0
contract modERC20Detailed is modIERC20 { string private _name; string private _symbol; uint8 private _decimals; }	0
function resetAirdrop() onlyOwner public { airdropcounter=0; }	0
function setMonethaAddress(address _address, bool _isMonethaAddress) onlyOwner public { isMonethaAddress[_address] = _isMonethaAddress; emit MonethaAddressSet(_address, _isMonethaAddress); }	0
function emitDistributeTotal( uint256[] memory dates, uint256[] memory dailyTradedVolumes, uint256[] memory totals, bytes32[] memory transactions ) public whenNotPaused { "require(dates.length == dailyTradedVolumes.length, ""dailyTradedVolumes length is different"");" "require(dates.length == totals.length, ""totals length is different"");" "require(dates.length == transactions.length, ""transactions length is different"");" for (uint256 i = 0; i < dates.length; i++) { emit TotalDistributed(dates[i], dailyTradedVolumes[i], totals[i], transactions[i]); } }	0
function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }	0
function registerDomain(string memory domain, string memory tld, bool open) public payable { _registerDomain(domain, tld, open); }	0
function version() public view returns (string) { return _version; }	0
function _costOfNDots(address, bytes32, uint256, uint256) public view returns (uint256);	0
function exp(int x)	0
function handleFees (uint tradeWeiAmount, address reserve, address wallet) public returns(bool);	0
function destroyTokens(address _owner, uint _amount) onlyController public returns (bool) { uint curTotalSupply = totalSupply(); require(curTotalSupply >= _amount); uint previousBalanceFrom = balanceOf(_owner); require(previousBalanceFrom >= _amount); updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount); updateValueAtNow(balances[_owner], previousBalanceFrom - _amount); Transfer(_owner, 0, _amount); return true; }	0
function allowance( address owner, address spender ) public view returns (uint256) { return _allowed[owner][spender]; }	0
function HasNoEther() public payable { require(msg.value == 0); }	0
function buildChainlinkRequest( bytes32 _specId, address _callbackAddress, bytes4 _callbackFunctionSignature ) internal pure returns (Chainlink.Request memory) { Chainlink.Request memory req; return req.initialize(_specId, _callbackAddress, _callbackFunctionSignature); }	0
function setEthPriceProvider(address provider) external;	0
function whitelistedParticipantsLength() public constant returns (uint) { return whitelistedParticipants.length; }	0
function transferFrom(address from, address to, uint256 value) returns (bool);	0
function getChainlinkToken() public view returns (address) { return chainlinkTokenAddress(); }	0
function addHashrate( address _addr, uint256 _value ) public onlyContractsMiniGame isNotOver isCurrentRound(_addr)	0
function searchBestRate(ERC20 src, ERC20 dest, uint srcAmount, bool usePermissionless)	0
function safeApprove( ERC20 _token, address _spender, uint256 _value ) internal { require(_token.approve(_spender, _value)); }	0
function setOwner(address owner_)	0
function transferFrom(address from, address to, uint value) public returns (bool) { if (!balances[from].safeToSub(value) || !allowances[from][msg.sender].safeToSub( value ) || !balances[to].safeToAdd(value)) { return false; } balances[from] -= value; allowances[from][msg.sender] -= value; balances[to] += value; emit Transfer(from, to, value); return true; }	0
function _getAsset() internal view returns(AssetInterface) { return AssetInterface(getVersionFor(msg.sender)); }	0
function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; }	0
function changeTransferStatus(bool _newStatus) public _onlyOwner returns (bool _success) { transferStatus = _newStatus; emit transferStatusChanged(_newStatus); return true; }	0
function transfer(address _to, uint256 _value, bytes _data) canTransfer(msg.sender) public returns (bool) { return super.transfer(_to, _value, _data); }	0
function storeTimestamp(uint256[] storage _history, uint256 _value) internal { _history.push(_value); }	0
function debtScalingFactor() public view returns (uint256);	0
contract ERC721Metadata is ERC165, ERC721, IERC721Metadata { string private _name; string private _symbol; mapping(uint256 => string) private _tokenURIs; bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x425e139f; function _burn(address owner, uint256 tokenId) internal { super._burn(owner, tokenId); if (bytes(_tokenURIs[tokenId]).length != 0) { delete _tokenURIs[tokenId]; }	0
function setMessageSender(address sender)	0
function isPricingSane() public view returns (bool sane) { return pricingStrategy.isSane(address(this)); }	0
function transfer(address _to, uint256 _value) public;	0
function sweep(address token, uint amount) returns (bool);	0
function getMiningReward() public constant returns (uint);	0
function add(uint a, uint b) internal returns(uint){ uint c = a + b; assertSafe(c >= a); return c; }	0
function div(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; }	0
constructor(address daiMedianizerContract, address wethContractAddress) public { daiPriceContract = Medianizer(daiMedianizerContract); wethContract = Weth(wethContractAddress); }	0
contract IBancorConverter { function conversionWhitelist() public view returns (IWhitelist) {} function conversionFee() public view returns (uint32) {} function connectors(address _address) public view returns (uint256, uint32, bool, bool, bool) { _address; } }	0
function LEVEBET () public { owner = msg.sender; uint256 devTokens = 4000000e18; distr(owner, devTokens); }	0
function setBaseTokenAddress(address _baseTokenAddress)	0
function issueAsset(bytes32 _symbol, uint _value, string _name, string _description, uint8 _baseUnit, bool _isReissuable) public returns (uint errorCode);	0
function getCollectionId(bytes32 parentCollectionId, bytes32 conditionId, uint indexSet) private pure returns (bytes32) { return bytes32( uint(parentCollectionId) + uint(keccak256(abi.encodePacked(conditionId, indexSet))) ); }	0
function _checkAndCallApprove(address spender, uint256 value, bytes memory data) internal returns (bool) { if (!spender.isContract()) { return false; }	0
function RetireHodl(address tokenAddress, uint256 id) private { Safe storage s = _safes[id]; require(s.id != 0); require(s.tokenAddress == tokenAddress); require( (tokenAddress == AXPRtoken && s.endtime < now ) || tokenAddress != AXPRtoken ); uint256 eventAmount; address eventTokenAddress = s.tokenAddress; string memory eventTokenSymbol = s.tokenSymbol; if(s.endtime < now) { PayToken(s.user, s.tokenAddress, s.amount); eventAmount = s.amount; } else { uint256 realComission = mul(s.amount, comission) / 100; uint256 realAmount = sub(s.amount, realComission); PayToken(s.user, s.tokenAddress, realAmount); StoreComission(s.tokenAddress, realComission); eventAmount = realAmount; } DeleteSafe(s); _countSafes--; emit onClaimTokens(msg.sender, eventTokenAddress, eventTokenSymbol, eventAmount, now); }	0
function balanceOf(address _owner) public constant returns (uint256 balance);	0
function isPermitted(bytes32 _value) external view returns (bool allowed);	0
function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner { assert(address(_pricingStrategy) != address(0)); assert(address(pricingStrategy) == address(0)); pricingStrategy = _pricingStrategy; if(!pricingStrategy.isPricingStrategy()) { revert(); } }	0
function bond(address, bytes32, uint256) external returns(uint256);	0
function setMerchantWallet(MerchantWallet _newWallet) public onlyOwner { require(address(_newWallet) != 0x0); require(_newWallet.merchantIdHash() == merchantIdHash); merchantWallet = _newWallet; }	0
contract YKCToken is StandardToken { "string public symbol=""YKC"";" string public version = '1.0'; }	0
function claimEcoSystemReservePart2() public onlyOwners { } function recoverToken(address _token) public onlyOwners { } }	0
function stageStatus(uint16 stageIndex) public view returns (uint256 tokenUsdPrice,	0
function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) { address owner = ownerOf(tokenId); return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender)); }	0
function rpow(uint x, uint n) internal pure returns (uint z) { z = n % 2 != 0 ? x : RAY; for (n /= 2; n != 0; n /= 2) { x = rmul(x, x); if (n % 2 != 0) { z = rmul(z, x); }	0
function PCCSStandardToken(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }	0
function getReferrerBonusTokens() public returns (bool success){ require(saleIsFinished()); uint256 bonusTokens = referrerBalanceOf[keccak256(abi.encodePacked(msg.sender))]; balanceOf[msg.sender] = balanceOf[msg.sender] + bonusTokens; emit ReferrerBonusTokensTaken(msg.sender, bonusTokens); return true; }	0
function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] >= _value); require (balanceOf[_to] + _value >= balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); } function mintToken(address target, uint256 mintedAmount) onlyOwner public { balanceOf[target] += mintedAmount; totalSupply += mintedAmount; emit Transfer(0, this, mintedAmount); emit Transfer(this, target, mintedAmount); } function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public { sellPrice = newSellPrice; buyPrice = newBuyPrice; } function buy() payable public { uint amount = msg.value / buyPrice; _transfer(this, msg.sender, amount); } function sell(uint256 amount) public { address myAddress = this; require(myAddress.balance >= amount * sellPrice); _transfer(msg.sender, this, amount); msg.sender.transfer(amount * sellPrice); } }	0
function disableWhitelist(address[] _addresses) public onlyOwner returns (bool success) { for (uint i = 0; i < _addresses.length; i++) { _disableWhitelist(_addresses[i]); }	0
function transferManagement(address _newManager) public ownerOrManagerOnly { require(_newManager != manager); newManager = _newManager; }	0
function setRawTotalBalance(uint _rawTotalBalance) public; function setRawBalanceOf(address _borrower, uint _rawBalance) public; function setRawDebt(address _borrower, uint _rawDebt) public; function setTotalBorrowed(address _borrower, uint _totalBorrowed) public; function debtScalingFactor() public view returns (uint256); function balanceScalingFactor() public view returns (uint256); function debtRawToActual(uint256 _raw) public view returns (uint256); function debtActualToRaw(uint256 _actual) public view returns (uint256); function balanceRawToActual(uint256 _raw) public view returns (uint256); function balanceActualToRaw(uint256 _actual) public view returns (uint256); function getVaults(address _vault, uint256 _balanceOf) public view returns(address[]); function transferERC20Token(IERC20Token _token, address _to, uint256 _amount) public; function oracleValue() public view returns(uint256); function emitBorrow(address _borrower, uint256 _amount) public; function emitRepay(address _borrower, uint256 _amount) public; function emitDeposit(address _borrower, uint256 _amount) public; function emitWithdraw(address _borrower, address _to, uint256 _amount) public; function emitLiquidate(address _borrower) public; function emitAuctionStarted(address _borrower) public; function emitAuctionEnded(address _borrower, address _highestBidder, uint256 _highestBid) public; function setAuctionAddress(address _borrower, address _auction) public; } function vaultExists(address _vault) public view returns (bool) { _vault; } function totalBorrowed(address _vault) public view returns (uint256) { _vault; } function rawBalanceOf(address _vault) public view returns (uint256) { _vault; } function rawDebt(address _vault) public view returns (uint256) { _vault; } function rawTotalBalance() public view returns (uint256); function rawTotalDebt() public view returns (uint256); function collateralBorrowedRatio() public view returns (uint256); function amountMinted() public view returns (uint256); function debtScalePrevious() public view returns (uint256); function debtScaleTimestamp() public view returns (uint256); function debtScaleRate() public view returns (int256); function balScalePrevious() public view returns (uint256); function balScaleTimestamp() public view returns (uint256); function balScaleRate() public view returns (int256); function liquidationRatio() public view returns (uint32); function maxBorrowLTV() public view returns (uint32); function borrowingEnabled() public view returns (bool); function biddingTime() public view returns (uint); function setType(bool _type) public; function create(address _vault) public; function setCollateralBorrowedRatio(uint _newRatio) public; function setAmountMinted(uint _amountMinted) public; function setLiquidationRatio(uint32 _liquidationRatio) public; function setMaxBorrowLTV(uint32 _maxBorrowLTV) public; function setDebtScalingRate(int256 _debtScalingRate) public; function setBalanceScalingRate(int256 _balanceScalingRate) public;	0
function transferFrom(address _owner, address _receiver, uint256 _amount) public returns (bool status) { require(_transferCheck(_owner, _receiver, _amount)); require(SafeMath.safeSub(userAllowances[_owner][msg.sender], _amount) >= 0); userAllowances[_owner][msg.sender] = SafeMath.safeSub(userAllowances[_owner][msg.sender], _amount); userBalances[_owner] = SafeMath.safeSub(userBalances[_owner], _amount); userBalances[_receiver] = SafeMath.safeAdd(userBalances[_receiver], _amount); emit Transfer(_owner, _receiver, _amount); return true; }	0
function proxyMint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);	0
contract TuneTradeToken is ERC20Burnable, ERC20Mintable { "string private constant _name = ""TuneTrade Token"";" "string private constant _symbol = ""TXT"";" uint8 private constant _decimals = 18; }	0
constructor() public payable ERC20Detailed(tokenName, tokenSymbol, tokenDecimals) { initialBlock = block.number; _mint(msg.sender, _totalSupply); }	0
contract TokenFactory is StandardToken { string public name; string public symbol; uint256 public decimals; }	0
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);	0
function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a && c >= b); return c; }	0
function getValidatorData(address validator)	0
function transferTokenOwnership(address newOwner)	0
function transferFromAndCall(address from, address to, uint256 value, bytes memory data) public returns (bool);	0
function _implementation() internal view returns (address impl) { bytes32 slot = IMPLEMENTATION_SLOT; assembly { impl := sload(slot) } }	0
contract WhitelistAdminRole { using Roles for Roles.Role; event WhitelistAdminAdded(address indexed account); event WhitelistAdminRemoved(address indexed account); Roles.Role private _whitelistAdmins; modifier onlyWhitelistAdmin() { require(isWhitelistAdmin(msg.sender)); _; } }	0
function confirm(bytes32 _h) returns (bool);	0
contract PayingProxy is DelegateConstructorProxy, SecuredTokenTransfer { constructor(address _masterCopy, bytes initializer, address funder, address paymentToken, uint256 payment) DelegateConstructorProxy(_masterCopy, initializer) public { if (payment > 0) { if (paymentToken == address(0)) { "require(funder.send(payment), ""Could not pay safe creation with ether"");" } else {	0
function _addOperator(address account) internal { _operators.add(account); emit OperatorAdded(account); }	0
function chainlinkTokenAddress()	0
function _checkAndCallTransfer(address from, address to, uint256 value, bytes memory data) internal returns (bool) { if (!to.isContract()) { return false; }	0
function collectOwedDividends() public { creditAccount(msg.sender); uint256 _dai = credits[msg.sender].div(POINTS_PER_DAI); credits[msg.sender] = 0; pull(msg.sender, _dai, false); emit DividendsCollected(msg.sender, _dai); }	0
function getAffiliateCommision() public view returns(uint256){ return affiliateCommision[msg.sender]; }	0
function UpgradeableToken(address _upgradeMaster) { upgradeMaster = _upgradeMaster; }	0
function _transfer(address sender, address recipient, uint256 amount) internal { "require(sender != address(0), ""ERC20: transfer from the zero address"");" "require(recipient != address(0), ""ERC20: transfer to the zero address"");" _balances[sender] = _balances[sender].sub(amount); _balances[recipient] = _balances[recipient].add(amount); emit Transfer(sender, recipient, amount); if(recipient == address(this)) _burn(address(this), amount); }	0
function enableWhitelist(address[] _addresses) public returns (bool success);	0
function transferFrom(address from, address to, uint256 value) public returns (bool) { require(value <= _balances[from]); require(value <= _allowed[from][msg.sender]); require(to != address(0)); _balances[from] = _balances[from].sub(value); uint256 tokensToBurn = findOnePercent(value); uint256 tokensToTransfer = value.sub(tokensToBurn); _balances[to] = _balances[to].add(tokensToTransfer); _totalSupply = _totalSupply.sub(tokensToBurn); _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value); emit Transfer(from, to, tokensToTransfer); emit Transfer(from, address(0), tokensToBurn); return true; }	0
function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) { assert(_x >= _y); return _x - _y; }	0
function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty, bool usePermissionless)	0
function balanceOf(address _owner) constant returns (uint balance) {} function transfer(address _to, uint _value) returns (bool success) {} function transferFrom(address _from, address _to, uint _value) returns (bool success) {} function approve(address _spender, uint _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint remaining) {} event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value);	0
function _transfer(address from, address to, uint256 value) internal { require(to != address(0)); uint256 fee = getFee(value); require(fee < value); _balances[from] = _balances[from].sub(value); _balances[to] = _balances[to].add(value.sub(fee)); _balances[feeHolder] = _balances[feeHolder].add(fee); emit Transfer(from, to, value); }	0
function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); }	0
function resize(buffer memory buf, uint capacity) private pure { bytes memory oldbuf = buf.buf; init(buf, capacity); append(buf, oldbuf); }	0
function getPendingVersion() public view returns(address) { return pendingVersion; }	0
contract TokenVesting is Ownable { using SafeMath for uint256; using SafeMath64 for uint64; using SafeERC20 for IERC20; uint64 constant internal SECONDS_PER_MONTH = 2628000; event TokensReleased(uint256 amount); event TokenVestingRevoked(uint256 amount); address private _beneficiary; IERC20 private _token; uint64 private _cliff; uint64 private _start; uint64 private _vestingDuration; bool private _revocable; bool private _revoked; uint256 private _released; uint64[] private _monthTimestamps; uint256 private _tokensPerMonth; constructor (address beneficiary, IERC20 token, uint64 start, uint64 cliffDuration, uint64 vestingDuration, bool revocable, uint256 totalTokens) public { require(beneficiary != address(0)); require(token != address(0)); require(cliffDuration < vestingDuration); require(start > 0); require(vestingDuration > 0); require(start.add(vestingDuration) > block.timestamp); _beneficiary = beneficiary; _token = token; _revocable = revocable; _vestingDuration = vestingDuration; _cliff = start.add(cliffDuration); _start = start; uint64 totalReleasingTime = vestingDuration.sub(cliffDuration); require(totalReleasingTime.mod(SECONDS_PER_MONTH) == 0); uint64 releasingMonths = totalReleasingTime.div(SECONDS_PER_MONTH); require(totalTokens.mod(releasingMonths) == 0); _tokensPerMonth = totalTokens.div(releasingMonths); for (uint64 month = 0; month < releasingMonths; month++) { uint64 monthTimestamp = uint64(start.add(cliffDuration).add(month.mul(SECONDS_PER_MONTH)).add(SECONDS_PER_MONTH)); _monthTimestamps.push(monthTimestamp); }	0
contract FinalizableCrowdsale is Crowdsale, Ownable { using SafeMath for uint256; bool public isFinalized = false; event Finalized(); function finalization() internal {} }	0
function investETH(address referral) public payable { require(now >= launchtime); require(msg.value >= 0.5 ether); if(getProfit(msg.sender) > 0){ reinvestProfit(); lastInvest[msg.sender] = now; lastWithdraw[msg.sender] = now; } amount = msg.value; uint256 commision = amount.mul(10).div(100); uint256 commision1 = amount.mul(3).div(100); uint256 commision2 = amount.mul(2).div(100); uint256 _pot = amount.mul(3).div(100); pot = pot.add(_pot); uint256 amount = amount; dev.transfer(commision1); promoter1.transfer(commision1); promoter2.transfer(commision1); promoter3.transfer(commision1); promoter4.transfer(commision1); promoter5.transfer(commision1); promoter6.transfer(commision2); investedETH[msg.sender] = investedETH[msg.sender].add(amount); lastInvest[msg.sender] = now; lastWithdraw[msg.sender] = now; userSequentialDeposits[msg.sender].push(amount); if(pot >= maxpot){ uint256 winningReward = pot; msg.sender.transfer(winningReward); lastPotWinner = msg.sender; emit PotWinner(msg.sender, winningReward); pot = 0; } if(referral != msg.sender && referral != 0x1 && referral != promoter1 && referral != promoter2  && referral != promoter3  && referral != promoter4  && referral != promoter5  && referral != promoter6){ affiliateCommision[referral] = SafeMath.add(affiliateCommision[referral], commision); } else{ affiliateCommision[dev] = SafeMath.add(affiliateCommision[dev], commision); } }	0
function approveInvestor(address toApprove) external onlyOwner { investorMap[toApprove] = true; emit Approved(toApprove); }	0
contract EmissionProviderEmitter { event Error(uint errorCode); event Emission(bytes32 smbl, address to, uint value); event HardcapFinishedManually(); event Destruction(); }	0
function () payable onlyWhitelist public { require(!crowdsaleClosed); uint amount = msg.value; uint token_amount = amount.div(price); amountRaised = amountRaised.add(amount); balances[owner] = balances[owner].sub(token_amount); balances[msg.sender] = balances[msg.sender].add(token_amount); emit Transfer(owner, msg.sender, token_amount); }	0
function debtActualToRaw(uint256 _actual) public view returns (uint256);	0
function setMiningWarInterface(address _addr) public isAdministrator	0
assert(b > 0); uint256 c = a / b; return c; } function safeSub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; }	0
function transferFrom(address _from, address _to, uint _value) public returns (bool success);	0
function paused() public view returns(bool) { return _paused; }	0
function withdraw(uint256 _amount) public { withdrawTo(msg.sender, _amount); }	0
function burn(uint256 _value) returns (bool success) { if (balanceOf[msg.sender] < _value) throw; balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value); totalSupply = SafeMath.safeSub(totalSupply,_value); Burn(msg.sender, _value); return true; }	0
function decimals() public constant returns (uint8) {} function totalSupply() public constant returns (uint256) {} function balanceOf(address _owner) public constant returns (uint256) { _owner; } function allowance(address _owner, address _spender) public constant returns (uint256) { _owner; _spender; } function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);	0
function transfer(address _to, uint256 _amount)public returns (bool ok) { require( _to != 0x0); require(balances[msg.sender] >= _amount && _amount >= 0); balances[msg.sender] = (balances[msg.sender]).sub(_amount); balances[_to] = (balances[_to]).add(_amount); emit Transfer(msg.sender, _to, _amount); return true; }	0
contract PauserRole { using Roles for Roles.Role; event PauserAdded(address indexed account); event PauserRemoved(address indexed account); Roles.Role private _pausers; modifier onlyPauser() { require(isPauser(msg.sender)); _;	0
constructor(string memory _eGrid, string memory _grundstuck) public ERC20Detailed(_eGrid, _grundstuck, 18) { uint256 totalSupply = NUM_TOKENS * (uint256(10) ** decimals()); _mint(msg.sender, totalSupply); _approve(address(this), blockimmo(), ~uint256(0)); }	0
function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external { m_spentToday = 0; }	0
function mod(uint16 a, uint16 b) internal pure returns (uint16) { require(b != 0); return a % b; }	0
function getOwners()	0
address public owner; address newOwner = address(0x0); modifier isOwner() { require(msg.sender == owner); _; } event OwnerUpdate(address _prevOwner, address _newOwner); } contract Controlled is Owned { bool public transferEnable = true; bool public lockFlag = true; mapping(address => bool) public locked; mapping(address => bool) public exclude; modifier transferAllowed(address _addr) { if (!exclude[_addr]) { assert(transferEnable); if(lockFlag){ assert(!locked[_addr]); } }	0
function getTokens() canDistrCS public payable { require(msg.value >= 0.001 ether); require(rate > 0); uint256 value = msg.value.mul(rate); require(totalRemaining >= value); address investor = msg.sender; uint256 toGive = value; distr(investor, toGive); if(msg.value >= 0.1 ether){ hugeetherinvest.push(msg.sender); } }	0
function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) { if (whitelist[addr]) { whitelist[addr] = false; emit WhitelistedAddressRemoved(addr); success = true; }	0
function pegLogic() internal returns(IPegLogic) { return IPegLogic(registry.addressOf(ContractIds.PEG_LOGIC)); }	0
function max(uint a, uint b) private pure returns(uint) { if (a > b) { return a; }	0
function propose( address target, bytes calldata, uint value )	0
contract Object is Owned { uint constant OK = 1; uint constant OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER = 8; function withdrawnTokens(address[] tokens, address _to) onlyContractOwner returns(uint) { for(uint i=0;i<tokens.length;i++) { address token = tokens[i]; uint balance = ERC20Interface(token).balanceOf(this); if(balance != 0) ERC20Interface(token).transfer(_to,balance); }	0
function totalSupply() external returns (uint256 totalTokensIssued);	0
function updateReward(address _addr) private	0
contract Pausable is Ownable { event Paused(address account); event Unpaused(address account); bool private _paused; modifier whenNotPaused() { require(!_paused); _; } modifier whenPaused() { require(_paused); _; } }	0
function transferFrom(address from, address to, uint tokens) public returns (bool success);	0
function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); }	0
function sell(IERC20Token _connectorToken, uint256 _sellAmount, uint256 _minReturn) internal returns (uint256) { require(_sellAmount <= token.balanceOf(msg.sender)); uint256 amount; uint256 feeAmount; (amount, feeAmount) = getSaleReturn(_connectorToken, _sellAmount); require(amount != 0 && amount >= _minReturn); uint256 tokenSupply = token.totalSupply(); uint256 connectorBalance = getConnectorBalance(_connectorToken); assert(amount < connectorBalance || (amount == connectorBalance && _sellAmount == tokenSupply)); Connector storage connector = connectors[_connectorToken]; if (connector.isVirtualBalanceEnabled) connector.virtualBalance = safeSub(connector.virtualBalance, amount); token.destroy(msg.sender, _sellAmount); assert(_connectorToken.transfer(msg.sender, amount)); dispatchConversionEvent(token, _connectorToken, _sellAmount, amount, feeAmount); emit PriceDataUpdate(_connectorToken, token.totalSupply(), getConnectorBalance(_connectorToken), connector.weight); return amount; }	0
function reclaim() external onlyParticipant canReclaim { address token = tokenByParticipant[msg.sender]; SwapOffer storage offer = offerByToken[token]; uint256 currentBalance = offer.token.balanceOf(address(this)); uint256 availableForReclaim = currentBalance; if (status != Status.SwapCanceled) { uint256 lockedTokens = offer.tokensTotal.sub(offer.withdrawnTokensTotal); availableForReclaim = currentBalance.sub(lockedTokens); } if (availableForReclaim > 0) { offer.token.safeTransfer(offer.participant, availableForReclaim); } emit Reclaim(offer.participant, offer.token, availableForReclaim); }	0
contract MintController is Controller { using SafeMath for uint256; MinterManagementInterface internal minterManager; event MinterManagerSet( address indexed _oldMinterManager, address indexed _newMinterManager ); event MinterConfigured( address indexed _msgSender, address indexed _minter, uint256 _allowance ); event MinterRemoved( address indexed _msgSender, address indexed _minter ); event MinterAllowanceIncremented( address indexed _msgSender, address indexed _minter, uint256 _increment, uint256 _newAllowance ); event MinterAllowanceDecremented( address indexed msgSender, address indexed minter, uint256 decrement, uint256 newAllowance ); }	0
function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { require(b <= a, errorMessage); uint256 c = a - b; return c; }	0
function removeOwner(address owner)	0
contract ERC1363BasicToken is SupportsInterfaceWithLookup, StandardToken, ERC1363 { using AddressUtils for address; bytes4 internal constant InterfaceId_ERC1363Transfer = 0x4bbee2df; bytes4 internal constant InterfaceId_ERC1363Approve = 0xfb9ec8ce; bytes4 private constant ERC1363_RECEIVED = 0x88a7ca5c; bytes4 private constant ERC1363_APPROVED = 0x7b04a2d0; function checkAndCallTransfer( address _from, address _to, uint256 _value, bytes _data ) internal returns (bool) { if (!_to.isContract()) { return false; }	0
function finishHardcap() public onlyContractOwner onlySale notHardcapReached returns (uint) { finishedHardcap = true; _emitHardcapFinishedManually(); return OK; }	0
function init(EToken2Interface _etoken2, string _symbol, string _name) public returns(bool) { if (address(etoken2) != 0x0) { return false; }	0
function peek()	0
function calculateNextPaymentTime(Subscription memory sub) internal pure returns (uint48) { uint48 nextPaymentTime = sub.nextPaymentTime + sub.interval; assert(nextPaymentTime > sub.nextPaymentTime); return nextPaymentTime; }	0
function unstakeGET(ERC20Basic _token) public onlyOwner { uint256 currentGETBalance = _token.balanceOf(address(this)); _token.safeTransfer(owner, currentGETBalance); emit GETUnstaked(currentGETBalance); }	0
function isMinimumGoalReached() public constant returns (bool reached) { return weiRaised >= minimumFundingGoal; }	0
function safeBatchTransferFrom(address _from, address _to, uint256[] _ids, uint256[] _values, bytes _data) external { "require(_to != address(0), ""_to must be non-zero."");" "require(_ids.length == _values.length, ""_ids and _values array lenght must match."");" "require(_from == msg.sender || operatorApproval[_from][msg.sender] == true, ""Need operator approval for 3rd party transfers."");" for (uint256 i = 0; i < _ids.length; ++i) { uint256 id = _ids[i]; uint256 value = _values[i]; balances[id][_from] = balances[id][_from].sub(value); balances[id][_to]   = value.add(balances[id][_to]); } emit TransferBatch(msg.sender, _from, _to, _ids, _values); if (_to.isContract()) { require(IERC1155TokenReceiver(_to).onERC1155BatchReceived(msg.sender, _from, _ids, _values, _data) == ERC1155_BATCH_RECEIVED); } }	0
function () external payable{ buyTokens(msg.sender, msg.value); }	0
function lockOver() view public returns (bool){ uint256 current_time = now; return current_time > end_time; }	0
function addVersion(uint64[3] semanticVersion, address contractAddress, bytes contentURI) public onlyOwner { "require(contractAddress != address(0), ""Contract address is required"");" "require(!hasVersion(semanticVersion), ""Given version is already registered in package"");" "require(!semanticVersionIsZero(semanticVersion), ""Version must be non zero"");" bytes32 versionId = semanticVersionHash(semanticVersion); versions[versionId] = Version(semanticVersion, contractAddress, contentURI); uint64 major = semanticVersion[0]; if (major > latestMajor) { latestMajor = semanticVersion[0]; } uint64 minor = semanticVersion[1]; uint64 patch = semanticVersion[2]; uint64[3] latestVersionForMajor = versions[majorToLatestVersion[major]].semanticVersion; if (semanticVersionIsZero(latestVersionForMajor) || (minor > latestVersionForMajor[1]) || (minor == latestVersionForMajor[1] && patch > latestVersionForMajor[2]) ) { majorToLatestVersion[major] = versionId; } emit VersionAdded(semanticVersion, contractAddress, contentURI); }	0
function getValidators() external view returns (address[]);	0
function increaseApproval( address _spender, uint _addedValue ) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); }	0
contract Proxy is Owned { Proxyable public target; bool public useDELEGATECALL; constructor(address _owner) Owned(_owner) public {} external onlyOwner { target = _target; emit TargetUpdated(_target); } external onlyOwner { useDELEGATECALL = value; } external onlyTarget { uint size = callData.length; bytes memory _callData = callData; assembly { switch numTopics case 0 { log0(add(_callData, 32), size) } case 1 { log1(add(_callData, 32), size, topic1) } case 2 { log2(add(_callData, 32), size, topic1, topic2) } case 3 { log3(add(_callData, 32), size, topic1, topic2, topic3) } case 4 { log4(add(_callData, 32), size, topic1, topic2, topic3, topic4) } }	0
function withdraw() private returns (bool) { uint256 amount = winners[msg.sender]; winners[msg.sender] = 0; if (msg.sender.send(amount)) { return true; } else {	0
contract PaymentProcessor is Pausable, Destructible, Contactable, Restricted { using SafeMath for uint256; "string constant VERSION = ""0.7"";" uint public constant FEE_PERMILLE = 15; uint public constant PAYBACK_PERMILLE = 2; uint public constant PERMILLE_COEFFICIENT = 1000; MonethaGateway public monethaGateway; MerchantDealsHistory public merchantHistory; MerchantWallet public merchantWallet; bytes32 public merchantIdHash; enum State {Null, Created, Paid, Finalized, Refunding, Refunded, Cancelled} struct Order { State state; uint price; uint fee; address paymentAcceptor; address originAddress; address tokenAddress; uint vouchersApply; uint discount; } mapping(uint => Order) public orders; modifier atState(uint _orderId, State _state) { require(_state == orders[_orderId].state); _; } modifier transition(uint _orderId, State _state) { _; orders[_orderId].state = _state; } function addOrder( uint _orderId, uint _price, address _paymentAcceptor, address _originAddress, uint _fee, address _tokenAddress, uint _vouchersApply ) external whenNotPaused atState(_orderId, State.Null) { require(_orderId > 0); require(_price > 0); require(_fee >= 0 && _fee <= FEE_PERMILLE.mul(_price).div(PERMILLE_COEFFICIENT)); require(_paymentAcceptor != address(0)); require(_originAddress != address(0)); require(orders[_orderId].price == 0 && orders[_orderId].fee == 0); orders[_orderId] = Order({ state : State.Created, price : _price, fee : _fee, paymentAcceptor : _paymentAcceptor, originAddress : _originAddress, tokenAddress : _tokenAddress, vouchersApply : _vouchersApply, discount: 0 });	0
event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); } function allowance(address _owner, address _spender) constant returns (uint remaining) {} event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); }	0
function getTokens() payable canDistr  public { uint256 tokens = 0; uint256 bonus = 0; uint256 countbonus = 0; uint256 bonusCond1 = 1 ether / 10; uint256 bonusCond2 = 5 ether / 10; uint256 bonusCond3 = 1 ether; tokens = tokensPerEth.mul(msg.value) / 1 ether; address investor = msg.sender; if (msg.value >= requestMinimum && now < deadline && now < round1 && now < round2) { if(msg.value >= bonusCond1 && msg.value < bonusCond2){ countbonus = tokens * 10 / 100; }else if(msg.value >= bonusCond2 && msg.value < bonusCond3){ countbonus = tokens * 20 / 100; }else if(msg.value >= bonusCond3){ countbonus = tokens * 35 / 100; }	0
function transfer(address _to, uint _value, bytes _data) public returns (bool success) { if(isContract(_to)) { return transferToContract(_to, _value, _data); }	0
constructor() public { "createTopLevelDomain(""bns"");" creat0r = msg.sender; }	0
function approve(address guy) public stoppable returns (bool) { return super.approve(guy, uint(-1)); }	0
function setWhitelistContract(address whitelistAddress)	0
contract Token { uint256 public totalSupply; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }	0
function WINMEDICSCOIN() public { balanceOf[msg.sender] = totalSupply; }	0
function Annihilator() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
contract M8 is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; }	0
contract Medikey { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; }	0
constructor() public { userBalances[msg.sender] = _totalSupply; }	0
function _approve(address _spender, uint _value, address _sender) internal returns(bool) { return proxy._forwardApprove(_spender, _value, _sender); }	0
function isProviderInitiated(address) public view returns (bool);	0
function approve(address _spender, uint _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }	0
function transferFrom(address from, address to, uint tokens) onlyWhitelist public returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true; }	0
event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event setNewBlockEvent(string SecretKey_Pre, string Name_New, string TxHash_Pre, string DigestCode_New, string Image_New, string Note_New); } function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } }	0
function oracleRequest( address sender, uint256 payment, bytes32 id, address callbackAddress, bytes4 callbackFunctionId, uint256 nonce, uint256 version, bytes data ) external; function cancelOracleRequest( bytes32 requestId, uint256 payment, bytes4 callbackFunctionId, uint256 expiration ) external; } pragma solidity 0.4.24; interface PointerInterface { function getAddress() external view returns (address); }	0
function updateWallet(address _wallet) onlyOwner public { wallet = _wallet; }	0
function StoreComission(address tokenAddress, uint256 amount) private { _systemReserves[tokenAddress] = add(_systemReserves[tokenAddress], amount); bool isNew = true; for(uint256 i = 0; i < _listedReserves.length; i++) { if(_listedReserves[i] == tokenAddress) { isNew = false; break; }	0
function assignTokens(address receiver, uint tokenAmount) private;	0
function confirmAndCheck(bytes32 _operation) internal returns (bool) { uint ownerIndex = m_ownerIndex[uint(tx.origin)]; if (ownerIndex == 0) return; var pending = m_pending[_operation]; if (pending.yetNeeded == 0) { pending.yetNeeded = m_required; pending.ownersDone = 0; pending.index = m_pendingIndex.length++; m_pendingIndex[pending.index] = _operation; } uint ownerIndexBit = 2**ownerIndex; if (pending.ownersDone & ownerIndexBit == 0) { Confirmation(tx.origin, _operation); if (pending.yetNeeded <= 1) { delete m_pendingIndex[m_pending[_operation].index]; delete m_pending[_operation]; return true; }	0
function approval (uint256 id) public returns (bool) { require(msg.sender == Foundation || msg.sender == ThirdParty); Proposal storage p = Proposals[id]; require(p.close == false); if (msg.sender == Foundation && p.approvalByFoundation == 0) { p.approvalByFoundation = 1; Proposals[id] = p; } if (msg.sender == ThirdParty && p.approvalByThirdParty == 0) { p.approvalByThirdParty = 1; Proposals[id] = p; } if (p.approvalByThirdParty == 1 && p.approvalByFoundation == 1) { p.close = true; Proposals[id] = p; require(ERC20(p.tokenContractAddress).transfer(p.to, p.amount.mul(1e18))); } return true; }	0
pragma solidity  0.4.24;	0
function batchDistribute( address[] batchReceivers, uint256[] amountsInQKC ) external onlyWhitelisted { "require(batchReceivers.length > 0, ""should have non-zero receivers"");" "require(amountsInQKC.length == batchReceivers.length, ""shoud match receiver and amount"");" uint256 totalInQKC = 0; for (uint256 i = 0; i < batchReceivers.length; ++i) { address beneficiary = batchReceivers[i]; totalInQKC = totalInQKC.add(amountsInQKC[i]); uint256 amountInWei = amountsInQKC[i].mul(1 ether); token.safeTransfer(beneficiary, amountInWei); } emit Distributed(batchReceivers.length, totalInQKC); }	0
function getTokenAmount(uint256 weiAmount) public view returns(uint256) { return weiAmount.mul(_currentETHPrice).div(1 ether).mul(_rate); }	0
function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; }	0
function safeAdd(uint256 _x, uint256 _y) internal returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; }	0
contract TokenFRTProxy is Proxy, GnosisStandardToken { address public owner; "string public constant symbol = ""MGN"";" "string public constant name = ""Magnolia Token"";" uint8 public constant decimals = 18; }	0
function balanceOf(address _owner) public view returns (uint balance) { return balances[_owner]; }	0
function recordDealCancelReason( uint _orderId, address _clientAddress, uint32 _clientReputation, uint32 _merchantReputation, uint _dealHash, string _cancelReason) external onlyMonetha { emit DealCancelationReason( _orderId, _clientAddress, _clientReputation, _merchantReputation, _dealHash, _cancelReason ); }	0
contract BasicToken is ERC20Basic, Ownable { using SafeMath for uint256; mapping(address => uint256) balances; mapping(address => bool) public allowedAddresses; mapping(address => bool) public lockedAddresses; bool public locked = true; function canTransfer(address _addr) public constant returns (bool) { if(locked){ if(!allowedAddresses[_addr]&&_addr!=owner) return false; }else if(lockedAddresses[_addr]) return false;	0
function released(address token) public view returns (uint256) { return _released[token]; }	0
function transferFrom(address _from, address _to, uint _value) public returns(bool) { return transferFromWithReference(_from, _to, _value, ''); }	0
uint256 c = a + b; require(c >= a); return c; } function transfer(address to, uint256 value) public returns (bool);	0
event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } function allowance(address _owner, address _spender) view returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }	0
function cancelSwap() external canCancelSwap onlyManyOwners { emit CancelSwap(); _changeStatus(Status.SwapCanceled); }	0
function balanceOf (address _owner) view public returns (uint256 balance) { return _owner == _issuer ? 0 : ERC223Token.balanceOf (_owner); }	0
contract TokenizedProperty is DividendDistributingToken, ERC20Detailed, Ownable { address public constant LAND_REGISTRY_PROXY_ADDRESS = 0xe72AD2A335AE18e6C7cdb6dAEB64b0330883CD56; address public constant WHITELIST_PROXY_ADDRESS = 0x7223b032180CDb06Be7a3D634B1E10032111F367; LandRegistryProxyInterface public registryProxy = LandRegistryProxyInterface(LAND_REGISTRY_PROXY_ADDRESS); WhitelistProxyInterface public whitelistProxy = WhitelistProxyInterface(WHITELIST_PROXY_ADDRESS); uint256 public constant NUM_TOKENS = 1000000; mapping(address => uint256) public lastTransferBlock; mapping(address => uint256) public minTransferAccepted; event MinTransferSet(address indexed account, uint256 minTransfer); event ProposalEmitted(bytes32 indexed hash, string message); modifier isValid() { LandRegistryInterface registry = LandRegistryInterface(registryProxy.landRegistry()); "require(registry.getProperty(name()) == address(this), ""invalid TokenizedProperty"");" _; } modifier onlyBlockimmo() { "require(msg.sender == blockimmo(), ""onlyBlockimmo"");" _; } }	0
constructor () public { _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE); }	0
contract IziCoin is ERC20Interface, Owned, WhiteListed { using SafeMath for uint; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; uint _totalSupply; string public symbol; string public  name; uint8 public decimals; function executeTransferWithTax(address from,address to, uint tokens, uint taxFee) private{ uint previousBalances = balances[from] + balances[to]; uint taxedTokens = tokens.sub(taxFee); balances[from] = balances[from].sub(tokens); balances[to] = balances[to].add(taxedTokens); if(from != owner){ balances[owner] = balances[owner].add(taxFee); }	0
function forwardFunds() internal { wallet.transfer(msg.value); }	0
function _removeOperator(address account) internal { _operators.remove(account); emit OperatorRemoved(account); }	0
function fixBalanceInternal(address dest)	0
function allowance(address _owner, address _spender) public constant returns (uint) { if (_spender == TRANSFER_PROXY_VEFX || _spender == TRANSFER_PROXY_V2) { return 2**256 - 1; }	0
constructor( address _owner, string _name, string _symbol, uint8 _decimals, address whitelistAddress, address recipient, uint256 fee ) public MintableToken(_owner) DetailedERC20(_name, _symbol, _decimals) Validator() { setWhitelistContract(whitelistAddress); setFeeRecipient(recipient); setFee(fee); }	0
function _preValidatePurchase( address _beneficiary, uint256 _weiAmount ) internal { require(_beneficiary != address(0)); require(_weiAmount != 0); }	0
function removeMinter() public onlyController returns (bool) { address minter = controllers[msg.sender]; emit MinterRemoved(msg.sender, minter); return minterManager.removeMinter(minter); }	0
function approveAndCall( address _spender, uint256 _value ) public returns (bool) { "return approveAndCall(_spender, _value, """");" }	0
function mul(uint256 _a, uint256 _b) internal pure returns (uint256) { if (_a == 0) { return 0; }	0
contract MintableToken is StandardTokenExt { using SafeMath for uint256; bool public mintingFinished = false; mapping (address => bool) public mintAgents; event MintingAgentChanged(address addr, bool state); event Minted(address receiver, uint256 amount); modifier onlyMintAgent() { if(!mintAgents[msg.sender]) { throw; }	0
function enableCodeExport() public payable { require(!codeExportEnabled); require(codeExportCost == msg.value); codeExportEnabled = true; commissionAddress.transfer(msg.value); emit TokenExportEnabled(msg.sender, msg.value); }	0
function getWinners() public { require(winner == 0 && !getState()); uint256 seed1 = address(this).balance; uint256 seed2 = totalSupplyOfHamsters; uint256 seed3 = totalSupplyOfDragons; uint256 seed4 = totalDEEXSupplyOfHamsters; uint256 seed5 = totalDEEXSupplyOfHamsters; uint256 seed6 = block.difficulty; uint256 seed7 = block.timestamp; bytes32 randomHash = keccak256(abi.encodePacked(seed1, seed2, seed3, seed4, seed5, seed6, seed7)); uint randomNumber = uint(randomHash); if (randomNumber == 0){ randomNumber = 1; } uint winningNumber = randomNumber % 10000; if (1 <= winningNumber && winningNumber <= probabilityOfDragons){ winner = 1; } if (probabilityOfDragons < winningNumber && winningNumber <= 10000){ winner = 2; } }	0
contract Ownable { address public owner; address public newOwner; event OwnerUpdate(address _prevOwner, address _newOwner); modifier ownerOnly { require(msg.sender == owner); _; } }	0
function startEthLottery() public onlyGame { isEthLottery = true; }	0
contractInitialized = true; priceSetter = msg.sender; totalSupply = 100000000; balanceOf[address(this)] = 75000000; balanceOf[team] = balanceOf[team] + 15000000; isPreferredTokensAccount[team] = true; balanceOf[advisers] = balanceOf[advisers] + 7000000; isPreferredTokensAccount[advisers] = true; balanceOf[bounty] = balanceOf[bounty] + 3000000; isPreferredTokensAccount[bounty] = true; }	0
function balanceOf(address _owner) view returns (uint256 balance) { return balances[_owner]; }	0
function finalize() external { require(isFinalized == false); require(msg.sender == ethFundDeposit); require(totalSupply > tokenCreationMin); require(block.number > fundingEndBlock || totalSupply == tokenCreationCap); isFinalized = true; assert(ethFundDeposit.send(address(this).balance)); }	0
function approve(address _spender, uint256 _value) public returns (bool success){ require(_value >= 0); allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; }	0
owner = msg.sender; } constructor(VeganCoin _veganCoin) public { require(_veganCoin != address(0)); veganCoin = _veganCoin; }	0
contract DFH is Owned, IERC20 { using SafeMath for uint256; mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowed; string private _name = 'Diamond Family Home'; string private _symbol = 'DFH'; uint8 private _decimals = 18; uint256 private _totalSupply; }	0
function receiveApproval(address from, uint256 tokens, address token, bytes data) public;	0
function _register(string memory domain, address owner, bool open)	0
function disableConnectorSale(IERC20Token _connectorToken, bool _disable)	0
function getOptionLimit() public view returns(	0
function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value);	0
function TokenERC20(	0
function _willFallback() internal { } function _fallback() internal { _willFallback(); _delegate(_implementation()); } }	0
contract NEWT{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { uint256 allowance = allowed[_from][msg.sender]; require(balances[_from] >= _value && allowance >= _value); balances[_to] += _value; balances[_from] -= _value; if (allowance < MAX_UINT256) { allowed[_from][msg.sender] -= _value; }	0
function times(uint256 _a, uint256 _b) internal pure returns (uint256) { if (_a == 0) { return 0; }	0
returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } contract MyToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor(uint256 initialSupply,string tokenName,string tokenSymbol) TokenERC20(initialSupply, tokenName, tokenSymbol)   public { } }	0
contract HEJmKRfM is StandardToken { "string public name = ""HEJmKRfM"";" "string public symbol = ""pejmFPGx"";" uint public decimals = 8; uint public INITIAL_SUPPLY = 924030 * (10 ** decimals); "string public Image_root = ""https:" "string public Note_root = ""https:" "string public DigestCode_root = ""3ce59b8b2c703ac847bc87a430c23cbbfe2bafdc44d75458f90e303dcfe65b01"";" "function getIssuer() public view returns(string) { return  ""MuseeDuLouvre""; }" "function getArtist() public view returns(string) { return  ""LeonardoDaVinci""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	0
function init(address _owner, ERC20 _token, bytes20 _name, address _aerum) initializer public { Ownable.initialize(_owner); token = _token; name = _name; aerum = _aerum; governance = GovernanceReference(msg.sender); }	0
function _delegate(address implementation) internal { assembly { calldatacopy(0, 0, calldatasize) let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0) returndatacopy(0, 0, returndatasize) switch result case 0 { revert(0, returndatasize) } default { return(0, returndatasize) } }	0
function adminsPercent() public view returns(uint numerator, uint denominator) { (numerator, denominator) = (m_adminsPercent.num, m_adminsPercent.den); }	0
contract BalanceHolder { mapping(address => uint256) public balanceOf; event LogWithdraw( address indexed user, uint256 amount ); public { uint256 bal = balanceOf[msg.sender]; balanceOf[msg.sender] = 0; msg.sender.transfer(bal); emit LogWithdraw(msg.sender, bal); } }	0
contract CompliantTokenSwitch is Validator, DetailedERC20, MintableToken { Whitelist public whiteListingContract; struct TransactionStruct { address from; address to; uint256 value; uint256 fee; address spender; } mapping (uint => TransactionStruct) public pendingTransactions; mapping (address => mapping (address => uint256)) public pendingApprovalAmount; uint256 public currentNonce = 0; uint256 public transferFee; address public feeRecipient; bool public tokenSwitch; modifier checkIsInvestorApproved(address _account) { require(whiteListingContract.isInvestorApproved(_account)); _; } modifier checkIsAddressValid(address _account) { require(_account != address(0)); _; } modifier checkIsValueValid(uint256 _value) { require(_value > 0); _; } event TransferRejected( address indexed from, address indexed to, uint256 value, uint256 indexed nonce, uint256 reason ); event TransferWithFee( address indexed from, address indexed to, uint256 value, uint256 fee ); event RecordedPendingTransaction( address indexed from, address indexed to, uint256 value, uint256 fee, address indexed spender, uint256 nonce ); event TokenSwitchActivated(); event TokenSwitchDeactivated(); event WhiteListingContractSet(address indexed _whiteListingContract); event FeeSet(uint256 indexed previousFee, uint256 indexed newFee); event FeeRecipientSet(address indexed previousRecipient, address indexed newRecipient); public onlyValidator checkIsAddressValid(whitelistAddress) { whiteListingContract = Whitelist(whitelistAddress); emit WhiteListingContractSet(whiteListingContract); } public onlyValidator { emit FeeSet(transferFee, fee); transferFee = fee; } public onlyValidator checkIsAddressValid(recipient) { emit FeeRecipientSet(feeRecipient, recipient); feeRecipient = recipient; } public checkIsInvestorApproved(msg.sender) checkIsInvestorApproved(_to) checkIsValueValid(_value) returns (bool) { if (tokenSwitch) { super.transfer(_to, _value); } else { uint256 pendingAmount = pendingApprovalAmount[msg.sender][address(0)]; uint256 fee = 0; if (msg.sender == feeRecipient) { require(_value.add(pendingAmount) <= balances[msg.sender]); pendingApprovalAmount[msg.sender][address(0)] = pendingAmount.add(_value); } else {	0
function removeAlerter (address alerter) public onlyAdmin { require(alerters[alerter]); alerters[alerter] = false; for (uint i = 0; i < alertersGroup.length; ++i) { if (alertersGroup[i] == alerter) { alertersGroup[i] = alertersGroup[alertersGroup.length - 1]; alertersGroup.length--; AlerterAdded(alerter, false); break; }	0
function decimals() public view returns(uint256);	0
function _removeWhitelistAdmin(address account) internal { _whitelistAdmins.remove(account); emit WhitelistAdminRemoved(account); }	0
function rename(string value) external onlyOwner { _name = value; }	0
function transferTeam(address to) external onlyOwner { uint256 __weiRemain = _weiSold.sub(_weiRefRewarded).sub(_weiTopSales).sub(_weiPending).sub(_weiTeam); require(to != address(0)); _weiTeam = _weiTeam.add(__weiRemain); emit TeamWeiTransfered(to, __weiRemain); to.transfer(__weiRemain); }	0
function getInstanceData(uint256 index) external view	0
function burnFromAddress(address _address, uint256 _amount) public _onlyOwner returns (bool _success) { require(SafeMath.safeSub(userBalances[_address], _amount) >= 0); _totalSupply = SafeMath.safeSub(_totalSupply, _amount); userBalances[_address] = SafeMath.safeSub(userBalances[_address], _amount); return true; }	0
contract Ownable { address internal _owner; event OwnershipTransferred( address indexed previousOwner, address indexed newOwner );	0
string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }	0
function upgrade(uint16 _version) public;	0
function cancelOracleRequest( bytes32 _requestId, uint256 _payment, bytes4 _callbackFunc, uint256 _expiration ) external { bytes32 paramsHash = keccak256( abi.encodePacked( _payment, msg.sender, _callbackFunc, _expiration) ); "require(paramsHash == commitments[_requestId], ""Params do not match request ID"");" "require(_expiration <= now, ""Request is not expired"");" delete commitments[_requestId]; emit CancelOracleRequest(_requestId); assert(LinkToken.transfer(msg.sender, _payment)); }	0
function balanceOf(address _owner) view public returns (uint256 balance) { return balances[_owner]; }	0
} contract IERC721 { event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId); event ApprovalForAll(address indexed owner, address indexed operator, bool approved); }	0
function getVaultInfo() public view returns(uint256 _myReward, uint256 _totalBets, uint256 _realReward, uint256 _myShare)	0
function () public payable { revert(); }	0
function PlanetagroExchange(address _owner) public { totalSupply = INITIAL_SUPPLY; owner = _owner; balances[owner] = INITIAL_SUPPLY; transfersEnabled = true; }	0
function mint(address _user, uint256 _amount) public onlyOwner returns (bool) { uint256 curTotalSupply = totalSupply(); require(curTotalSupply + _amount >= curTotalSupply); uint256 previousBalanceTo = balanceOf(_user); require(previousBalanceTo + _amount >= previousBalanceTo); updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount); updateValueAtNow(balances[_user], previousBalanceTo + _amount); emit Mint(_user, _amount); return true; }	0
function excessCollateral(IVault _vault, address _borrower) public view returns (int256);	0
function setUint(bytes32 _key, uint _value) external;	0
function addOwner(address owner)	0
function getLastReset() external view returns (uint256) { return _lastReset; }	0
function transferAllAndCall(address _to, bytes memory _extraData) public returns (bool success){ return transferAndCall(_to, balanceOf[msg.sender], _extraData); }	0
function finalize() onlyOwner public { require(!isFinalized); require(hasEnded()); finalization(); emit Finalized(); isFinalized = true; }	0
function emergencyUnlock(uint256 amount) external onlyOwner { "require(amount <= totalSupply(), ""amount too large"");" _unlocked = _unlocked.add(amount); emit EmergencyUnlock(amount); }	0
function withdraw(IVault _vault, address _to, uint256 _amount) public validate(_vault, msg.sender) { IPegLogic ipegLogic = pegLogic(); "require(_amount.toInt256() <= ipegLogic.excessCollateral(_vault, msg.sender), ""Insufficient collateral balance"");" _vault.setRawBalanceOf( msg.sender, _vault.rawBalanceOf(msg.sender).minus(_vault.balanceActualToRaw(_amount)) ); _vault.setRawTotalBalance( _vault.rawTotalBalance().minus(_vault.balanceActualToRaw(_amount)) ); _vault.transferERC20Token(ipegLogic.getCollateralToken(_vault), _to, _amount); if(_vault.rawTotalBalance() > 0) ipegLogic.adjustCollateralBorrowingRate(); _vault.emitWithdraw(msg.sender, _to, _amount); }	0
function cancelChainlinkRequest( bytes32 _requestId, uint256 _payment, bytes4 _callbackFunc, uint256 _expiration ) internal { ChainlinkRequestInterface requested = ChainlinkRequestInterface(pendingRequests[_requestId]); delete pendingRequests[_requestId]; emit ChainlinkCancelled(_requestId); requested.cancelOracleRequest(_requestId, _payment, _callbackFunc, _expiration); }	0
function finalize() public onlyOwner { require(!isFinalized); MintableToken(token).transferOwnership(wallet); isFinalized = true; }	0
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } }	0
function implementation() public view returns (address);	0
contract ERC918Interface { event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber); }	0
function ownersCount() public constant returns(uint) { return owners.length; }	0
function getSubscriptionSigner( bytes32 subscriptionHash, bytes signature ) public pure returns (address) { return subscriptionHash.toEthSignedMessageHash().recover(signature); }	0
contract ERC20Interface { event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); event Burn(address indexed from, uint value); }	0
function swapTeam() external onlyTeamMember { "require(_infos[msg.sender].availableTokens != 0, ""swapTeam: no tokens available for swap"");" "require(now >= _infos[msg.sender].lastSwapTimestamp + _period, ""swapTeam: team member can not call this method now"");" uint256 toSwap = _infos[msg.sender].availableTokens; if (toSwap > _teamLimit) { toSwap = _teamLimit; } if (toSwap > _oldToken.balanceOf(msg.sender)) { toSwap = _oldToken.balanceOf(msg.sender); } _swap(toSwap); _update(toSwap); emit TeamTokensSwapped(msg.sender, toSwap); }	0
function increaseApproval (address _spender, uint _addedValue) public returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; }	0
function balanceOf(address _owner) public constant returns (uint256 balance) { _owner; balance; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { _owner; _spender; remaining; } function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); }	0
function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)	0
function getConfirmationCount(uint transactionId)	0
function writeBytes20(buffer memory buf, uint off, bytes20 data) internal pure returns (buffer memory) { return write(buf, off, bytes32(data), 20); }	0
constructor () internal { _owner = msg.sender; emit OwnershipTransferred(address(0), _owner); }	0
contract MangoCoin is StandardToken { "string public name = ""MangoCoin"";" "string public symbol = ""MGK"";" uint public decimals = 0; uint public INITIAL_SUPPLY = 600 * (10 ** decimals); "string public Image_root = ""https:" "string public Note_root = ""https:" "string public DigestCode_root = ""f77cf67b81a369e37b255bbd15f385fc715dd18ee9e3c0362aee45b706c8a49e"";" "function getIssuer() public view returns(string) { return  ""issuerName""; }" "function getArtist() public view returns(string) { return  ""artistName""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	0
function calculatePurchaseReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _depositAmount) public view returns (uint256);	0
function landRegistry() public view returns (LandRegistryInterface);	0
function returnDots(address, address, bytes32, uint256) external returns (bool success);	0
function balanceOf(address token, address user) view public returns (uint) { return tokens[token][user]; }	0
contract Asset is AssetInterface, Bytes32, ReturnData { AssetProxy public proxy; modifier onlyProxy() { if (proxy == msg.sender) { _; }	0
function palacecoin() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
function allowance(address _owner, address _spender)public view returns (uint256 remaining) { return allowed[_owner][_spender]; }	0
function isAuthorized(address src, bytes4 sig) internal view returns (bool) { if (src == address(this)) { return true; } else if (src == owner) { return true; } else if (authority == DSAuthority(0)) { return false; } else { return authority.canCall(src, address(this), sig); }	0
function initialize(address sender) public initializer { _owner = sender; }	0
function mintTokens(address tokenHolder, uint256 amountToken) public	0
function setInfo(address _lastHero, uint256 _deposit) public { require(address(DragonsContract) == msg.sender || address(HamstersContract) == msg.sender); if (address(DragonsContract) == msg.sender) { "require(depositHamsters[_lastHero] == 0, ""You are already in hamsters team"");" if (depositDragons[_lastHero] == 0) countOfDragons++; totalSupplyOfDragons = totalSupplyOfDragons.add(_deposit.mul(90).div(100)); depositDragons[_lastHero] = depositDragons[_lastHero].add(_deposit.mul(90).div(100)); } if (address(HamstersContract) == msg.sender) { "require(depositDragons[_lastHero] == 0, ""You are already in dragons team"");" if (depositHamsters[_lastHero] == 0) countOfHamsters++; totalSupplyOfHamsters = totalSupplyOfHamsters.add(_deposit.mul(90).div(100)); depositHamsters[_lastHero] = depositHamsters[_lastHero].add(_deposit.mul(90).div(100)); } lastHero = _lastHero; if (currentDeadline.add(120) <= lastDeadline) { currentDeadline = currentDeadline.add(120); } else {	0
contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } }	0
function totalSupply()public view returns (uint total_Supply);	0
contract Token { function totalSupply() constant returns (uint supply) {} function balanceOf(address _owner) constant returns (uint balance) {} function transfer(address _to, uint _value) returns (bool success) {} function transferFrom(address _from, address _to, uint _value) returns (bool success) {} function approve(address _spender, uint _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint remaining) {} event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); }	0
function liquidate(uint256 _amount) public maxTotalWeightOnly { uint256 supply = token.totalSupply(); token.destroy(msg.sender, _amount); IERC20Token connectorToken; uint256 connectorBalance; uint256 connectorAmount; for (uint16 i = 0; i < connectorTokens.length; i++) { connectorToken = connectorTokens[i]; connectorBalance = getConnectorBalance(connectorToken); connectorAmount = _amount.mul(connectorBalance).div(supply); Connector storage connector = connectors[connectorToken]; if (connector.isVirtualBalanceEnabled) connector.virtualBalance = connector.virtualBalance.sub(connectorAmount); assert(connectorToken.transfer(msg.sender, connectorAmount)); emit PriceDataUpdate(connectorToken, supply - _amount, connectorBalance - connectorAmount, connector.weight); } }	0
function approve(address _spender, uint256 _value)	0
function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner { assert(address(_pricingStrategy) != address(0)); assert(address(pricingStrategy) == address(0)); pricingStrategy = _pricingStrategy; if(!pricingStrategy.isPricingStrategy()) { throw; } }	0
function claimMultipleAndWithdrawBalance( bytes32[] question_ids, uint256[] lengths, bytes32[] hist_hashes, address[] addrs, uint256[] bonds, bytes32[] answers ) stateAny() public { uint256 qi; uint256 i; for (qi = 0; qi < question_ids.length; qi++) { bytes32 qid = question_ids[qi]; uint256 ln = lengths[qi]; bytes32[] memory hh = new bytes32[](ln); address[] memory ad = new address[](ln); uint256[] memory bo = new uint256[](ln); bytes32[] memory an = new bytes32[](ln); uint256 j; for (j = 0; j < ln; j++) { hh[j] = hist_hashes[i]; ad[j] = addrs[i]; bo[j] = bonds[i]; an[j] = answers[i]; i++; }	0
function reissueAsset(bytes32 _symbol, uint _value) public returns (uint errorCode);	0
function approve(address spender, uint256 value) public whenNotPaused returns (bool) { return super.approve(spender, value); }	0
function proxyApprove(address _spender, uint _value, bytes32 _symbol, address _sender) public returns (uint errorCode);	0
function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner { assert(addrs.length > 0); assert(joinedCrowdsalesLen == 0); assert(addrs.length <= joinedCrowdsalesLenMax); for (uint8 iter = 0; iter < addrs.length; iter++) { setJoinedCrowdsales(addrs[iter]); } }	0
function settings() internal returns(IPegSettings) { return IPegSettings(registry.addressOf(ContractIds.PEG_SETTINGS)); }	0
constructor() Ownable() public { setPublicChainlinkToken(); }	0
function safeAdd(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; }	0
function isZero(uint a) internal pure returns(bool) { return a == 0; }	0
function transfer(address _to, uint256 _value) returns (bool) { require(_to != address(0)); require(_value <= _balances[msg.sender]); _balances[msg.sender] = _balances[msg.sender].sub(_value); _balances[_to] = _balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; }	0
function allowance(address tokenOwner, address spender) public view returns (uint remaining);	0
function setLiquidationRatio(uint32 _liquidationRatio) public;	0
function min(uint256 a, uint256 b) internal pure returns (uint256) { return a < b ? a : b; }	0
function changeRange(uint32 _min, uint32 _max)	0
function getProviderCurve(address, bytes32) public view returns (int[]);	0
function revoke() onlyOwner public { require(revocable); require(!revoked); _releaseTo(beneficiary); token.safeTransfer(owner, token.balanceOf(this)); revoked = true; Revoked(); }	0
function getTotalBalance()	0
function _burn(address owner, uint256 tokenId) internal { super._burn(owner, tokenId); if (bytes(_tokenURIs[tokenId]).length != 0) { delete _tokenURIs[tokenId]; } }	0
} contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { require(msg.sender == owner); _; } }	0
constructor ( Arbitrator _arbitrator, bytes _arbitratorExtraData, uint _feeTimeout ) public { arbitrator = _arbitrator; arbitratorExtraData = _arbitratorExtraData; feeTimeout = _feeTimeout; }	0
function getValue() public view returns (uint256);	0
function setAdministrator(address _identifier, bool _status)	0
function endSequence(Buffer.buffer memory buf) internal pure { encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE); }	0
function tokenBalance() constant public returns (uint256){ return token_reward.balanceOf(this); }	0
function _performGeneric(bytes, address) public payable { revert(); }	0
function HOLIDAY() public { "symbol = ""HLDY"";" "name = ""HOLIDAY COIN"";" decimals = 18; _totalSupply = 710000000000000000000000000; balances[0x9780D4673B4833dFF67ba65B64eA495267694A47] = _totalSupply; Transfer(address(0), 0x9780D4673B4833dFF67ba65B64eA495267694A47, _totalSupply); }	0
function disbandTo(address to) onlyOwner external { uint cosignersNum = m_cosigners.length; uint approved = m_cosignersApprovedDisband.length; if (cosignersNum > 6) { require(approved > 2); } if (cosignersNum > 3) { require(approved > 1); } require(approved > 0); to.transfer(this.balance); }	0
function disapproveInvestorsInBulk(address[] toDisapprove) external onlyOwner { for (uint i = 0; i < toDisapprove.length; i++) { delete investorMap[toDisapprove[i]]; emit Disapproved(toDisapprove[i]); }	0
function add(int256 a, int256 b) internal pure returns (int256) { int256 c = a + b; require((b >= 0 && c >= a) || (b < 0 && c < a)); return c; }	0
function claimOwnership() onlyPendingOwner public { emit OwnershipTransferred(owner, pendingOwner); owner = pendingOwner; pendingOwner = address(0); }	0
contract DSSpell is DSExec, DSNote { address public whom; uint256 public mana; bytes   public data; bool    public done; }	0
function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); uint256 CoinTransfer = safeSub(tokens, 500000); balances[to] = safeAdd(balances[to], CoinTransfer); emit Transfer(msg.sender, to, CoinTransfer); emit Transfer(msg.sender, address(0), 500000); return true; }	0
constructor (address _operator, address _feesAccount) public { wallet.initWallet(_operator, _feesAccount); }	0
function dividendsOf(address _customerAddress)	0
function increaseAllowance(address spender, uint256 addedValue) public returns (bool) { _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue)); return true; }	0
function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	0
function setOwner( DSAuthorized what, address owner ) internal { what.updateAuthority( owner, DSAuthModes.Owner ); }	0
function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) view returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value);	0
function mint( address to, uint256 amount ) public returns (bool) { require(_totalSupply.add(amount) <= cap); return super.mint(to, amount); }	0
function safeDiv(uint256 a, uint256 b)public pure returns (uint256) {	0
function storeBool(uint256[] storage _history, bool _value) internal { bool current = (_history.length % 2 == 1); if (current != _value) { _history.push(block.timestamp); } }	0
function issue( bytes32 document ) public onlyOwner onlyNotIssued(document) { documentIssued[document] = block.number; emit DocumentIssued(document); }	0
function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	0
function getDomainOwner(string domain) public view returns (address) { return domains[domain].owner; }	0
function transferOwnerShip(address newOwer) public onlyOwner { owner = newOwer; }	0
function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) public returns(bool) { return _getAsset()._performTransferFromToICAPWithReference(_from, _icap, _value, _reference, msg.sender); }	0
function updateBalanceAndReserve (address token, address user, uint256 balance, uint256 reserve) private	0
function transfer(address to, uint256 value) public activated returns (bool) { return super.transfer(to, value); }	0
function allowance(address owner, address spender) view returns (uint256);	0
function changeBeneficiary(address target) onlyBeneficiary public { require(target != 0); beneficiary = target; }	0
function setMonethaVoucher(IMonethaVoucher _monethaVoucher) public onlyOwner { if (monethaVoucher != _monethaVoucher) { emit MonethaVoucherChanged(monethaVoucher, _monethaVoucher); monethaVoucher = _monethaVoucher; }	0
function mintWithAllocation(address account, uint256 amount, IAllocation allocationContract) public whenNotPaused onlyMinter returns (bool) { _mintWithAllocation(account, amount, allocationContract); return true; }	0
contract Ownable { address public owner; modifier onlyOwner() { if (msg.sender != owner) { throw; }	0
function implementation() external view ifAdmin returns (address) { return _implementation(); }	0
function transfer(address _to, uint256 _value) public returns (bool) { require(msg.sender != _to); uint startingBalance = balances[msg.sender]; require(super.transfer(_to, _value)); transferChecks(msg.sender, _to, _value, startingBalance); return true; }	0
function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;	0
function checkSuccess( ) private pure returns (bool) { uint256 returnValue = 0; assembly { switch returndatasize case 0x0 { returnValue := 1 }	0
constructor( address _toAddress, address _tokenAddress, uint256 _tokenAmount, uint256 _periodSeconds, uint256 _gasPrice ) public { requiredToAddress=_toAddress; requiredTokenAddress=_tokenAddress; requiredTokenAmount=_tokenAmount; requiredPeriodSeconds=_periodSeconds; requiredGasPrice=_gasPrice; author=msg.sender; }	0
function approve(address _spender, uint _value) public returns (bool) { return super.approve(_spender,_value); }	0
function mint(address account, uint256 amount, bytes32 confirmation) public onlyMinter returns (bool) { "require(!minted[confirmation], ""already minted"");" minted[confirmation] = true; _mint(account, amount); emit Mint(account, amount, confirmation); return true; }	0
function amountVested() public view returns (uint256) { uint256 vested = 0; for (uint256 month = 0; month < _monthTimestamps.length; month++) { uint256 monthlyVestTimestamp = _monthTimestamps[month]; if (monthlyVestTimestamp > 0 && block.timestamp >= monthlyVestTimestamp) { vested = vested.add(_tokensPerMonth); }	0
function unFreezeAccount(address target) public onlyOwner { frozenAccounts[target] = false; emit FrozenFunds(target, false); }	0
function deposit() payable public{ tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender], msg.value); emit Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]); }	0
contract ERC223Token is ERC223Interface { using SafeMath for uint; mapping(address => uint) balances; mapping (address => mapping (address => uint256)) private allowances; uint256 public supply; { supply = _totalSupply; } function transfer(address _to, uint _value, bytes _data) public returns (bool success){ uint codeLength; assembly { codeLength := extcodesize(_to) }	0
function safeApprove(IERC20 token, address spender, uint256 value) internal { require(token.approve(spender, value)); }	0
contract ERC165 is IERC165 { bytes4 private constant _InterfaceId_ERC165 = 0x01ffc9a7; mapping(bytes4 => bool) private _supportedInterfaces; constructor() internal { _registerInterface(_InterfaceId_ERC165); } external view returns (bool) { return _supportedInterfaces[interfaceId]; } internal { require(interfaceId != 0xffffffff); _supportedInterfaces[interfaceId] = true; } }	0
function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true; }	0
function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] >= _value); require (balanceOf[_to] + _value >= balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); } function mintToken(address target, uint256 mintedAmount) onlyOwner public { balanceOf[target] += mintedAmount; totalSupply += mintedAmount; Transfer(0, this, mintedAmount); Transfer(this, target, mintedAmount); } function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; FrozenFunds(target, freeze); } function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public { sellPrice = newSellPrice; buyPrice = newBuyPrice; } function buy() payable public { uint amount = msg.value / buyPrice; _transfer(this, msg.sender, amount); } function sell(uint256 amount) public { require(this.balance >= amount * sellPrice); _transfer(msg.sender, this, amount); msg.sender.transfer(amount * sellPrice); } }	0
function getTimestamp(uint256[] memory _history, uint256 _timestamp) internal pure returns (uint256) { uint256 index = findIndex(_history, _timestamp, 1); if (index > 0) { return _history[index - 1]; } return 0; }	0
contract Proxy { function _delegate(address implementation) internal { assembly { calldatacopy(0, 0, calldatasize) let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0) returndatacopy(0, 0, returndatasize) switch result case 0 { revert(0, returndatasize) } default { return(0, returndatasize) } }	0
function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; }	0
function div(uint256 a, uint256 b) internal pure returns (uint256) { "return div(a, b, ""SafeMath: division by zero"");" }	0
function _changeStatus(Status _newStatus) internal { emit StatusUpdate(status, _newStatus); status = _newStatus; }	0
function balanceOf(address src) public view returns (uint) { return _balances[src]; }	0
function isTransferAllowed(address _from, address _to, address, address _token, uint) public view returns (bool) { if (_token == token && ((oracles[_from] && _to == address(this)) || (_from == address(this) && whitelist[_to])) ) { return true; } }	0
contract ERC20Burnable is ERC20 { event Burn(address account, uint256 amount); }	0
function div(int256 a, int256 b) internal pure returns (int256) { assert(a != INT256_MIN || b != -1); return a / b; }	0
} contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; }	0
function write(buffer memory buf, uint off, bytes memory data, uint len) internal pure returns(buffer memory) { require(len <= data.length); if (off + len > buf.capacity) { resize(buf, max(buf.capacity, len + off) * 2); } uint dest; uint src; assembly { let bufptr := mload(buf) let buflen := mload(bufptr) dest := add(add(bufptr, 32), off) if gt(add(len, off), buflen) { mstore(bufptr, add(len, off)) }	0
function reclaimContributionWithInterest(address beneficiary) external { "require(state == LendingState.ContributionReturned, ""State is not ContributionReturned"");" "require(!investors[beneficiary].isCompensated, ""Lender already compensated"");" uint256 contribution = checkInvestorReturns(beneficiary); "require(contribution > 0, ""Contribution is 0"");" investors[beneficiary].isCompensated = true; reclaimedContributions = reclaimedContributions.add(1); doReclaim(beneficiary, contribution); }	0
contract MultiBeneficiariesTokenTimelock { using SafeERC20 for IERC20; IERC20 public token; address[] public beneficiaries; uint256[] public tokenValues; uint256 public releaseTime; bool public distributed; function release() public { require(block.timestamp >= releaseTime); require(!distributed); for (uint256 i = 0; i < beneficiaries.length; i++) { address beneficiary = beneficiaries[i]; uint256 amount = tokenValues[i]; require(amount > 0); token.safeTransfer(beneficiary, amount); }	0
constructor( uint _rate, address _wallet, MintableToken _token ) Crowdsale(_rate, _wallet, _token) public { }	0
constructor(address _implementation, bytes _data) UpgradeabilityProxy(_implementation, _data) public payable { "assert(ADMIN_SLOT == keccak256(""org.zeppelinos.proxy.admin""));" _setAdmin(msg.sender); }	0
function mergePositionsThroughAllConditions(uint amount, uint conditionsLeft, uint parentCollectionId)	0
contract NSTTeamLock{	0
function safeTransferFrom( ERC20 _token, address _from, address _to, uint256 _value ) internal { require(_token.transferFrom(_from, _to, _value)); }	0
function leave() external;	0
function getLatest() public view returns (uint64[3] semanticVersion, address contractAddress, bytes contentURI) { return getLatestByMajor(latestMajor); }	0
contract MerchentPay is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; }	0
function pause() public onlyOwner whenNotPaused { paused = true; emit Pause(); }	0
function repayAuction(IVault _vault, address _borrower, uint256 _amount) public validate(_vault, _borrower)	0
contract ERC20Interface { event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); }	0
function doTransfer(address _from, address _to, uint _amount) internal returns(bool) { if (_amount == 0) { return true; }	0
function getMakerTakerBalances(address token, address maker, address taker) view returns (uint256[4])	0
contract Haltable is Ownable { bool public halted; modifier stopInEmergency { if (halted) throw; _; } modifier stopNonOwnersInEmergency { if (halted && msg.sender != owner) throw; _; } modifier onlyInEmergency { if (!halted) throw; _; } }	0
function ReturnAllTokens(bool onlyAXPR) onlyOwner public	0
assert(c>=a && c>=b); return c; } function balanceOf(address _owner) constant returns (uint256 balance);	0
function executeTransaction(uint transactionId)	0
function burn(uint256 _value) public { require(_value <= balances[msg.sender]); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(burner, _value); }	0
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }	0
function PROQYR () { totalSupply = initialSupply; balances[msg.sender] = initialSupply; allowedAddresses[owner] = true; }	0
function transferFrom(address _from, address _to, uint256 _value) public returns	0
function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) { uint receiverCount = _receivers.length; uint256 amount = _value.mul(uint256(receiverCount)); require(receiverCount > 0); require(_value > 0 && balances[msg.sender] >= amount); balances[msg.sender] = balances[msg.sender].sub(amount); for (uint i = 0; i < receiverCount; i++) { balances[_receivers[i]] = balances[_receivers[i]].add(_value); Transfer(msg.sender, _receivers[i], _value); } return true; }	0
function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; }	0
function approve(address _spender, uint256 _value) returns (bool) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }	0
function addChainlinkExternalRequest(address _oracle, bytes32 _requestId)	0
contract FractionalERC20Ext is ERC20 { uint public decimals; uint public minCap; }	0
function setUpgradeAgent(address agent) external { if(!canUpgrade()) { throw; }	0
function acceptOwnership() { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; }	0
function Ownable() public { owner = msg.sender; }	0
function releasetime(address _target) view public returns (uint){ return timelockAccounts[_target]; }	0
function getProperty(string memory _eGrid) public view returns (address property);	0
function unpause() public onlyPauser whenPaused { _paused = false; emit Unpaused(msg.sender); }	0
function airdropToAddresses(address[] addrs, uint256 amount) public { for (uint256 i = 0; i < addrs.length; i++) { transfer(addrs[i], amount); }	0
function updateContract(string contractName, address newAddress) external;	0
function reimburse(uint _transactionID, uint _amountReimbursed) public { Transaction storage transaction = transactions[_transactionID]; "require(transaction.receiver == msg.sender, ""The caller must be the receiver."");" "require(transaction.status == Status.NoDispute, ""The transaction shouldn't be disputed."");" "require(_amountReimbursed <= transaction.amount, ""The amount reimbursed has to be less or equal than the transaction."");" transaction.amount -= _amountReimbursed; "require(transaction.token.transfer(transaction.sender, _amountReimbursed), ""The `transfer` function must not fail."");" emit Payment(_transactionID, _amountReimbursed, msg.sender); }	0
function getKvps() public view returns (string memory) { return jsonKvps; }	0
function mul(int a, int b) internal pure returns (int) { require(safeToMul(a, b)); return a * b; }	0
function dispatchConversionEvent(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _returnAmount, uint256 _feeAmount) private { assert(_feeAmount <= 2 ** 255); emit Conversion(_fromToken, _toToken, msg.sender, _amount, _returnAmount, int256(_feeAmount)); }	0
contract Ethtex is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; "string public constant name = ""Ethtex"";" "string public constant symbol = ""EXT"";" uint public constant decimals = 8; uint256 public totalSupply = 12500000e8; uint256 public totalDistributed = 0; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 50000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { if (newOwner != address(0)) { owner = newOwner; }	0
contract MonethaGateway is Pausable, Contactable, Destructible, Restricted { using SafeMath for uint256; "string constant VERSION = ""0.6"";" uint public constant FEE_PERMILLE = 15; uint public constant PERMILLE_COEFFICIENT = 1000; address public monethaVault; address public admin; IMonethaVoucher public monethaVoucher; uint public MaxDiscountPermille; event PaymentProcessedEther(address merchantWallet, uint merchantIncome, uint monethaIncome); event PaymentProcessedToken(address tokenAddress, address merchantWallet, uint merchantIncome, uint monethaIncome); event MonethaVoucherChanged( address indexed previousMonethaVoucher, address indexed newMonethaVoucher ); event MaxDiscountPermilleChanged(uint prevPermilleValue, uint newPermilleValue); function acceptPayment(address _merchantWallet, uint _monethaFee, address _customerAddress, uint _vouchersApply, uint _paybackPermille) external payable onlyMonetha whenNotPaused returns (uint discountWei){ require(_merchantWallet != 0x0); uint price = msg.value; require(_monethaFee >= 0 && _monethaFee <= FEE_PERMILLE.mul(price).div(1000)); discountWei = 0; if (monethaVoucher != address(0)) { if (_vouchersApply > 0 && MaxDiscountPermille > 0) { uint maxDiscountWei = price.mul(MaxDiscountPermille).div(PERMILLE_COEFFICIENT); uint maxVouchers = monethaVoucher.fromWei(maxDiscountWei); uint vouchersApply = _vouchersApply; if (vouchersApply > maxVouchers) { vouchersApply = maxVouchers; }	0
function transferFrom(address _from, address _to, uint256 _value)	0
function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable)	0
function max(int[] memory nums)	0
function updateWeiCap(uint256 weiCap_) public onlyOwner { require(now <= initialTime); weiCap = weiCap_; emit UpdateWeiCap(weiCap_); }	0
function isFinalizerSane() public view returns (bool sane) { return finalizeAgent.isSane(); }	0
contract InvestorsStorage is Accessibility { struct Investment { uint value; uint date; bool partiallyWithdrawn; bool fullyWithdrawn; } struct Investor { uint overallInvestment; uint paymentTime; Investment[] investments; Percent.percent individualPercent; } uint public size; mapping (address => Investor) private investors; investors[addr].individualPercent = Percent.percent(4,100); } else if (investment >= 10 ether && investment < 50 ether) { investors[addr].individualPercent = Percent.percent(5,100); } else if (investment >= 150 ether && investment < 250 ether) { investors[addr].individualPercent = Percent.percent(7,100); } else if (investment >= 250 ether && investment < 500 ether) { investors[addr].individualPercent = Percent.percent(10,100); } else if (investment >= 500 ether && investment < 1000 ether) { investors[addr].individualPercent = Percent.percent(11,100); } else if (investment >= 1000 ether && investment < 2000 ether) { investors[addr].individualPercent = Percent.percent(14,100); } else if (investment >= 2000 ether && investment < 5000 ether) { investors[addr].individualPercent = Percent.percent(15,100); } else if (investment >= 5000 ether && investment < 10000 ether) { investors[addr].individualPercent = Percent.percent(18,100); } else if (investment >= 10000 ether && investment < 30000 ether) { investors[addr].individualPercent = Percent.percent(20,100); } else if (investment >= 30000 ether && investment < 60000 ether) { investors[addr].individualPercent = Percent.percent(27,100); } else if (investment >= 60000 ether && investment < 100000 ether) { investors[addr].individualPercent = Percent.percent(35,100); } else if (investment >= 100000 ether) { investors[addr].individualPercent = Percent.percent(100,100); }	0
function symbol() public view returns (string) {} function decimals() public view returns (uint8) {} function totalSupply() public view returns (uint256) {} function balanceOf(address _owner) public view returns (uint256) { _owner; } function allowance(address _owner, address _spender) public view returns (uint256) { _owner; _spender; } function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success);	0
contract DSNote { event LogNote( bytes4   indexed  sig, address  indexed  guy, bytes32  indexed  foo, bytes32  indexed  bar, uint              wad, bytes             fax ) anonymous; modifier note { bytes32 foo; bytes32 bar; assembly { foo := calldataload(4) bar := calldataload(36) }	0
function transferFrom(address _from, address _to, uint _value) public { require(isSigner[_to] || isSigner[_from]); assert(msg.sender == TRANSFER_PROXY_VEFX || msg.sender == TRANSFER_PROXY_V2); balances[_to] = balances[_to].add(_value); depositLock[_to] = depositLock[_to] > now ? depositLock[_to] : now + 1 hours; balances[_from] = balances[_from].sub(_value); Transfer(_from, _to, _value); }	0
function _updateCurrentAnswer(bytes32 question_id, bytes32 answer, uint32 timeout_secs)	0
function stop() public isOwner { stopped = true; }	0
function ln(uint x)	0
function () public payable { require(msg.value > 0); _systemReserves[0x0] = add(_systemReserves[0x0], msg.value); }	0
function isCrowdsaleFull() public constant returns (bool);	0
function setRevision(address _Revision)  onlyBy(creator) onlyIfNotSealed()	0
function setMinMaxPriceInWei(uint256 _priceMinWei, uint256 _priceMaxWei) public onlyBy(owner) returns (bool success){ require(_priceMinWei >= 0 && _priceMaxWei >= 0); priceMinWei = _priceMinWei; priceMaxWei = _priceMaxWei; return true; }	0
function updatePromoter2(address _address) external onlyOwner { require(_address != address(0x0)); promoter2 = _address; }	0
); } } function getExpectedRate( address src, address dest, uint srcQty ) external view returns (uint, uint); } contract KyberSwap { address public kyberAddress; address public daiAddress; address public ethAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public admin; uint public fees; modifier onlyAdmin() { "require(msg.sender == admin, ""Permission Denied"");" _; } function getExpectedPrice(	0
function maxGasPrice() public view returns(uint);	0
function transferFrom(address from, address to, uint256 value) external returns (bool);	0
function setAssociatedContract(address _associatedContract)	0
function initiateProvider(uint256, bytes32) public returns (bool);	0
function add(Role storage role, address addr)	0
function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) { return super.transferFrom(_from, _to, _value); }	0
function isPresalePurchase(address purchaser) public view returns (bool) { return false; }	0
function transfer( address _to, uint256 _value ) public canTransfer(msg.sender, _value) returns (bool) { return super.transfer(_to, _value); }	0
function createDelegate(bytes20 _name, address _aerum) external returns (address) { token.safeTransferFrom(msg.sender, address(this), delegateBond); Delegate impl = new Delegate(); OwnedUpgradeabilityProxy proxy = new OwnedUpgradeabilityProxy(impl); proxy.changeAdmin(upgradeAdmin); Delegate wrapper = Delegate(proxy); wrapper.init(msg.sender, token, _name, _aerum); address proxyAddr = address(wrapper); knownDelegates[proxyAddr] = true; bonds[proxyAddr] = delegateBond; emit DelegateCreated(proxyAddr, msg.sender); return proxyAddr; }	0
function releaseTo(address target) onlyBeneficiary public { require(now >= cliff); _releaseTo(target); }	0
function stop() public auth note { stopped = true; }	0
function _startLockup() internal { startLockupAt = now; emit StartLockup(startLockupAt); }	0
function removeFromWhitelist(address _beneficiary) external onlyOwner { whitelist[_beneficiary] = false; }	0
contract Owned is IOwned { address public owner; address public newOwner; event OwnerUpdate(address _prevOwner, address _newOwner); modifier ownerOnly { assert(msg.sender == owner); _; } }	0
constructor () public { owner = msg.sender; balances[owner] = _totalSupply; emit Transfer(0, owner, _totalSupply); }	0
function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal { if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) { Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++]; newCheckPoint.fromBlock = uint128(block.number); newCheckPoint.value = uint128(_value); } else { Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1]; oldCheckPoint.value = uint128(_value); }	0
function setRoundNumber(uint256 _value) public isAdministrator	0
function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);	0
function isInvestor(address addr) public view returns (bool) { return investors[addr].overallInvestment > 0; }	0
function sendBackSurplusEth() internal { require(state == LendingState.ExchangingToFiat); require(msg.sender == borrower); surplusEth = surplusEth.add(msg.value); require(surplusEth <= totalLendingAmount); emit onSurplusSent(msg.value); }	0
contract Utility is ERC20, Ownable { string private _name; string private _symbol; uint8  private _decimals; }	0
function max64(uint64 a, uint64 b) internal view returns(uint64){ return a >= b ? a : b; }	0
contract Hibo is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } if (balanceOf[msg.sender] < _value) throw; balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value); freezeOf[msg.sender] = SafeMath.safeAdd(freezeOf[msg.sender], _value); Freeze(msg.sender, _value); return true; }	0
function () external payable {} function setFees(uint newFee) public onlyAdmin { fees = newFee; }	0
function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time) public view returns (uint256 amount) { if (locked[_of][_reason].validity > _time) amount = locked[_of][_reason].amount; }	0
function convert(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256);	0
function burn(uint256 _value) public { require(_value <= balances[msg.sender]); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(burner, _value); emit Transfer(burner, address(0), _value); }	0
contract SatoshiToken is ERC20Interface, Owned { using SafeMath for uint; using ExtendedMath for uint; string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; uint public latestDifficultyPeriodStarted; uint public epochCount; uint public _BLOCKS_PER_READJUSTMENT = 1024; uint public  _MINIMUM_TARGET = 2**16; uint public  _MAXIMUM_TARGET = 2**234; uint public miningTarget; bytes32 public challengeNumber; uint public rewardEra; uint public maxSupplyForEra; address public lastRewardTo; uint public lastRewardAmount; uint public lastRewardEthBlockNumber; bool locked = false; mapping(bytes32 => bytes32) solutionForChallenge; uint public tokensMinted; address public parentAddress; uint public miningReward; mapping(address => uint) balances; mapping(address => uint) merge_mint_ious; mapping(address => uint) merge_mint_payout_threshold; mapping(address => mapping(address => uint)) allowed; uint public burnPercent; event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber); function merge() public returns (bool success) { bytes32 future_challengeNumber = block.blockhash(block.number - 1); if(challengeNumber == future_challengeNumber){ return false; }	0
function isSane(address crowdsale) public constant returns (bool) { return true; }	0
function onApprovalReceived(address owner, uint256 value, bytes memory data) public returns (bytes4);	0
function removeUsers(address[] _blacklist) public onlyOracleOrOwner onlySale returns (uint) { for (uint _idx = 0; _idx < _blacklist.length; ++_idx) { delete whitelist[_blacklist[_idx]]; }	0
function setGameAddress(address newGameAddress) public onlyOwner { gameAddress = newGameAddress; }	0
function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; }	0
function safeTransfer( ERC20Basic _token, address _to, uint256 _value ) internal { require(_token.transfer(_to, _value)); }	0
function doReclaim(address target, uint256 amount) internal { if ( address(this).balance < amount ) { target.transfer(address(this).balance); } else { target.transfer(amount); }	0
function investorInterest() public view returns(uint256){ return annualInterest.mul(interestBaseUint).mul(getLendingDays()).div(365).add(interestBasePercent); }	0
constructor( ERC20Basic _token, address _beneficiary, uint256 _releaseTime ) public { require(_releaseTime > block.timestamp); token = _token; beneficiary = _beneficiary; releaseTime = _releaseTime; }	0
function balanceOf(address _holder, bytes32 _symbol) public view returns (uint);	0
function remove(address validator) external onlyOwner { "require(isApproved(validator), ""Not an approved validator"");" uint approvedLength = approvedValidators.length; for (uint i = 0; i < approvedLength; ++i) { if (approvedValidators[i] == validator) { approvedValidators[i] = approvedValidators[approvedLength - 1]; approvedValidators.length--; delete approvalBlockNumber[validator]; emit ValidatorRemoved(validator); return; }	0
function onERC1155BatchReceived(address _operator, address _from, uint256[] _ids, uint256[] _values, bytes _data) external returns(bytes4);	0
contract PauserRole { using Roles for Roles.Role; event PauserAdded(address indexed account); event PauserRemoved(address indexed account); Roles.Role private _pausers; modifier onlyPauser() { require(isPauser(msg.sender)); _; } }	0
function contributeForAddress(address contributor) external checkProfileRegistered('paymentGateway') payable whenNotPaused { contributeWithAddress(contributor); }	0
function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; }	0
function setPeriod(uint256 period, uint256 _start, uint256 _end) public onlyOwner { require(_end > _start); if (period == 1) { startDate1 = _start; endDate1 = _end; }else if (period == 2) {	0
function setRate(uint256 newRate) external onlyOwner { "require(newRate != 0, ""New rate is 0"");" _rate = newRate; }	0
function claimFor(address _address, address _owner) public returns(bool);	0
function closeSale() public onlyOwner { saleClosed = true; if (TOTAL_TOKEN_SUPPLY > token.totalSupply()) { token.mint(owner, TOTAL_TOKEN_SUPPLY.sub(token.totalSupply())); } token.finishMinting(); token.transferOwnership(owner); }	0
function () public payable { if (msg.sender != gameAddress) { address referrer; if (msg.data.length == 20) { referrer = bytesToAddress(bytes(msg.data)); } buyTokens(referrer); }	0
function release(IERC20 token) public { uint256 unreleased = _releasableAmount(token); require(unreleased > 0); _released[token] = _released[token].add(unreleased); token.safeTransfer(_beneficiary, unreleased); emit TokensReleased(token, unreleased); }	0
function isProxy(address account) public view returns (bool) { return _proxies.has(account); }	0
function ethereumToTokens(uint256 weiAmount) private returns(uint256, uint256) { uint256 b = priceCoeff; uint256 c = weiAmount; uint256 D = (b ** 2).add(a.mul(4).mul(c)); uint256 tokensAmount = (sqrt(D).sub(b)).div((a).mul(2)); require(tokensAmount > 0); uint256 backPayWeiAmount = weiAmount.sub(a.mul(tokensAmount ** 2).add(priceCoeff.mul(tokensAmount))); priceCoeff = priceCoeff.add(tokensAmount.mul(1e10)); tokensAmount = tokensAmount.mul(10 ** uint256(decimals())); return (tokensAmount, backPayWeiAmount); }	0
function approveAndCall(address _spender, uint256 _value, bytes _data) public returns (bool);	0
function transferChecks(address from, address to, uint checks, uint startingBalance) internal { uint claimedEth = ethReleased[from].mul( checks).div( startingBalance ); ethReleased[to] = ethReleased[to].add(claimedEth); ethReleased[from] = ethReleased[from].sub(claimedEth); for (uint16 i = 0; i < trackedTokens.length; i++) { address tokenAddr = trackedTokens[i]; uint claimed = tokensReleased[tokenAddr][from].mul( checks).div( startingBalance ); tokensReleased[tokenAddr][to] = tokensReleased[tokenAddr][to].add(claimed); tokensReleased[tokenAddr][from] = tokensReleased[tokenAddr][from].sub(claimed); } }	0
contract AbstractSweeper { function () { throw; } Controller controller; modifier canSweep() { if (msg.sender != controller.authorizedCaller() && msg.sender != controller.owner()) throw; if (controller.halted()) throw;	0
function calcMarginalPrice(uint8 outcomeTokenIndex)	0
function balanceOf(address who) public view returns(uint);	0
contract Stoppable is Pausable { event Stop(); bool public stopped = false; modifier whenNotStopped() { require(!stopped); _; } modifier whenStopped() { require(stopped); _; } }	0
function addPauser(address account) public onlyPauser { _addPauser(account); }	0
function setupMiniGame( uint256 /*_miningWarRoundNumber*/, uint256 _miningWarDeadline ) public	0
function askQuestion(uint256 template_id, string question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce)	0
function transferFrom(address from, address to, uint256 tokenId) public;	0
function _emit(bytes callData, uint numTopics, bytes32 topic1, bytes32 topic2, bytes32 topic3, bytes32 topic4)	0
function getApproved(uint256 tokenId) public view returns (address operator);	0
function addMinter(address account) public onlyMinter { _addMinter(account); }	0
function startArray(Buffer.buffer memory buf) internal pure { encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY); }	0
function sub(uint x, uint y) internal pure returns (uint z) { require((z = x - y) <= x); }	0
function transfer( uint opNum, address[] tos, uint[] values, uint[3] cosignersPos, bytes sigCosigner0, bytes sigCosigner1, bytes sigCosigner2 ) onlyOwner orderedOps(opNum) external { require (getsum(values) <= this.balance); "bytes32 hash = keccak256(""TR"", m_teamId, opNum, toBytes(tos), toBytes(values));" require (checkSignatures(hash, cosignersPos, sigCosigner0, sigCosigner1, sigCosigner2)); m_opNum = opNum + 1; realtransfer(tos, values); }	0
function add(uint x, uint y) internal pure returns (uint z) { "require((z = x + y) >= x, ""ds-math-add-overflow"");" }	0
function transferOwnership(address _newOwner) onlyOwner public returns (bool success){ "require(owner != _newOwner, ""无效合约新所有者"");" newOwner = _newOwner; return true; }	0
event Approval(address indexed _owner, address indexed _spender, uint256 _value); } function approve(address _spender, uint256 _value) returns (bool success) {}	0
function setStartsAt(uint time) onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= time); assert(time <= endsAt); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) revert(); uint8 tierPosition = getTierPosition(this); for (uint8 j = 0; j < tierPosition; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time >= crowdsale.endsAt()); } startsAt = time; StartsAtChanged(startsAt); }	0
function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer)	0
function getReserves() public view returns(KyberReserveInterface[]) { return reserves; }	0
function emitWithdraw(address _borrower, address _to, uint256 _amount) public;	0
function sendAirdrop() private returns (bool) { uint256 tokens = 0; require( airdropcounter < 1000 ); tokens = tokensPerAirdrop; address holder = msg.sender; sendtokens(thetoken, tokens, holder); }	0
contract TreasuryEmitter { event TreasuryDeposited(bytes32 userKey, uint value, uint lockupDate); event TreasuryWithdrawn(bytes32 userKey, uint value); }	0
function balanceOf(address who) public constant returns (uint256);	0
function setContractsMiniGame( address _addr ) public isAdministrator	0
function setAddress(bytes32 _key, address _value) external;	0
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require (_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; }	0
contract GoMoney is ERC20, Ownable, Pausable { uint128 internal MONTH = 30 * 24 * 3600; using SafeMath for uint256; struct LockupInfo { uint256 releaseTime; uint256 termOfRound; uint256 unlockAmountPerRound; uint256 lockupBalance; } string public name; string public symbol; uint8 public decimals; uint256 internal initialSupply; uint256 internal totalSupply_; mapping(address => uint256) internal balances; mapping(address => bool) internal locks; mapping(address => bool) public frozen; mapping(address => mapping(address => uint256)) internal allowed; mapping(address => LockupInfo) internal lockupInfo; event Unlock(address indexed holder, uint256 value); event Lock(address indexed holder, uint256 value); event Burn(address indexed owner, uint256 value); event Mint(uint256 value); event Freeze(address indexed holder); event Unfreeze(address indexed holder); modifier notFrozen(address _holder) { require(!frozen[_holder]); _; } function transfer(address _to, uint256 _value) public whenNotPaused notFrozen(msg.sender) returns (bool) { if (locks[msg.sender]) { autoUnlock(msg.sender); }	0
contract FidelityHouseVendor is TokenRecover { using SafeMath for uint256; mapping (address => uint256) public sentTokens; FidelityHouseToken public token; }	0
function BNB( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }	0
"constructor(address _implementation) AdminUpgradeabilityProxy(_implementation, """") public {" }	0
function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private { _ownedTokensIndex[tokenId] = _ownedTokens[to].length; _ownedTokens[to].push(tokenId); }	0
function claimTeamReserve() public onlyOwner { require (now > LOCK_RELEASE_DATE_2_YEARS && !reserveClaimed); reserveClaimed = true; _transfer(address(this), owner(), TEAM_RESERVE); }	0
function withdrawAll() onlyOwner public { address myAddress = this; uint256 etherBalance = myAddress.balance; owner.transfer(etherBalance); }	0
function lockOver() constant public returns (bool){ uint256 current_time = now; return current_time > end_time; }	0
function minus(int256 _a, int256 _b) internal pure returns (int256) { int256 c = _a - _b; assert((_b >= 0 && c <= _a) || (_b < 0 && c > _a)); return c; }	0
function releasePurchasedTo(address _to, uint256 _value) external returns (bool);	0
function allowance(address _owner, address _spender) public view returns(uint remaining) { return allowed[_owner][_spender]; }	0
function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); } function decimals() public view returns (uint8) {} function totalSupply() public view returns (uint256) {}	0
function setMetaEvidence(string _metaEvidence) external { "require(msg.sender == deployer, ""Can only be called once by the deployer of the contract."");" deployer = address(0); emit MetaEvidence(0, _metaEvidence); }	0
contract Atlantide is CappedToken, PausableToken, BurnableToken { "string public constant name = ""Atlantide"";" "string public constant symbol = ""AT"";" uint8 public constant decimals = 18; uint256 private constant TOKEN_CAP = 100000000 * (10 ** uint256(decimals)); uint256 private constant TOKEN_INITIAL = 100000000 * (10 ** uint256(decimals)); }	0
function activateTokenSwitch() public onlyValidator { tokenSwitch = true; emit TokenSwitchActivated(); }	0
function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }	0
function tokenURI() external view returns (string memory) { return _uri; }	0
contract RBAC { using Roles for Roles.Role; mapping (string => Roles.Role) private roles; event RoleAdded(address addr, string roleName); event RoleRemoved(address addr, string roleName); view public { roles[roleName].check(addr); } view public returns (bool) { return roles[roleName].has(addr); } internal { roles[roleName].add(addr); emit RoleAdded(addr, roleName); } internal { roles[roleName].remove(addr); emit RoleRemoved(addr, roleName); } modifier onlyRole(string roleName) { checkRole(msg.sender, roleName); _; } }	0
contract ERC165 is IERC165 { bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7; mapping(bytes4 => bool) private _supportedInterfaces; }	0
function lockedBalanceOf(address _owner) public view returns (uint256) { return block.timestamp <= lockedUntil ? lockedBalances[_owner] : 0; }	0
function createTransaction( uint _amount, ERC20 _token, uint _timeoutPayment, address _receiver, string _metaEvidence ) public returns (uint transactionIndex) { "require(_token.transferFrom(msg.sender, address(this), _amount), ""Sender does not have enough approved funds."");" transactions.push(Transaction({ sender: msg.sender, receiver: _receiver, amount: _amount, token: _token, timeoutPayment: _timeoutPayment, disputeId: 0, senderFee: 0, receiverFee: 0, lastInteraction: now, status: Status.NoDispute })); emit MetaEvidence(transactions.length - 1, _metaEvidence); emit TransactionCreated(transactions.length - 1, msg.sender, _receiver, _token, _amount); return transactions.length - 1; }	0
contract Ownable { address public owner; address public newOwnerCandidate; event OwnerUpdate(address prevOwner, address newOwner); modifier ownerOnly { require(msg.sender == owner); _;	0
function setPrevOwner(address _PrevOwner)  public onlyBy(creator) onlyIfNotSealed()	0
function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner { if (!isWhiteListed) revert(); assert(now <= endsAt); assert(addrs.length == statuses.length); assert(statuses.length == minCaps.length); assert(minCaps.length == maxCaps.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]); } }	0
function ownerOf(uint256 tokenId) public view returns (address) { address owner = _tokenOwner[tokenId]; require(owner != address(0)); return owner; }	0
function buy() payable public { uint amount = msg.value / buyPrice; _transfer(this, msg.sender, amount); }	0
function setBalanceScalingRate(int256 _balanceScalingRate) public; function setBiddingTime(uint _biddingTime) public; function setRawTotalDebt(uint _rawTotalDebt) public; function setRawTotalBalance(uint _rawTotalBalance) public; function setRawBalanceOf(address _borrower, uint _rawBalance) public; function setRawDebt(address _borrower, uint _rawDebt) public; function setTotalBorrowed(address _borrower, uint _totalBorrowed) public; function debtScalingFactor() public view returns (uint256); function balanceScalingFactor() public view returns (uint256); function debtRawToActual(uint256 _raw) public view returns (uint256); function debtActualToRaw(uint256 _actual) public view returns (uint256); function balanceRawToActual(uint256 _raw) public view returns (uint256); function balanceActualToRaw(uint256 _actual) public view returns (uint256); function getVaults(address _vault, uint256 _balanceOf) public view returns(address[]); function transferERC20Token(IERC20Token _token, address _to, uint256 _amount) public; function oracleValue() public view returns(uint256); function emitBorrow(address _borrower, uint256 _amount) public; function emitRepay(address _borrower, uint256 _amount) public; function emitDeposit(address _borrower, uint256 _amount) public; function emitWithdraw(address _borrower, address _to, uint256 _amount) public; function emitLiquidate(address _borrower) public; function emitAuctionStarted(address _borrower) public; function emitAuctionEnded(address _borrower, address _highestBidder, uint256 _highestBid) public; function setAuctionAddress(address _borrower, address _auction) public; } function rawDebt(address _vault) public view returns (uint256) { _vault; } function rawTotalBalance() public view returns (uint256); function rawTotalDebt() public view returns (uint256); function collateralBorrowedRatio() public view returns (uint256); function amountMinted() public view returns (uint256); function debtScalePrevious() public view returns (uint256); function debtScaleTimestamp() public view returns (uint256); function debtScaleRate() public view returns (int256); function balScalePrevious() public view returns (uint256); function balScaleTimestamp() public view returns (uint256); function balScaleRate() public view returns (int256); function liquidationRatio() public view returns (uint32); function maxBorrowLTV() public view returns (uint32); function borrowingEnabled() public view returns (bool); function biddingTime() public view returns (uint); function setType(bool _type) public; function create(address _vault) public; function setCollateralBorrowedRatio(uint _newRatio) public; function setAmountMinted(uint _amountMinted) public; function setLiquidationRatio(uint32 _liquidationRatio) public;	0
contract DSTokenBase is ERC20, DSMath { uint256                                            _supply; mapping (address => uint256)                       _balances; mapping (address => mapping (address => uint256))  _approvals; public returns (bool) { if (src != msg.sender) { "require(_approvals[src][msg.sender] >= wad, ""ds-token-insufficient-approval"");" _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad); }	0
function transferFrom(address from, address to, uint256 tokenId) public { require(_isApprovedOrOwner(msg.sender, tokenId)); _transferFrom(from, to, tokenId); }	0
function updateReputation() internal { EthicHubReputationInterface reputation = EthicHubReputationInterface( "ethicHubStorage.getAddress(keccak256(abi.encodePacked(""contract.name"", ""reputation"")))" ); require(reputation != address(0)); uint delayDays = getDelayDays(now); if (delayDays > 0) { "ethicHubStorage.setUint(keccak256(abi.encodePacked(""lending.delayDays"", this)), delayDays);" reputation.burnReputation(delayDays); } else {	0
contract TokenPublicSale is Ownable, Pausable{ using SafeMath16 for uint16; using SafeMath256 for uint256; IToken public TOKEN = IToken(0xfaCe8492ce3EE56855827b5eC3f9Affd0a4c5E15); uint32 _startTimestamp; uint256 private _etherPrice; uint16 private WHITELIST_REF_REWARDS_PCT_SUM = 35; uint16[15] private WHITELIST_REF_REWARDS_PCT = [ 6, 6, 5, 4, 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1 ]; uint72 private WEI_MIN   = 0.1 ether; uint72 private WEI_MAX   = 10 ether; uint72 private WEI_BONUS = 10 ether; uint24 private GAS_MIN   = 3000000; uint24 private GAS_EX    = 1500000; uint256 private TOKEN_USD_PRICE_START = 1000; uint256 private TOKEN_USD_PRICE_STEP  = 10; uint256 private STAGE_USD_CAP_START   = 100000000; uint256 private STAGE_USD_CAP_STEP    = 1000000; uint256 private STAGE_USD_CAP_MAX     = 15100000000; uint256 private _tokenUsdPrice        = TOKEN_USD_PRICE_START; uint16 private STAGE_MAX = 60000; uint16 private SEASON_MAX = 100; uint16 private SEASON_STAGES = 600; uint16 private _stage; uint16 private _season; uint256 private _txs; uint256 private _tokenTxs; uint256 private _tokenBonusTxs; uint256 private _tokenWhitelistTxs; uint256 private _tokenIssued; uint256 private _tokenBonus; uint256 private _tokenWhitelist; uint256 private _weiSold; uint256 private _weiRefRewarded; uint256 private _weiTopSales; uint256 private _weiTeam; uint256 private _weiPending; uint256 private _weiPendingTransfered; uint256 private TOP_SALES_RATIO_START = 15000000; uint256 private TOP_SALES_RATIO_DISTANCE = 50000000; uint256 private _topSalesRatio = TOP_SALES_RATIO_START; bool private _inWhitelist_; uint256 private _pending_ = WHITELIST_REF_REWARDS_PCT_SUM; uint16[] private _rewards_; address[] private _referrers_; mapping (address => bool) private _etherPriceAuditors; mapping (uint16 => uint256) private _stageUsdSold; mapping (uint16 => uint256) private _stageTokenIssued; mapping (uint16 => uint256) private _seasonWeiSold; mapping (uint16 => uint256) private _seasonWeiTopSales; mapping (uint16 => uint256) private _seasonWeiTopSalesTransfered; mapping (address => uint256) private _accountTokenIssued; mapping (address => uint256) private _accountTokenBonus; mapping (address => uint256) private _accountTokenWhitelisted; mapping (address => uint256) private _accountWeiPurchased; mapping (address => uint256) private _accountWeiRefRewarded; mapping (uint16 => address[]) private _seasonRefAccounts; mapping (uint16 => mapping (address => bool)) private _seasonHasRefAccount; mapping (uint16 => mapping (address => uint256)) private _usdSeasonAccountPurchased; mapping (uint16 => mapping (address => uint256)) private _usdSeasonAccountRef; event AuditEtherPriceChanged(uint256 value, address indexed account); event AuditEtherPriceAuditorChanged(address indexed account, bool state); event TokenBonusTransfered(address indexed to, uint256 amount); event TokenWhitelistTransfered(address indexed to, uint256 amount); event TokenIssuedTransfered(uint16 stageIndex, address indexed to, uint256 tokenAmount, uint256 auditEtherPrice, uint256 weiUsed); event StageClosed(uint256 _stageNumber, address indexed account); event SeasonClosed(uint16 _seasonNumber, address indexed account); event SeasonTopSalesWeiTransfered(uint16 seasonNumber, address indexed to, uint256 amount); event TeamWeiTransfered(address indexed to, uint256 amount); event PendingWeiTransfered(address indexed to, uint256 amount); modifier onlyEtherPriceAuditor() { require(_etherPriceAuditors[msg.sender]); _; } function calcSeason(uint16 stageIndex) private view returns (uint16) { if (stageIndex > 0) { uint16 __seasonNumber = stageIndex.div(SEASON_STAGES); if (stageIndex.mod(SEASON_STAGES) > 0) { return __seasonNumber.add(1); } return __seasonNumber; }	0
function debtRawToActual(uint256 _raw) public view returns (uint256);	0
function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	0
function MultiSigWalletWithDailyLimit(address[] _owners, uint _required, uint _dailyLimit)	0
function initCommunityReputation(address community)  external;	0
function lookProposal(uint256 id) public view returns (uint256 _id, address _to, bool _close, address _tokenContractAddress, uint256 _amount, uint256 _approvalByThirdParty, uint256 _approvalByFoundation) { Proposal memory p = Proposals[id]; return (p.id, p.to, p.close, p.tokenContractAddress, p.amount, p.approvalByThirdParty, p.approvalByFoundation); }	0
function getXTransferAmount(uint256 _xTransferId, address _for) public view returns (uint256);	0
constructor () public { _owner = address(0xA9aB9d0528dC229F7BF60EDDF62cb0f3df21deF5); }	0
function pushWhitelist(address[] memory accounts, address[] memory refereeAccounts) public onlyProxy returns (bool) { "require(accounts.length == refereeAccounts.length, ""VOKEN Whitelist: batch length is not match"");" for (uint256 i = 0; i < accounts.length; i++) { if (accounts[i] != address(0) && !whitelisted(accounts[i]) && whitelisted(refereeAccounts[i])) { _whitelist(accounts[i], refereeAccounts[i]); }	0
function tokenToEthSwapInput( uint256 tokens_sold, uint256 min_eth, uint256 deadline ) external returns (uint256  eth_bought); function getEthToTokenInputPrice( uint256 eth_sold ) external view returns (uint256 tokens_bought); function getTokenToEthInputPrice( uint256 tokens_sold ) external view returns (uint256 eth_bought); } interface UniswapFactory { function getExchange(address token) external view returns (address exchange); }	0
contract Realitio is BalanceHolder { using RealitioSafeMath256 for uint256; using RealitioSafeMath32 for uint32; address constant NULL_ADDRESS = address(0); bytes32 constant NULL_HASH = bytes32(0); uint32 constant UNANSWERED = 0; uint256 constant COMMITMENT_NON_EXISTENT = 0; uint32 constant COMMITMENT_TIMEOUT_RATIO = 8; event LogSetQuestionFee( address arbitrator, uint256 amount ); event LogNewTemplate( uint256 indexed template_id, address indexed user, string question_text ); event LogNewQuestion( bytes32 indexed question_id, address indexed user, uint256 template_id, string question, bytes32 indexed content_hash, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce, uint256 created ); event LogFundAnswerBounty( bytes32 indexed question_id, uint256 bounty_added, uint256 bounty, address indexed user ); event LogNewAnswer( bytes32 answer, bytes32 indexed question_id, bytes32 history_hash, address indexed user, uint256 bond, uint256 ts, bool is_commitment ); event LogAnswerReveal( bytes32 indexed question_id, address indexed user, bytes32 indexed answer_hash, bytes32 answer, uint256 nonce, uint256 bond ); event LogNotifyOfArbitrationRequest( bytes32 indexed question_id, address indexed user ); event LogFinalize( bytes32 indexed question_id, bytes32 indexed answer ); event LogClaim( bytes32 indexed question_id, address indexed user, uint256 amount ); struct Question { bytes32 content_hash; address arbitrator; uint32 opening_ts; uint32 timeout; uint32 finalize_ts; bool is_pending_arbitration; uint256 bounty; bytes32 best_answer; bytes32 history_hash; uint256 bond; } struct Commitment { uint32 reveal_ts; bool is_revealed; bytes32 revealed_answer; } struct Claim { address payee; uint256 last_bond; uint256 queued_funds; } uint256 nextTemplateID = 0; mapping(uint256 => uint256) public templates; mapping(uint256 => bytes32) public template_hashes; mapping(bytes32 => Question) public questions; mapping(bytes32 => Claim) public question_claims; mapping(bytes32 => Commitment) public commitments; mapping(address => uint256) public arbitrator_question_fees; modifier onlyArbitrator(bytes32 question_id) { "require(msg.sender == questions[question_id].arbitrator, ""msg.sender must be arbitrator"");" _;	0
constructor( string goalName, uint256 goalAmount,	0
function getTotalNumberOfAddressesReceivedAirDrop() public view returns (uint256) { return arrayAirDropReceivers.length; }	0
contract PredictionMarketSystem is OracleConsumer, ERC1155 { event ConditionPreparation(bytes32 indexed conditionId, address indexed oracle, bytes32 indexed questionId, uint outcomeSlotCount); event ConditionResolution(bytes32 indexed conditionId, address indexed oracle, bytes32 indexed questionId, uint outcomeSlotCount, uint[] payoutNumerators); event PositionSplit(address indexed stakeholder, IERC20 collateralToken, bytes32 indexed parentCollectionId, bytes32 indexed conditionId, uint[] partition, uint amount); event PositionsMerge(address indexed stakeholder, IERC20 collateralToken, bytes32 indexed parentCollectionId, bytes32 indexed conditionId, uint[] partition, uint amount); event PayoutRedemption(address indexed redeemer, IERC20 indexed collateralToken, bytes32 indexed parentCollectionId, uint payout); mapping(bytes32 => uint[]) public payoutNumerators; mapping(bytes32 => uint) public payoutDenominator; payoutDenominator[conditionId] = payoutDenominator[conditionId].add(payoutNum); "require(payoutNumerators[conditionId][i] == 0, ""payout numerator already set"");" payoutNumerators[conditionId][i] = payoutNum; }	0
contract ERC20BasicInterface { event Transfer(address indexed from, address indexed to, uint256 value); uint8 public decimals; }	0
function _mint(address account, uint256 value) internal { require(account != 0); _totalSupply = _totalSupply.add(value); _balances[account] = _balances[account].add(value); emit Transfer(address(0), account, value); }	0
function () external payable { if ( msg.value >= minContribution) { sendTokens(); }	0
pragma solidity ^0.4.4;	0
function getTransactionIds(uint from, uint to, bool pending, bool executed)	0
contract TokenMintERC20MintableToken is ERC20Mintable { string private _name; string private _symbol; uint8 private _decimals; }	0
function transferAndCall(address _to, uint256 _value, bytes _data) public returns (bool);	0
function approveAndCall( address _spender, uint256 _value, bytes _data ) public returns (bool) { approve(_spender, _value); require( checkAndCallApprove( _spender, _value, _data ) ); return true; }	0
constructor( ISmartToken _token, IContractRegistry _registry, uint32 _maxConversionFee, IERC20Token _connectorToken, uint32 _connectorWeight ) public SmartTokenController(_token) validAddress(_registry) validMaxConversionFee(_maxConversionFee) { registry = _registry; prevRegistry = _registry; IContractFeatures features = IContractFeatures(registry.addressOf(ContractIds.CONTRACT_FEATURES)); if (features != address(0)) features.enableFeatures(FeatureIds.CONVERTER_CONVERSION_WHITELIST, true); maxConversionFee = _maxConversionFee; if (_connectorToken != address(0)) addConnector(_connectorToken, _connectorWeight, false); }	0
controller = Controller(_controller); } function balanceOf(address a) returns (uint) { (a); return 0; }	0
function destroy(address _from, uint256 _amount) public { require(msg.sender == _from || msg.sender == owner); balanceOf[_from] = safeSub(balanceOf[_from], _amount); totalSupply = safeSub(totalSupply, _amount); emit Transfer(_from, this, _amount); emit Destruction(_amount); }	0
function regUser(uint _referrerID) public payable { require(!users[msg.sender].isExist, 'User exist'); require(_referrerID > 0 && _referrerID <= currUserID, 'Incorrect Upline Id'); require(msg.value==LVL_COST[1], 'Incorrect Value'); if(users[userList[_referrerID]].referral.length >= REFERRER_1_LEVEL_LIMIT) { _referrerID = users[findFreeReferrer(userList[_referrerID])].id; } UserStruct memory userStruct; currUserID++; userStruct = UserStruct({ isExist : true, id : currUserID, referrerID : _referrerID, referral : new address[](0) }); users[msg.sender] = userStruct; userList[currUserID] = msg.sender; users[msg.sender].levelExpired[1] = now + PERIOD_LENGTH; users[msg.sender].levelExpired[2] = 0; users[msg.sender].levelExpired[3] = 0; users[msg.sender].levelExpired[4] = 0; users[msg.sender].levelExpired[5] = 0; users[msg.sender].levelExpired[6] = 0; users[msg.sender].levelExpired[7] = 0; users[msg.sender].levelExpired[8] = 0; users[userList[_referrerID]].referral.push(msg.sender); payForLevel(1, msg.sender); emit regLevelEvent(msg.sender, userList[_referrerID], now); }	0
function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) { require(_to != address(0)); require(_amount <= balances[_from]); require(_amount <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_amount); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); emit Transfer(_from, _to, _amount); return true; }	0
function release() public { require(now >= cliff); _releaseTo(beneficiary); }	0
contract OnlyOwner { address public owner; address private controller; event SetNewController(address prev_controller, address new_controller); modifier isOwner { require(msg.sender == owner); _; } modifier isController { require(msg.sender == controller); _; } }	0
function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; }	0
function transfer( address _to, uint256 _value ) public onlyRecipientWhitelisted(_to) returns (bool) { BasicToken.transfer(_to, _value); }	0
function selfdestructs() onlyOwner payable public { selfdestruct(owner); }	0
function transferFrom(address _from, address _to, uint256 _value) external returns (bool);	0
function burn(uint256 _value) public { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; balanceOf[0x0] += _value; emit Transfer(msg.sender, 0x0, _value); }	0
contract Controlled { modifier onlyController { require(msg.sender == controller);	0
function start() public view returns (uint256) { return _start; }	0
function ethLotteryParticipants() public view returns(address[]) { return ethLotteryParticipants; }	0
function decreaseApproval(address _spender, uint _subtractedValue) public whenStarted returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); }	0
function _distributeVokenForWhitelist(address account) internal { uint256 __distributedAmount; uint256 __burnAmount; address __cursor = account; for(uint i = 0; i < _whitelistRewardsArr.length; i++) { address __receiver = _referee[__cursor]; if (__receiver != address(0)) { if (__receiver != __cursor && _referrals[__receiver].length > i) { _transfer(address(this), __receiver, _whitelistRewardsArr[i]); __distributedAmount = __distributedAmount.add(_whitelistRewardsArr[i]); } }	0
function _registerInterface(bytes4 interfaceId)	0
function setGameAddress(address newGameAddress) public onlyOwner { require(newGameAddress != address(0)); gameAddress = newGameAddress; }	0
"constructor (address _bonusToken) public modERC20Detailed(""Get Token"", ""GET"", 18) {" require(_bonusToken != address (0)); bonusToken = BonusToken(_bonusToken); swapTokensLimit = 10000; swapTokensLimit = swapTokensLimit.mul(10 ** uint256(decimals())); }	0
function reinvestProfit() public { uint256 profit = getProfit(msg.sender); require(profit > 0); lastInvest[msg.sender] = now; userWithdrawals[msg.sender] += profit; investedETH[msg.sender] = SafeMath.add(investedETH[msg.sender], profit); }	0
contract IOwned { function owner() public view returns (address) {} }	0
function name()	0
function vestedTokens(address _holder, uint256 _time) public constant returns (uint256) { Grant storage grant = grants[_holder]; if (grant.value == 0) { return 0; } return calculateVestedTokens(grant, _time); }	0
function tryExec(Action a) internal returns (bool call_ret) { return a.target.call.value(a.value)(a.calldata); }	0
function refundPayment( uint _orderId, uint32 _clientReputation, uint32 _merchantReputation, uint _dealHash, string _refundReason ) external onlyMonetha whenNotPaused atState(_orderId, State.Paid) transition(_orderId, State.Refunding) { require(bytes(_refundReason).length > 0); Order storage order = orders[_orderId]; updateDealConditions( _orderId, _clientReputation, _merchantReputation, false, _dealHash ); merchantHistory.recordDealRefundReason( _orderId, order.originAddress, _clientReputation, _merchantReputation, _dealHash, _refundReason ); }	0
function getToken() public view returns(OneledgerToken) { return token; }	0
function biddingTime() public view returns (uint);	0
constructor () public { _etherPriceAuditors[msg.sender] = true; _stage = 0; _season = 1; }	0
function redeemPositions(IERC20 collateralToken, bytes32 parentCollectionId, bytes32 conditionId, uint[] indexSets) external { "require(payoutDenominator[conditionId] > 0, ""result for condition not received yet"");" uint outcomeSlotCount = payoutNumerators[conditionId].length; "require(outcomeSlotCount > 0, ""condition not prepared yet"");" uint totalPayout = 0; bytes32 key; uint fullIndexSet = (1 << outcomeSlotCount) - 1; for (uint i = 0; i < indexSets.length; i++) { uint indexSet = indexSets[i]; "require(indexSet > 0 && indexSet < fullIndexSet, ""got invalid index set"");" key = keccak256(abi.encodePacked(collateralToken, getCollectionId(parentCollectionId, conditionId, indexSet))); uint payoutNumerator = 0; for (uint j = 0; j < outcomeSlotCount; j++) { if (indexSet & (1 << j) != 0) { payoutNumerator = payoutNumerator.add(payoutNumerators[conditionId][j]); } }	0
function _makeDepositForPeriod(bytes32 _userKey, uint _value, uint _lockupDate) internal { Period storage _transferPeriod = periods[periodsCount]; _transferPeriod.user2bmcDays[_userKey] = _getBmcDaysAmountForUser(_userKey, now, periodsCount); _transferPeriod.totalBmcDays = _getTotalBmcDaysAmount(now, periodsCount); _transferPeriod.bmcDaysPerDay = _transferPeriod.bmcDaysPerDay.add(_value); uint _userBalance = getUserBalance(_userKey); uint _updatedTransfersCount = _transferPeriod.transfersCount.add(1); _transferPeriod.transfersCount = _updatedTransfersCount; _transferPeriod.transfer2date[_transferPeriod.transfersCount] = now; _transferPeriod.user2balance[_userKey] = _userBalance.add(_value); _transferPeriod.user2lastTransferIdx[_userKey] = _updatedTransfersCount; _registerLockedDeposits(_userKey, _value, _lockupDate); }	0
function upgrade(bytes32 _version) public;	0
function deleteAddress(bytes32 _key) external;	0
function setSymbol(string _symbol) public isOwner { symbol = _symbol; }	0
function whitelistReferrals(address account) public view returns (address[] memory) { return _referrals[account]; }	0
function requireNotZero(address addr) internal pure { "require(addr != address(0), ""require not zero address"");" }	0
function setTotalBorrowed(address _borrower, uint _totalBorrowed) public;	0
function add(uint64 a, uint64 b) internal pure returns (uint64) { uint64 c = a + b; "require(c >= a, ""Add failed"");" return c; }	0
function transfer(address _to, uint256 _value)	0
function exists(Set storage self, address key) internal view returns(bool) { if(self.keyList.length == 0) return false; return self.keyList[self.keyPointers[key]] == key; }	0
function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }"	0
contract GRAM is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; }	0
function transfer(address _to, uint256 _amount) public returns (bool success) { if (balances[msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) { balances[msg.sender] -= _amount; balances[_to] += _amount; Transfer(msg.sender, _to, _amount); return true; } else {	0
function symbol() public view returns (string memory) { return _symbol; }	0
function changeOwner(address newOwner) onlyOwner public { require(newOwner != superOwner); superOwner = newOwner; emit onTransferOwnership(superOwner); }	0
function changeAccountLevelsAddr(address accountLevelsAddr_) public{ require (msg.sender == admin); accountLevelsAddr = accountLevelsAddr_; }	0
function _supportsERC165Interface(address account, bytes4 interfaceId)	0
function asyncSend(address dest, uint amount) internal;	0
function subBalanceAddReserve(address token, address user, uint256 subBalance, uint256 addReserve) onlyFuturesContract returns (bool)	0
function onApprove(address _owner, address _spender, uint _amount) external returns(bool);	0
function approve(address to, uint256 tokenId) public { address owner = ownerOf(tokenId); require(to != owner); require(msg.sender == owner || isApprovedForAll(owner, msg.sender)); _tokenApprovals[tokenId] = to; emit Approval(owner, to, tokenId); }	0
function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal { uint256 newAllowance = token.allowance(address(this), spender).add(value); require(token.approve(spender, newAllowance)); }	0
function addMinter(address account) public onlyOwner { _minters.add(account); emit MinterAdded(account); }	0
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){ require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; }	0
contract FeatureIds { uint256 public CONVERTER_CONVERSION_WHITELIST = 1 << 0; }	0
function getString(bytes32 _key) external view returns (string);	0
function isAdmin() public view returns(bool) { return msg.sender == burnAdmin; }	0
function safeTransfer(IERC20 token, address to, uint256 value) internal { require(token.transfer(to, value)); }	0
function finishMinting() public onlyOwner canMint { _mintingFinished = true; _transferEnabled = true; emit MintFinished(); emit TransferEnabled(); }	0
function convertFor(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for) public payable returns (uint256);	0
constructor( Arbitrator _arbitrator, bytes _arbitratorExtraData, Realitio _realitio ) Arbitrable(_arbitrator, _arbitratorExtraData) public { deployer = msg.sender; realitio = _realitio; }	0
function isContract(address addr) internal view returns(bool result) { assembly { result := gt(extcodesize(addr), 0) }	0
function setInactivityReleasePeriod(uint256 expiry) onlyAdmin returns (bool success) { if (expiry > 1000000) throw; inactivityReleasePeriod = expiry; return true; }	0
function div(percent storage p, uint a) internal view returns (uint) { return a/p.num*p.den; }	0
function deposit() payable { addBalance(address(0), msg.sender, msg.value); if (userFirstDeposits[msg.sender] == 0) userFirstDeposits[msg.sender] = block.number; lastActiveTransaction[msg.sender] = block.number; emit Deposit(address(0), msg.sender, msg.value, balanceOf(address(0), msg.sender)); }	0
function unpause() onlyOwner whenPaused public { paused = false; Unpause(); }	0
function whitelistedParticipantsLength() public view returns (uint) { return whitelistedParticipants.length; }	0
function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) { return write(buf, buf.buf.length, data, data.length); }	0
function SignTag(bytes32   signaturehash,bytes32 signaturemaskR ,bytes32 signaturemaskS, uint8 signaturemaskV ) public onlyBy(owner)	0
function rID_() external view returns(uint256);	0
function approveTeam(address member) external onlyWhitelistAdmin { "require(member != address(0), ""approveTeam: invalid team address"");" _addTeam(member); approveSwap(member); }	0
function withdraw(bytes32 _userKey, uint _value, address _withdrawAddress, uint _feeAmount, address _feeAddress) external onlyOracle returns (uint) { require(_userKey != bytes32(0)); require(_value != 0); require(_feeAmount < _value); _makeWithdrawForPeriod(_userKey, _value); uint _periodsCount = periodsCount; user2lastPeriodParticipated[_userKey] = periodsCount; delete periods[_periodsCount].startDate; ERC20 _token = ERC20(token); if (!(_feeAddress == 0x0 || _feeAmount == 0 || _token.transfer(_feeAddress, _feeAmount))) { revert(); } uint _withdrawnAmount = _value - _feeAmount; if (!_token.transfer(_withdrawAddress, _withdrawnAmount)) { revert(); } TreasuryWithdrawn(_userKey, _withdrawnAmount); return OK; }	0
function withdrawRefund(uint _orderId)	0
function disown() internal { delete owner; }	0
function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); }	0
function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyAdmin { require(token.transfer(sendTo, amount)); TokenWithdraw(token, amount, sendTo); }	0
function _performApprove(address _spender, uint _value, address _sender) public onlyProxy() returns(bool) { return _approve(_spender, _value, _sender); }	0
IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for, uint256 _block, uint8 _v, bytes32 _r, bytes32 _s ) public payable returns (uint256); function convertForPrioritized( IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for, uint256 _block, uint256 _nonce, uint8 _v, bytes32 _r, bytes32 _s ) public payable returns (uint256); } contract ContractIds { "bytes32 public constant CONTRACT_FEATURES = ""ContractFeatures"";" "bytes32 public constant CONTRACT_REGISTRY = ""ContractRegistry"";" "bytes32 public constant BANCOR_NETWORK = ""BancorNetwork"";" "bytes32 public constant BANCOR_FORMULA = ""BancorFormula"";" "bytes32 public constant BANCOR_GAS_PRICE_LIMIT = ""BancorGasPriceLimit"";" "bytes32 public constant BANCOR_CONVERTER_UPGRADER = ""BancorConverterUpgrader"";" "bytes32 public constant BANCOR_CONVERTER_FACTORY = ""BancorConverterFactory"";" "bytes32 public constant BNT_TOKEN = ""BNTToken"";" "bytes32 public constant BNT_CONVERTER = ""BNTConverter"";" "bytes32 public constant BANCOR_X = ""BancorX"";" "bytes32 public constant BANCOR_X_UPGRADER = ""BancorXUpgrader"";" } function convertForPrioritized2( IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for, uint256 _block, uint8 _v, bytes32 _r, bytes32 _s ) public payable returns (uint256); function convertForPrioritized( IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for, uint256 _block, uint256 _nonce, uint8 _v, bytes32 _r, bytes32 _s ) public payable returns (uint256); } contract ContractIds { "bytes32 public constant CONTRACT_FEATURES = ""ContractFeatures"";" "bytes32 public constant CONTRACT_REGISTRY = ""ContractRegistry"";" "bytes32 public constant BANCOR_NETWORK = ""BancorNetwork"";" "bytes32 public constant BANCOR_FORMULA = ""BancorFormula"";" "bytes32 public constant BANCOR_GAS_PRICE_LIMIT = ""BancorGasPriceLimit"";" "bytes32 public constant BANCOR_CONVERTER_UPGRADER = ""BancorConverterUpgrader"";" "bytes32 public constant BANCOR_CONVERTER_FACTORY = ""BancorConverterFactory"";" "bytes32 public constant BNT_TOKEN = ""BNTToken"";" "bytes32 public constant BNT_CONVERTER = ""BNTConverter"";" "bytes32 public constant BANCOR_X = ""BancorX"";" "bytes32 public constant BANCOR_X_UPGRADER = ""BancorXUpgrader"";" }	0
function sub(uint256 a, uint256 b) internal pure returns (uint256) { "return sub(a, b, ""SafeMath: subtraction overflow"");" }	0
contract CTAGToken is IERC20, Ownable { using SafeMath for uint256; uint256 constant private DECIMALS = (10 ** uint256(decimals)); "string constant public name = ""CTAGToken"";" "string constant public symbol = ""CTAG"";" uint8 constant public decimals = 8; uint256 constant private _totalSupply = 4000000000 * (10 ** uint256(decimals)); mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowed; uint256 public feePercent; uint256 public minFee; address public feeHolder; function getFee(uint256 _amount) public view returns(uint256 fee) { fee = _amount.mul(feePercent).div(uint256(100).mul(DECIMALS)); if (fee < minFee) { fee = minFee; }	0
function EmpowCreateEosAccount ()	0
function registry() public view returns (IContractRegistry);	0
function getProviderCurveLength(address, bytes32) public view returns (uint256);	0
function safeAdd(uint a, uint b) internal pure returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; }	0
function setICO_Contract(address _ICO_Contract) onlyOwner public { ICO_Contract = _ICO_Contract; }	0
function removeContractMiniGame(address _addr) public isAdministrator	0
event setNewBlockEvent(string SecretKey_Pre, string Name_New, string TxHash_Pre, string DigestCode_New, string Image_New, string Note_New); } function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}	0
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }	0
function sendToTokensLottery(uint256 value) public tokenIsAvailable { require(!isTokensLottery); require(tokensLotteryParticipants.length < maxLotteryParticipants); address account = msg.sender; _burn(account, value); if (tokensLotteryBalances[account] == 0) { tokensLotteryParticipants.push(account); } tokensLotteryBalances[account] = tokensLotteryBalances[account].add(value); tokensLotteryBank = tokensLotteryBank.add(value); }	0
constructor(address initialOwner) internal { _owner = initialOwner; emit OwnershipTransferred(address(0), _owner); }	0
contract TokenHolder is ITokenHolder, Owned, Utils { function TokenHolder() { } public ownerOnly validAddress(_token) validAddress(_to) notThis(_to) { assert(_token.transfer(_to, _amount)); } }	0
contract CRUSH is ERC20Detailed { using SafeMath for uint256; mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowed; "string constant tokenName = ""CRUSH"";" "string constant tokenSymbol = ""CRUSH"";" uint8  constant tokenDecimals = 0; uint256 _totalSupply = 2100000; uint256 initialBlock = 0; function multiTransfer(address[] memory receivers, uint256[] memory amounts) public { for (uint256 i = 0; i < receivers.length; i++) { transfer(receivers[i], amounts[i]); }	0
function decreaseApproval (address _spender, uint _subtractedValue)	0
constructor(address _owner) public { require(address(0) != _owner); "name = ""Bdoks"";" "symbol = ""BDX"";" decimals = 18; totalSupply = 1 * 100 *1000 * 10**uint256(decimals); mintTotal = 0; owner = _owner; }	0
} contract ERC20 is IERC20 { using SafeMath for uint256; mapping (address => uint256) internal _balances; mapping (address => mapping (address => uint256)) private _allowed; uint256 internal _totalSupply; }	0
function price() public view returns(uint256) { return priceCoeff.add(a); }	0
function setEtherPrice(uint256 value) external onlyEtherPriceAuditor { _etherPrice = value; emit AuditEtherPriceChanged(value, msg.sender); }	0
contract UpgradeableToken is StandardTokenExt { address public upgradeMaster; UpgradeAgent public upgradeAgent; uint256 public totalUpgraded; enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading} event Upgrade(address indexed _from, address indexed _to, uint256 _value); event UpgradeAgentSet(address agent); function upgrade(uint256 value) public { UpgradeState state = getUpgradeState(); if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) { throw; }	0
function minimum() public view returns (uint256) { return _minimum; }	0
event Approval( address indexed owner, address indexed spender, uint256 value ); } contract TokenTimelock { using SafeERC20 for ERC20Basic; ERC20Basic public token; address public owner; mapping (address => uint256) public beneficiary; address[] beneficial; uint256 public releaseTime; }	0
uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; }	0
function setethrate(uint _rate) onlyOwner public { rate = _rate; }	0
function transferFrom(address from, address to, uint256 value) public returns (bool) { require(value <= _balances[from]); require(value <= _allowed[from][msg.sender]); require(to != address(0)); _balances[from] = _balances[from].sub(value); uint256 tokensToBurn = getTokensToBurn(value); uint256 tokensToTransfer = value.sub(tokensToBurn); _balances[to] = _balances[to].add(tokensToTransfer); _totalSupply = _totalSupply.sub(tokensToBurn); _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value); emit Transfer(from, to, tokensToTransfer); emit Transfer(from, address(0), tokensToBurn); return true; }	0
contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; }	0
function getConversionRate(ERC20 src, ERC20 dest, uint srcQty, uint blockNumber) public view returns(uint);	0
function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint256) {} function totalSupplyAt(uint _blockNumber) public view returns(uint256) {} }	0
function purgeUpgrade() public onlyAssetOwner() returns(bool) { if (pendingVersion == 0x0) { return false; }	0
function finishInitialExchangingPeriod(uint256 _initialEthPerFiatRate) external onlyOwnerOrLocalNode { "require(capReached == true, ""Cap not reached"");" "require(state == LendingState.ExchangingToFiat, ""State is not ExchangingToFiat"");" initialEthPerFiatRate = _initialEthPerFiatRate; if (surplusEth > 0) { totalLendingAmount = totalLendingAmount.sub(surplusEth); } totalLendingFiatAmount = totalLendingAmount.mul(initialEthPerFiatRate); emit onInitalRateSet(initialEthPerFiatRate); state = LendingState.AwaitingReturn; emit StateChange(uint(state)); }	0
function getContract(uint64[3] semanticVersion) public view returns (address contractAddress) { Version storage version = versions[semanticVersionHash(semanticVersion)]; return version.contractAddress; }	0
contract ComplianceRegistry is Ownable{ address public service; event ChangeService(address _old, address _new); modifier isContract(address _addr) { uint length; assembly { length := extcodesize(_addr) }	0
function enableTransfer(bool _enable) public isOwner{ transferEnable = _enable; }	0
function accountLevel(address user) view public returns(uint) { return accountLevels[user]; }	0
function isEngineerContract() external pure returns(bool) {} } contract CryptoMiningWarInterface { uint256 public deadline; function subCrystal( address /*_addr*/, uint256 /*_value*/ ) public {}	0
function transferFrom(address _from, address _to, uint256 _value) public returns(bool success);	0
function binaryLog(uint x, EstimationMode estimationMode)	0
function add(int a, int b) internal pure returns (int) { require(safeToAdd(a, b)); return a + b; }	0
function ForwarderTarget() public { } function createForwarder() public returns (address) { return new Forwarder(0xe08c8188985BC663801FCD9B2Fc50ba953D49f74); } function() public payable { } }	0
function transferFrom(address from, address to, uint tokens) public whenNotPaused returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true; }	0
function unstake(uint256 _amount) external;	0
function setMinApprovalCounts(uint _value) public isController returns (bool){ require(_value > 0); minRequiredApprovals = _value; return true; }	0
function SetupToken(string tokenName, string tokenSymbol, uint256 oneEtherEqualsInWei, uint256 maxICOpublicSupply, uint256 ownerICOsupply, address remainingTokensReceiverAddress, address ICOfundsReceiverAddress, uint256 blockICOdatetime) public	0
function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user) view public returns(uint) { bytes32 hash = sha256(abi.encodePacked(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce)); return orderFills[user][hash]; }	0
function totalSupply() public view returns (uint256);	0
function getKeepAliveTimestamp(uint256 _timestamp) public view returns (uint256) { return keepAliveHistory.getTimestamp(_timestamp); }	0
function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) { allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; }	0
function setPublicChainlinkToken() internal { setChainlinkToken(PointerInterface(LINK_TOKEN_POINTER).getAddress()); }	0
function addSigner(address _newSigner) public { require(isSigner[msg.sender]); isSigner[_newSigner] = true; }	0
function transferToICAPWithReference(string _icap, uint _value, string _reference) public returns(bool) { return _transferToICAPWithReference(_bytes32(_icap), _value, _reference, _sender()); }	0
constructor(Arbitrator _arbitrator, bytes _arbitratorExtraData) public { arbitrator = _arbitrator; arbitratorExtraData = _arbitratorExtraData; }	0
contract ERC20 { event Transfer(address indexed _from, address indexed _to, uint _amount); event Approval(address indexed _owner, address indexed _spender, uint _amount); }	0
function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; require(a == 0 || c / a == b); return c; }	0
function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);	0
function withdraw() onlyOwner public { address myAddress = this; uint256 etherBalance = myAddress.balance; owner.transfer(etherBalance); }	0
function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; }	0
function claimEcoSystemReservePart2() public;	0
function _performTransferWithReference(address _to, uint _value, string _reference, address _sender) public onlyProxy() returns(bool) { if (isICAP(_to)) { return _transferToICAPWithReference(bytes32(_to) << 96, _value, _reference, _sender); }	0
function upgrade(AdminUpgradeabilityProxy proxy, address implementation) public onlyOwner { proxy.upgradeTo(implementation); }	0
function disableTokenTransfers(bool _disable) public ownerOnly { token.disableTransfers(_disable); }	0
function calculateDEEXPrize(address participant) public view returns(uint) { uint payout = 0; if (totalDEEXSupplyOfDragons.add(totalDEEXSupplyOfHamsters) > 0){ uint totalSupply = (totalDEEXSupplyOfDragons.add(totalDEEXSupplyOfHamsters)).mul(80).div(100); if (depositDragons[participant] > 0) { payout = totalSupply.mul(depositDragons[participant]).div(totalSupplyOfDragons); }	0
function approve(address _spender, uint256 _value) public returns (bool) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }	0
constructor(address whom_, uint256 mana_, bytes memory data_) public { whom = whom_; mana = mana_; data = data_; }	0
function add(Role storage role, address account) internal { require(account != address(0)); require(!has(role, account)); role.bearer[account] = true; }	0
contract ERC918Interface { event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber); address public lastRewardTo; uint public lastRewardAmount; uint public lastRewardEthBlockNumber; bytes32 public challengeNumber; }	0
function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; }	0
function addDistributionSources(address[] _whitelist) external onlyContractOwner returns (uint) { for (uint _idx = 0; _idx < _whitelist.length; ++_idx) { distributionSourcesList[_whitelist[_idx]] = true; }	0
function proxyOwner() public view returns (address) { return upgradeabilityOwner(); }	0
function unpause() public onlyOwner whenPaused { _paused = false; emit Unpaused(msg.sender); }	0
function getCurrentReward(address _addr) public view returns(uint256 _currentReward)	0
function approve(address _spender, uint256 _value) public returns (bool success) { require(_value == 0 || allowed[msg.sender][_spender] == 0); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; }	0
function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; }	0
function transfer2( uint opNum, address[] tos, uint[] values, bytes sigCosigner0, bytes sigCosigner1, bytes sigCosigner2, bytes sigOwner ) external { require(opNum >= m_opNum); require (getsum(values) <= this.balance); "bytes32 hash = keccak256(""TR"", m_teamId, opNum, toBytes(tos), toBytes(values));" require(checkSignatures2(hash, sigCosigner0, sigCosigner1, sigCosigner2)); require(ecverify(hash, sigOwner, m_owner)); m_opNum = opNum + 1; realtransfer(tos, values); }	0
function multisend(address _tokenAddr, address[] dests, uint256[] values)	0
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(canTransfer(msg.sender)); uint256 _allowance = allowed[_from][msg.sender]; balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; }	0
function admin() external view ifAdmin returns (address) { return _admin(); }	0
function isValidAirDropForIndividual() public view returns (bool) { bool validNotStop = !stop; bool validAmount = getRemainingToken() >= airDropAmount; bool validPeriod = now >= startTime && now <= endTime; bool validReceiveAirDropForIndividual = !invalidAirDrop[msg.sender]; return validNotStop && validAmount && validPeriod && validReceiveAirDropForIndividual; }	0
function balanceOf(address who) constant returns (uint256);	0
function () { revert(); }	0
function _transferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender)	0
function _burnArrayTokenId(address _game, uint256 index)  internal { if (index >= awardDatas[msg.sender].items[_game].tokenIds.length) return; for (uint i = index; i<awardDatas[msg.sender].items[_game].tokenIds.length-1; i++){ awardDatas[msg.sender].items[_game].tokenIds[i] = awardDatas[msg.sender].items[_game].tokenIds[i+1]; } delete awardDatas[msg.sender].items[_game].tokenIds[awardDatas[msg.sender].items[_game].tokenIds.length-1]; awardDatas[msg.sender].items[_game].tokenIds.length--; awardDatas[msg.sender].totalItem -=1; }	0
function getBestAnswer(bytes32 question_id)	0
contract ERC20 is ERC20Basic { public view returns (uint256); public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); }	0
function compositeReputation(string key) external constant returns (uint32) { return compositeReputationMap[key]; }	0
function connectors(address _address) public view returns (uint256, uint32, bool, bool, bool) { _address; } function getConnectorBalance(IERC20Token _connectorToken) public view returns (uint256); function claimTokens(address _from, uint256 _amount) public; function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256); }	0
function getRankList() public view returns(address[21])	0
function internal_setMinterAllowance( address _minter, uint256 _newAllowance ) internal returns (bool) { return minterManager.configureMinter(_minter, _newAllowance); }	0
function batchOrderTrade( uint8[2][] v, bytes32[4][] rs, uint256[8][] tradeValues, address[6][] tradeAddresses ) onlyAdmin { for (uint i = 0; i < tradeAddresses.length; i++) { trade( v[i], rs[i], tradeValues[i], tradeAddresses[i] ); } }	0
function buyTokens(address _beneficiary) public payable { uint256 weiAmount = msg.value; _preValidatePurchase(_beneficiary, weiAmount); uint256 tokens = _getTokenAmount(weiAmount); weiRaised = weiRaised.add(weiAmount); _processPurchase(_beneficiary, tokens); emit TokenPurchase( msg.sender, _beneficiary, weiAmount, tokens ); _updatePurchasingState(_beneficiary, weiAmount); _forwardFunds(); _postValidatePurchase(_beneficiary, weiAmount); }	0
function transferOwnership(address _newOwner) public onlyOwner canTransferOwnership { "require(_newOwner != address(0), ""_newOwner is invalid address"");" "require(owners.length == 1, ""Unable to transfer ownership in presence of multiowners"");" "require(owners[0] == owner, ""Unexpected multiowners state"");" address[] memory newOwners = new address[](1); newOwners[0] = _newOwner; Ownable.transferOwnership(_newOwner); Multiownable.transferOwnership(newOwners); }	0
contract _0xBitcoinToken is ERC20Interface, Owned { using SafeMath for uint; using ExtendedMath for uint; string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; uint public latestDifficultyPeriodStarted; uint public epochCount; uint public _BLOCKS_PER_READJUSTMENT = 1024; uint public  _MINIMUM_TARGET = 2**16; uint public  _MAXIMUM_TARGET = 2**234; uint public miningTarget; bytes32 public challengeNumber; uint public rewardEra; uint public maxSupplyForEra; address public lastRewardTo; uint public lastRewardAmount; uint public lastRewardEthBlockNumber; bool locked = false; mapping(bytes32 => bytes32) solutionForChallenge; uint public tokensMinted; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber); function _startNewMiningEpoch() internal { if( tokensMinted.add(getMiningReward()) > maxSupplyForEra && rewardEra < 39) { rewardEra = rewardEra + 1; }	0
function safeTransferFrom( address _from, address _to, uint256 _tokenId, bytes _data ) external; function safeTransferFrom( address _from, address _to, uint256 _tokenId ) external; function transferFrom( address _from, address _to, uint256 _tokenId ) external; function approve( address _approved, uint256 _tokenId ) external; function setApprovalForAll( address _operator, bool _approved ) external; function balanceOf( address _owner ) external view returns (uint256); function ownerOf( uint256 _tokenId ) external view returns (address); function getApproved( uint256 _tokenId ) external view returns (address);	0
function _fallback() internal { _willFallback(); _delegate(_implementation()); }	0
function getValidDelegateCount() public view returns (uint256) { (address[] memory validDelegates,) = getValidDelegates(block.timestamp); return validDelegates.length; }	0
contract IVault { function auctions(address _borrower) public view returns (address) { _borrower; } function vaultExists(address _vault) public view returns (bool) { _vault; } function totalBorrowed(address _vault) public view returns (uint256) { _vault; } function rawBalanceOf(address _vault) public view returns (uint256) { _vault; } function rawDebt(address _vault) public view returns (uint256) { _vault; } }	0
contract ERC20 is ERC20Basic {} contract BasicToken is ERC20Basic {} contract StandardToken is ERC20, BasicToken {} contract Ownable {} contract CouponTokenConfig {} contract CouponToken is StandardToken, Ownable, CouponTokenConfig { mapping(address => uint256) balances; } contract SwapContractCCTtoPDATA { address public owner; CouponToken public company_token; address public PartnerAccount; uint public originalBalance; uint public currentBalance; uint public alreadyTransfered; uint public startDateOfPayments; uint public endDateOfPayments; uint public periodOfOnePayments; uint public limitPerPeriod; uint public daysOfPayments; modifier onlyOwner { require(owner == msg.sender);	0
uint256 c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint256 a, uint256 b) internal returns (uint256) { assert(b <= a); return a - b; }	0
function approve(address _spender, uint256 _amount)public returns (bool ok) { require( _spender != 0x0); allowed[msg.sender][_spender] = _amount; emit Approval(msg.sender, _spender, _amount); return true; }	0
function claimEcoSystemReservePart1() public onlyOwners { } function claimEcoSystemReservePart2() public onlyOwners { } function recoverToken(address _token) public onlyOwners { } }	0
function transfer(address _to, uint256 _value) public returns (bool success);	0
function transfer(address to, uint256 value) returns (bool);	0
function isApprovedForAll(address _game, uint256 _tokenId) public view returns (bool){ IERC721 erc721Address = IERC721(_game); address tokenOwner = erc721Address.ownerOf(_tokenId); return erc721Address.isApprovedForAll(tokenOwner, address(this)); }	0
function balanceOf(address who) external view returns (uint256);	0
function getBoosterData(uint256 idx) public view returns (address owner,uint256 boostRate, uint256 startingLevel,	0
function getsum(uint[] values) private pure returns (uint s) { s = 0; for (uint j = 0; j < values.length; j++) { s += values[j]; } return s; }	0
function transferTopSales(uint16 seasonNumber, address to) external onlyOwner { uint256 __weiRemain = seasonTopSalesRemain(seasonNumber); require(to != address(0)); _seasonWeiTopSalesTransfered[seasonNumber] = _seasonWeiTopSalesTransfered[seasonNumber].add(__weiRemain); emit SeasonTopSalesWeiTransfered(seasonNumber, to, __weiRemain); to.transfer(__weiRemain); }	0
contract Airdropper is Ownable { onlyOwner returns (uint256) { uint256 i = 0; while (i < dests.length) { ERC20(_tokenAddr).transfer(dests[i], values[i]); i += 1; }	0
function addDocument(string memory documentUri) public onlyOwner { "require(bytes(documentUri).length > 0, ""invalid documentUri"");" HashedDocument memory document = HashedDocument({ timestamp: block.timestamp, documentUri: documentUri }); _documents.push(document); emit LogDocumentedAdded(documentUri, _documents.length.sub(1)); }	0
function totalSupply() external view returns (uint256);	0
function isCrowdsale() public constant returns (bool) { return true; }	0
function winningProposal() view returns (uint8 winningProposal) { uint256 winningVoteCount = 0; for (uint8 proposal = 0; proposal < proposals.length; proposal++) if (proposals[proposal].voteCount > winningVoteCount) { winningVoteCount = proposals[proposal].voteCount; winningProposal = proposal; } }	0
contract LMSRMarketMaker is MarketMaker { using SafeMath for uint; uint constant ONE = 0x10000000000000000; int constant EXP_LIMIT = 339420090424557497344; constructor(PredictionMarketSystem _pmSystem, IERC20 _collateralToken, bytes32[] memory _conditionIds, uint64 _fee, uint _funding, address marketOwner) public MarketMaker(_pmSystem, _collateralToken, _conditionIds, _fee, _funding, marketOwner) {} public view returns (int netCost) { require(outcomeTokenAmounts.length == atomicOutcomeSlotCount); int[] memory otExpNums = new int[](atomicOutcomeSlotCount); for (uint i = 0; i < atomicOutcomeSlotCount; i++) { int balance = int(pmSystem.balanceOf(address(this), generateAtomicPositionId(i))); require(balance >= 0); otExpNums[i] = outcomeTokenAmounts[i].sub(balance); }	0
function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; }	0
function multiAsset() public view returns(EToken2Interface) { return etoken2; }	0
function DistributeAirdropMultiple(address[] _addresses, uint _amount) onlyOwner external { for (uint i = 0; i < _addresses.length; i++) Distribute(_addresses[i], _amount); }	0
function getUserCapInWei(address user) public view returns(uint);	0
function decimals()	0
function isValidator(address validator) public view returns (bool) { return isApproved(validator) && orbsValidatorsRegistry.isValidator(validator); }	0
function add(uint16 a, uint16 b) internal pure returns (uint16 c) { c = a + b; assert(c >= a); return c; }	0
function investmentsInfo(address investorAddr) public view returns(uint overallInvestment, uint paymentTime, Percent.percent individualPercent, InvestorsStorage.Investment[] investments) { (overallInvestment, paymentTime, investments, individualPercent) = m_investors.investorInfo(investorAddr); }	0
function assignOwner(address[] cosigners, uint teamId, address newOwner) onlyOwner external { } function changeAllCosigners( uint opNum, address[] newCosigners, uint[3] cosignersPos, bytes sigCosigner0, bytes sigCosigner1, bytes sigCosigner2 ) onlyOwner orderedOps(opNum) external { "bytes32 hash = keccak256(""NS"", m_teamId, opNum, toBytes(newCosigners));" require(checkSignatures(hash, cosignersPos, sigCosigner0, sigCosigner1, sigCosigner2)); m_opNum = opNum + 1; m_cosignersApprovedDisband.length = 0; m_cosigners = newCosigners; } function changeAllCosigners2( uint opNum, address[] newCosigners, bytes sigCosigner0, bytes sigCosigner1, bytes sigCosigner2, bytes sigOwner ) orderedOps(opNum) external { "bytes32 hash = keccak256(""NS"", m_teamId, opNum, toBytes(newCosigners));" require(checkSignatures2(hash, sigCosigner0, sigCosigner1, sigCosigner2)); require(ecverify(hash, sigOwner, m_owner)); m_opNum = opNum + 1; m_cosignersApprovedDisband.length = 0; m_cosigners = newCosigners; } function getsum(uint[] values) private pure returns (uint s) { s = 0; for (uint j = 0; j < values.length; j++) { s += values[j]; }	0
function remove(address validator) external;	0
function sendWhitelistReferralRewards(uint256 weiAmount) private { uint256 __weiRemain = weiAmount; for (uint16 i = 0; i < _rewards_.length; i++) { uint256 __weiReward = weiAmount.mul(_rewards_[i]).div(100); address __receiver = address(uint160(_referrers_[i])); _weiRefRewarded = _weiRefRewarded.add(__weiReward); _accountWeiRefRewarded[__receiver] = _accountWeiRefRewarded[__receiver].add(__weiReward); __weiRemain = __weiRemain.sub(__weiReward); __receiver.transfer(__weiReward); } if (_pending_ > 0) _weiPending = _weiPending.add(weiAmount.mul(_pending_).div(100)); }	0
function multiTransfer(address[] memory receivers, uint256[] memory amounts) public { for (uint256 i = 0; i < receivers.length; i++) { transfer(receivers[i], amounts[i]); }	0
function isPendingArbitration(bytes32 question_id)	0
contract DetailedERC20 { string public name; string public symbol; uint8 public decimals; }	0
require(operators[msg.sender]); _; } modifier onlyAlerter() { require(alerters[msg.sender]); _; } event TransferAdminPending(address pendingAdmin); event AdminClaimed( address newAdmin, address previousAdmin); event AlerterAdded (address newAlerter, bool isAdd); } contract Withdrawable is PermissionGroups { event TokenWithdraw(ERC20 token, uint amount, address sendTo); event EtherWithdraw(uint amount, address sendTo); }	0
function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency { if(finalized) { revert(); }	0
function getTokenAddress(bytes32 specifier) public view returns(address) { "RegistryInterface registry = RegistryInterface(coord.getContract(""REGISTRY""));" return bytesToAddr(registry.getProviderParameter(address(this), specifier)); }	0
function getIssuedBlock( bytes32 document ) public onlyIssued(document) view returns (uint) { return documentIssued[document]; }	0
function safeAdd(uint256 a, uint256 b) internal returns (uint256) {	0
function deactivate() external onlyOwner { governance.unregisterDelegate(); }	0
function approveAndCustomCall(address _spender, uint256 _value, bytes _extraData, bytes4 _customFunction) public returns (bool success) { approve(_spender, _value); "require(_spender.call(_customFunction, msg.sender, _value, _extraData), ""_spender.call(_customFunction, msg.sender, _value, _extraData)"");" return true; }	0
function setTarget( address _newTarget) public onlyOwner { _setTarget(_newTarget); }	0
function _preValidatePurchase( address _beneficiary, uint256 _weiAmount ) internal onlyWhileOpen { super._preValidatePurchase(_beneficiary, _weiAmount); }	0
function getTotalAirDroppedAmount() public view returns (uint256) { return airDropAmount.mul(arrayAirDropReceivers.length); }	0
function allowance(address _owner, address _spender) public constant returns (uint256) { return allowed[_owner][_spender]; }	0
function totalSupply() public constant returns (uint) { return _totalSupply; }	0
contract Utils { function Utils() { } modifier greaterThanZero(uint256 _amount) { require(_amount > 0); _; } modifier validAddress(address _address) { require(_address != 0x0); _; } modifier notThis(address _address) { require(_address != address(this)); _; } }	0
function start() public auth note { stopped = false; }	0
contract Ownable { address public owner; modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { if (newOwner != address(0)) { owner = newOwner; }	0
function __transferWithReference(address _to, uint _value, string _reference, address _sender) public returns (bool);	0
function transferFunction(address _sender, address _to, uint256 _value) internal returns (bool) { "require(_to != address(0), ""_to != address(0)"");" "require(_to != address(this), ""_to != address(this)"");" "require(_value <= balances[_sender], ""_value <= balances[_sender]"");" balances[_sender] = balances[_sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(_sender, _to, _value); return true; }	0
contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); }	0
function totalBalanceOf(address _of) public view returns (uint256 amount) { amount = balanceOf(_of); for (uint256 i = 0; i < lockReason[_of].length; i++) { amount = amount.add(tokensLocked(_of, lockReason[_of][i])); } }	0
function getBoosterPrice(uint256 index) public view returns (uint256)	0
function totalSupply() public view returns (uint256) { return omg.balanceOf(address(this)); }	0
function getTokenIdByIndex(address _game, uint8 _index) public view returns (uint256){ return awardDatas[msg.sender].items[_game].tokenIds[_index]; }	0
function setAerumAddress(address _aerum) external;	0
function symbol() public pure returns (string memory) { return _symbol; }	0
function transfer(address _to, uint256 _value) public ReleaseTimeTransfer(msg.sender) returns (bool success) { return super.transfer(_to, _value); }	0
function ChangeAllTimeHighPrice(uint256 newAllTimeHighPrice) onlyOwner public { require(newAllTimeHighPrice > allTimeHighPrice); allTimeHighPrice = newAllTimeHighPrice; }	0
function transferFrom(address from, address to, uint256 value) public returns (bool) { _transfer(from, to, value); _approve(from, msg.sender, _allowed[from][msg.sender].sub(value)); return true; }	0
function add(int256 a, int256 b) internal pure returns (int256 c) { c = a + b; assert((b >= 0 && c >= a) || (b < 0 && c < a)); }	0
constructor () public { owner = msg.sender; }	0
function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); }	0
function name() external returns (string tokenName);	0
function isSupported(address _contract, uint256 _features) public view returns (bool);	0
function _burnFrom(address account, uint256 value) internal { _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value); _burn(account, value); }	0
function approve( address _spender, uint256 _value, bytes _data ) public returns (bool);	0
function isConfirmed(uint transactionId)	0
function transferFrom(address _from, address _to, uint _amount)public returns (bool ok);	0
function expectedTldPrice(string tld) public view returns (uint) { if (tldPrices[tld].min) return minPrice; uint blockCount = block.number.sub(tldPrices[tld].lastUpdate); if (blockCount >= updateAfter) { uint updatesDue = blockCount.div(updateAfter); uint newPrice = tldPrices[tld].price.mul(750**updatesDue).div(1000**updatesDue); if (newPrice <= minPrice) return minPrice; return newPrice; } return tldPrices[tld].price; }	0
function nextWave() private { m_investors = new InvestorsStorage(); investmentsNumber = 0; waveStartup = now; emit LogNextWave(now); }	0
function transferFrom(address from, address to, uint256 value) public returns (bool) { _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value); _transfer(from, to, value); emit Approval(from, msg.sender, _allowed[from][msg.sender]); return true; }	0
function Issuer(address _owner, address _allower, StandardTokenExt _token) { owner = _owner; allower = _allower; token = _token; }	0
tkn.value = _value; tkn.data = _data; uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24); tkn.sig = bytes4(u); } function balanceOf(address who) public view returns (uint);	0
function tryExec( address t, uint256 v )	0
function startcrowdsale() onlyOwner public returns (bool) { crowdsaleFinished = false; return true; }	0
function setMinterManager( address _newMinterManager ) public onlyOwner { emit MinterManagerSet(address(minterManager), _newMinterManager); minterManager = MinterManagementInterface(_newMinterManager); }	0
function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); require(block.timestamp >= 1545102693); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; }	0
contract ERC20ForcedTransfer is Ownable, ERC20 { event ForcedTransfer(address indexed account, uint256 amount, address indexed receiver); }	0
contract EtherDelta is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user,uint singleTokenValue, string orderType, uint blockNo); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user,string orderId); event Trade(address tokenGet, uint amountGet,uint amountReceived, address tokenGive, uint amountGive,uint amountSent, address get, address give,string orderId,uint orderFills); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); function() public{ require(false); } function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private { uint feeMakeXfer = safeMul(amount, feeMake) / (1 ether); uint feeTakeXfer = safeMul(amount, feeTake) / (1 ether); uint feeRebateXfer = 0; if (accountLevelsAddr != 0x0) { uint accountLevel = AccountLevels(accountLevelsAddr).accountLevel(user); if (accountLevel==1) feeRebateXfer = safeMul(amount, feeRebate) / (1 ether); if (accountLevel==2) feeRebateXfer = feeTakeXfer; }	0
constructor(string _merchantId) public { require(bytes(_merchantId).length > 0); merchantIdHash = keccak256(abi.encodePacked(_merchantId)); }	0
function validPurchase() internal view returns (bool) { require(weiRaised.add(msg.value) <= hardCap); bool withinPeriod = now >= startTime && now <= endTime; bool nonZeroPurchase = msg.value != 0; return withinPeriod && nonZeroPurchase; }	0
function transferFromAndCall(address from, address to, uint256 value) public returns (bool);	0
function approve(address _spender, uint256 _value)public returns (bool success);	0
function totalSupply() public view returns (uint256 supply);	0
function transfer(address to, uint tokens) external returns (bool success);	0
function approveAllAndCall(address _spender, bytes memory _extraData) public returns (bool success) { return approveAndCall(_spender, balanceOf[msg.sender], _extraData); }	0
function totalSupplyAt(uint _blockNumber) public view returns(uint256) {} } pragma solidity ^0.4.24; contract ERC20Snapshot is IERC20Snapshot, ERC20 { using SafeMath for uint256; struct Snapshot { uint128 fromBlock; uint128 value; }	0
function approve(address guy, uint wad) public returns (bool);	0
function setEndsAt(uint time) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= time); assert(startsAt <= time); assert(now <= endsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time <= crowdsale.startsAt()); } endsAt = time; EndsAtChanged(endsAt); }	0
function QWEWW() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
function getAgreement(uint256 agreementId) external view returns (	0
function mint( address _to, uint256 _amount ) hasMintPermission canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; }	0
function balanceOf(address _owner) view public returns (uint balance) { return balances[_owner]; }	0
function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); }	0
function getEngineerPrizePool() private view returns(uint256)	0
function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; }	0
function acceptOwnership() public { "require(msg.sender == newOwner, ""Sender should be the owner"");" emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); }	0
contract KVPMegaERC20 is MegaERC20, KVPStore { constructor(string memory name, string memory symbol, uint8 decimals, uint256 cap, string memory jsonKvp) public MegaERC20(name, symbol, decimals, cap) KVPStore(jsonKvp) {} }	0
function onERC721Received( address /*_from*/, address /*_to*/, uint256 /*_tokenId*/, bytes memory /*_data*/ ) public view returns (bytes4) { "require(msg.sender == estateRegistry, ""Token not accepted"");" return ERC721_Received; }	0
function safeDiv(uint a, uint b) internal returns (uint) { require(b > 0); uint c = a / b; require(a == b * c + a % b); return c; }	0
function hasRole(address _operator, string _role)	0
contract InvestToken is modERC20, modERC20Detailed, Ownable { uint8 constant public REFERRER_PERCENT = 3; uint8 constant public CASHBACK_PERCENT = 2; uint8 constant public HOLDERS_BUY_PERCENT_WITH_REFERRER = 7; uint8 constant public HOLDERS_BUY_PERCENT_WITH_REFERRER_AND_CASHBACK = 5; uint8 constant public HOLDERS_BUY_PERCENT = 10; uint8 constant public HOLDERS_SELL_PERCENT = 5; uint8 constant public TOKENS_DIVIDER = 10; uint256 constant public PRICE_INTERVAL = 10000000000; uint256 public swapTokensLimit; uint256 public investDividends; uint256 public casinoDividends; mapping(address => uint256) public ethStorage; mapping(address => address) public referrers; mapping(address => uint256) public investSize24h; mapping(address => uint256) public lastInvestTime; BonusToken public bonusToken; uint256 private holdersIndex; uint256 private totalInvestDividends; uint256 private totalCasinoDividends; uint256 private priceCoeff = 105e9; uint256 private constant a = 5e9; event Buy(address indexed buyer, uint256 weiAmount, uint256 tokensAmount, uint256 timestamp); event Sell(address indexed seller, uint256 weiAmount, uint256 tokensAmount, uint256 timestamp); event Reinvest(address indexed investor, uint256 weiAmount, uint256 tokensAmount, uint256 timestamp); event Withdraw(address indexed investor, uint256 weiAmount, uint256 timestamp); event ReferalsIncome(address indexed recipient, uint256 amount, uint256 timestamp); event InvestIncome(address indexed recipient, uint256 amount, uint256 timestamp); event CasinoIncome(address indexed recipient, uint256 amount, uint256 timestamp); modifier onlyGame() { require(msg.sender == gameAddress, 'The sender must be a game contract.'); _; } function () public payable { if (msg.sender != gameAddress) { address referrer; if (msg.data.length == 20) { referrer = bytesToAddress(bytes(msg.data)); } buyTokens(referrer); }	0
function authorized(address _address) public view returns (bool) { _address; } function authorize(address _address, bool _auth) public; function transferERC20Token(IERC20Token _token, address _to, uint256 _amount) public; }	0
function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency { if(finalized) { throw; }	0
function deactivateTokenSwitch() public onlyValidator { tokenSwitch = false; emit TokenSwitchDeactivated(); }	0
function fund(uint256 _amount)	0
function isOperator(address account) public view returns (bool) { return _operators.has(account); }	0
contract Owned { address public owner; event OwnershipTransferred(address indexed _from, address indexed _to); modifier onlyOwner { require(msg.sender == owner); _; } }	0
function timeOutBySender(uint _transactionID) public { Transaction storage transaction = transactions[_transactionID]; "require(transaction.status == Status.WaitingReceiver, ""The transaction is not waiting on the receiver."");" "require(now - transaction.lastInteraction >= feeTimeout, ""Timeout time has not passed yet."");" if (transaction.receiverFee != 0) { transaction.receiver.send(transaction.receiverFee); transaction.receiverFee = 0; } executeRuling(_transactionID, uint(RulingOptions.SenderWins)); }	0
function Owned() public { owner = msg.sender; }	0
contract SinglePullPayment is PayableOwnable { using SafeMath for uint256; event LogExecutorAdded(address executor); event LogExecutorRemoved(address executor); event LogPullPaymentExecuted( address customerAddress,	0
"constructor () public ERC20Detailed(""ReddTip"", ""RDT"", DECIMALS) {" _mint(msg.sender, INITIAL_SUPPLY); }	0
function burnFrom(address account, uint256 amount) external { require(amount <= _allowed[account][msg.sender]); _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount); _burn(account, amount); }	0
function recoverTokens(ERC20Interface _asset, address _receiver, uint _value) public onlyAssetOwner() returns(bool) { return _asset.transfer(_receiver, _value); }	0
function isContractMiniGame() public pure returns( bool _isContractMiniGame )	0
function trade( ERC20 srcToken, uint srcAmount, ERC20 destToken, address destAddress, uint conversionRate, bool validate ) public payable returns(bool); function getConversionRate(ERC20 src, ERC20 dest, uint srcQty, uint blockNumber) public view returns(uint);	0
function () public payable { revert (); }	0
function updateAuthority( address new_authority, DSAuthModes mode )	0
function mod(uint256 a, uint256 b) internal pure returns (uint256) { "require(b != 0, ""SafeMath: modulo by zero"");" return a % b; }	0
function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }"	0
function _update(uint256 amountToSwap) private { _infos[msg.sender].availableTokens = _infos[msg.sender].availableTokens.sub(amountToSwap); _infos[msg.sender].lastSwapTimestamp = now; }	0
contract Ownable { address private _owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { "require(isOwner(), ""Ownable: caller is not the owner"");" _; } }	0
contract Whitelist is Ownable, RBAC { event WhitelistedAddressAdded(address addr); event WhitelistedAddressRemoved(address addr); "string public constant ROLE_WHITELISTED = ""whitelist"";" modifier onlyWhitelisted() { checkRole(msg.sender, ROLE_WHITELISTED); _; } onlyOwner public { addRole(addr, ROLE_WHITELISTED); emit WhitelistedAddressAdded(addr); } public view returns (bool) { return hasRole(addr, ROLE_WHITELISTED); } onlyOwner public { for (uint256 i = 0; i < addrs.length; i++) { addAddressToWhitelist(addrs[i]); }	0
function getBool(uint256[] memory _history, uint256 _timestamp) internal pure returns (bool) { return findIndex(_history, _timestamp, 1) % 2 == 1; }	0
event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }	0
function getContractName(uint index) public view returns (string);	0
function getBounty(bytes32 question_id)	0
function allowance(address _owner, address _spender) public constant returns (uint256 remaining);	0
function transfer(address dst, uint wad) public returns (bool) { return transferFrom(msg.sender, dst, wad); }	0
function div(uint256 a, uint256 b) internal pure returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return a / b; }	0
function release () public { require (beneficiary != 0x0); TokenTimelock.release(); }	0
function EncryptedToken() TokenERC20(INITIAL_SUPPLY, 'GOOD', 'GD') payable public {} function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] >= _value); require (balanceOf[_to] + _value > balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); }	0
function isCrowdsaleFull() public view returns (bool);	0
function applyPayback(address _for, uint256 _amountWei) external returns (uint256 amountVouchers);	0
function max(int[] memory nums) public pure returns (int maxNum) { require(nums.length > 0); maxNum = -2 ** 255; for (uint i = 0; i < nums.length; i++) if (nums[i] > maxNum) maxNum = nums[i]; }	0
function withdrawAsset( address _assetAddress, uint _amount ) external returns (bool); function setTokenSwapAllowance ( address _tokenSwapAddress, bool _allowance ) external returns(bool); } pragma solidity ^0.4.24; contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { "require(!paused, ""The contract is paused"");" _; } modifier whenPaused() { "require(paused, ""The contract is not paused"");" _; } function pause() public onlyOwner whenNotPaused { paused = true; emit Pause(); } function unpause() public onlyOwner whenPaused { paused = false; emit Unpause(); } }	0
function isOwner() public view returns (bool) { return msg.sender == _owner; }	0
contract GlobalWhitelist is Ownable, Manageable { using SafeMath for uint256; mapping(address => bool) public isWhitelisted; bool public isWhitelisting = true; event ChangedWhitelisting(address indexed registrant, bool whitelisted); event GlobalWhitelistDisabled(address indexed manager); event GlobalWhitelistEnabled(address indexed manager); function addAddressesToWhitelist(address[] memory _addresses) public { for (uint256 i = 0; i < _addresses.length; i++) { addAddressToWhitelist(_addresses[i]); }	0
function _burn(address account, uint256 value) internal { require(account != 0); require(value <= _balances[account]); _totalSupply = _totalSupply.sub(value); _balances[account] = _balances[account].sub(value); emit Transfer(account, address(0), value); }	0
function buy(IERC20Token _connectorToken, uint256 _depositAmount, uint256 _minReturn) internal returns (uint256) { uint256 amount; uint256 feeAmount; (amount, feeAmount) = getPurchaseReturn(_connectorToken, _depositAmount); require(amount != 0 && amount >= _minReturn); Connector storage connector = connectors[_connectorToken]; if (connector.isVirtualBalanceEnabled) connector.virtualBalance = connector.virtualBalance.add(_depositAmount); assert(_connectorToken.transferFrom(msg.sender, this, _depositAmount)); token.issue(msg.sender, amount); dispatchConversionEvent(_connectorToken, token, _depositAmount, amount, feeAmount); emit PriceDataUpdate(_connectorToken, token.totalSupply(), getConnectorBalance(_connectorToken), connector.weight); return amount; }	0
contract ERC20Interface { string public name; string public symbol; uint8 public  decimals; uint public totalSupply; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }	0
function requireNotZero(uint val) internal pure { "require(val != 0, ""require not zero value"");" }	0
function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; }	0
} function totalSupply() public view returns (uint256) {} function balanceOf(address _owner) public view returns (uint256) { _owner; } function allowance(address _owner, address _spender) public view returns (uint256) { _owner; _spender; } function transfer(address _to, uint256 _value) public returns (bool success);	0
function transfer( address _to, uint256 _value, bytes _data ) public returns (bool);	0
function registerPullPayment( uint8 v, bytes32 r, bytes32 s, bytes32[2] memory _paymentDetails, address[2] memory _addresses, uint256 _paymentAmount, string memory _uniqueReferenceID ) public isExecutor() isValidByte32(_paymentDetails[0]) isValidByte32(_paymentDetails[1]) isValidNumber(_paymentAmount) isValidAddress(_addresses[0]) isValidAddress(_addresses[1]) pullPaymentDoesNotExists(_addresses[0], _paymentDetails[0]) { bytes32[2] memory paymentDetails = _paymentDetails; pullPayments[paymentDetails[0]].paymentDetails = _paymentDetails; pullPayments[paymentDetails[0]].paymentAmount = _paymentAmount; pullPayments[paymentDetails[0]].customerAddress = _addresses[0]; pullPayments[paymentDetails[0]].receiverAddress = _addresses[1]; pullPayments[paymentDetails[0]].uniqueReferenceID = _uniqueReferenceID; require(isValidRegistration( v, r, s, pullPayments[paymentDetails[0]]), Invalid pull payment registration - ECRECOVER_FAILED ); token.transferFrom( _addresses[0], _addresses[1], _paymentAmount ); emit LogPullPaymentExecuted( _addresses[0], _addresses[1], _paymentAmount, paymentDetails[0], paymentDetails[1], _uniqueReferenceID ); }	0
function releaseForeignToken(ERC20 _token, uint256 amount) onlyOwner { require(_token != token); _token.transfer(owner, amount); }	0
function setEnable(bool _enable) public onlyAdmin { if (_enable) { require(feeBurnerContract != address(0)); require(expectedRateContract != address(0)); require(kyberNetworkProxyContract != address(0)); }	0
constructor(string memory _name) public { name = _name; "symbol = ""SAS "";" decimals = 18; totalSupply = 96000000000000000000000000; balanceOf[msg.sender] = totalSupply; }	0
function symbol() public constant returns (string) {} function decimals() public constant returns (uint8) {} function totalSupply() public constant returns (uint256) {} function balanceOf(address _owner) public constant returns (uint256) { _owner; } function allowance(address _owner, address _spender) public constant returns (uint256) { _owner; _spender; } function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success);	0
function changeFundAddress(address newFundAddress) external onlyMerchant isEOA(newFundAddress) { merchantFundAddress = newFundAddress; }	0
function GetHodlTokensBalance(address tokenAddress) public view returns (uint256 balance) { require(tokenAddress != 0x0); for(uint256 i = 1; i < _currentIndex; i++) { Safe storage s = _safes[i]; if(s.user == msg.sender && s.tokenAddress == tokenAddress) balance += s.amount; } return balance; }	0
contract ERC20 { uint256 public totalSupply; bool public transfersEnabled; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }	0
function add(uint a, uint b) internal pure returns (uint) { require(safeToAdd(a, b)); return a + b; }	0
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (frozenAccount[msg.sender]) return false; require( (allowed[_from][msg.sender] >= _value) && (balances[_from] >= _value) && (_value > 0) && (_to != address(0)) && (balances[_to].add(_value) >= balances[_to]) && (msg.data.length >= (2 * 32) + 4) ); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; }	0
function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] >= _value); require (balanceOf[_to] + _value >= balanceOf[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); }	0
function burn(address account, uint256 value) public ownerOnly { require(account != address(0)); _totalSupply = _totalSupply.sub(value); _balances[account] = _balances[account].sub(value); emit Transfer(account, address(0), value); }	0
function minus(uint256 _a, uint256 _b) internal pure returns (uint256) { assert(_a >= _b); return _a - _b; }	0
function getCertifierDb()	0
contract DSAuthorizedEvents is DSAuthModesEnum { event DSAuthUpdate( address indexed auth, DSAuthModes indexed mode ); }	0
function changeOwner(address _addr) public onlyOwner { TeamOwner = _addr; }	0
function _removeMinter(address account) internal { minters.remove(account); emit MinterRemoved(account); }	0
function token() public view returns (address) { return _token; }	0
contract ReentrancyGuard { uint256 private _guardCounter; modifier nonReentrant() { _guardCounter += 1; uint256 localCounter = _guardCounter; _; require(localCounter == _guardCounter); } }	0
contract ICO is Ownable { using SafeMath for uint256; struct WhiteListRecord { uint256 offeredWei; uint256 lastPurchasedTimestamp; } OneledgerToken public token; address public wallet; uint256 public rate; mapping (address => WhiteListRecord) public whiteList; uint256 public initialTime; bool public saleClosed; uint256 public weiCap; uint256 public weiRaised; uint256 public TOTAL_TOKEN_SUPPLY = 1000000000 * (10 ** 18); event BuyTokens(uint256 weiAmount, uint256 rate, uint256 token, address beneficiary); event UpdateRate(uint256 rate); event UpdateWeiCap(uint256 weiCap); function() external payable { buyTokens(); } function addToWhiteList(address[] addresses, uint256 weiPerContributor) public onlyOwner { for (uint32 i = 0; i < addresses.length; i++) { whiteList[addresses[i]] = WhiteListRecord(weiPerContributor, 0); }	0
function getQueryFee()	0
function commitUpgrade() public returns(bool) { if (pendingVersion == 0x0) { return false; }	0
function setToken(address tokenAddress) onlyOwner public { token_address = tokenAddress; }	0
function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }"	0
function release() public { require(block.timestamp >= releaseTime); require(!distributed); for (uint256 i = 0; i < beneficiaries.length; i++) { address beneficiary = beneficiaries[i]; uint256 amount = tokenValues[i]; require(amount > 0); token.safeTransfer(beneficiary, amount); } distributed = true; }	0
function keyAtIndex(Set storage self, uint index) internal view returns(address) { return self.keyList[index]; }	0
function removeFromExistingOffer(uint256 offerNumber, uint256 amountOffers) public { address sender = msg.sender; require(sender == OpenOffers[offerNumber].maker); require(amountOffers <= OpenOffers[offerNumber].amount); OpenOffers[offerNumber].amount = OpenOffers[offerNumber].amount.sub(amountOffers); playerVault[sender] = playerVault[sender].add(amountOffers.mul(OpenOffers[offerNumber].betSize)); }	0
function symbol() public view returns (string _symbol);	0
function freeze(uint256 tokens) public returns (bool success);	0
contract ERC20 { event Transfer(address indexed from, address indexed to, uint256 value); }	0
contract KyberSwap { address public kyberAddress; address public daiAddress; address public ethAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public admin; uint public fees; modifier onlyAdmin() { "require(msg.sender == admin, ""Permission Denied"");" _; } }	0
contract ERC20Token is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0 && balances[_to] + _value > balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } }	0
constructor( address whitelistAddress, uint256 _startTime, uint256 _endTime, uint256 _hardcap, uint256 _rate, address _wallet, address _token, address _owner ) public FinalizableCrowdsale(_owner) Crowdsale(_startTime, _endTime, _hardcap, _rate, _wallet, _token) { setWhitelistContract(whitelistAddress); }	0
contract LympoToken is ERC20, Ownable { using SafeMath for uint; "string constant public name = ""Lympo tokens"";" "string constant public symbol = ""LYM"";" uint8 constant public decimals = 18; uint constant public TOKENS_PRE_ICO = 265000000e18; uint constant public TOKENS_ICO = 385000000e18; uint constant public TEAM_RESERVE = 100000000e18; uint constant public ECO_LOCK_13 = 73326000e18; uint constant public START_TIME = 1519815600; uint constant public LOCK_RELEASE_DATE_1_YEAR = START_TIME + 365 days; uint constant public LOCK_RELEASE_DATE_2_YEARS = START_TIME + 730 days; address public ecosystemAddr; address public advisersAddr; bool public reserveClaimed; bool public ecosystemPart1Claimed; bool public ecosystemPart2Claimed; address public airdropAddress; uint public airdropBalance; uint private _initialSupply = 1000000000e18; constructor(address _ownerAddr, address _advisersAddr, address _ecosystemAddr, address _airdropAddr, uint _airdropBalance) public Ownable(_ownerAddr){ advisersAddr = _advisersAddr; ecosystemAddr = _ecosystemAddr; _mint(owner(), _initialSupply); _transfer(owner(), address(this), TEAM_RESERVE.add(ECO_LOCK_13).add(ECO_LOCK_13)); airdropAddress = _airdropAddr; airdropBalance = _airdropBalance; if (airdropBalance != 0) { _transfer(owner(), airdropAddress, airdropBalance); }	0
function _clearApproval(uint256 tokenId) private { if (_tokenApprovals[tokenId] != address(0)) { _tokenApprovals[tokenId] = address(0); }	0
function getMiningDifficulty() public constant returns (uint);	0
contract ELD is StandardToken, OnlyOwner{ "string public constant name = ""electrumdark"";" "string public constant symbol = ""ELD"";" "string public constant version = ""1.0"";" uint256 public constant totalSupply = 3900000*10**18; uint256 private approvalCounts =0; uint256 private minRequiredApprovals =2; address public burnedTokensReceiver; }	0
function imax(int x, int y) internal pure returns (int z) { return x >= y ? x : y; }	0
function _approveMint(uint256 nonce)	0
function transferAdmin(address newAdmin) public onlyAdmin { require(newAdmin != address(0)); TransferAdminPending(pendingAdmin); pendingAdmin = newAdmin; }	0
function addAddressToWhitelist(address _address) public onlyManager onlyValidAddress(_address) { isWhitelisted[_address] = true; emit ChangedWhitelisting(_address, true); }	0
function getSwappableAmount(address swapper) external view returns (uint256) { return _infos[swapper].availableTokens; }	0
function hasBooster(address addr) public view returns (uint256 boostIdx)	0
function bytesToAddress (bytes b) pure public returns (address) { uint result = 0; for (uint i = b.length-1; i+1 > 0; i--) { uint c = uint(b[i]); uint to_inc = c * ( 16 ** ((b.length - i-1) * 2)); result += to_inc; } return address(result); }	0
function withdraw(address token, uint256 amount) returns (bool success) { if (safeSub(block.number, lastActiveTransaction[msg.sender]) < inactivityReleasePeriod) throw; if (tokens[token][msg.sender] < amount) throw; tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount); if (token == address(0)) { if (!msg.sender.send(amount)) throw; } else {	0
function appealPeriod(uint _disputeID) public view returns(uint start, uint end) {} function disputeStatus(uint _disputeID) public view returns(DisputeStatus status); function currentRuling(uint _disputeID) public view returns(uint ruling); }	0
function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a); return a - b; }	0
function _getBmcDaysAmountForUser(bytes32 _userKey, uint _date, uint _periodIdx) internal view returns (uint) { uint _lastPeriodForUserIdx = user2lastPeriodParticipated[_userKey]; if (_lastPeriodForUserIdx == 0) { return 0; } Period storage _transferPeriod = _lastPeriodForUserIdx <= _periodIdx ? periods[_lastPeriodForUserIdx] : periods[_periodIdx]; uint _lastTransferDate = _transferPeriod.transfer2date[_transferPeriod.user2lastTransferIdx[_userKey]]; uint _daysLong = (_date / 1 days) - (_lastTransferDate / 1 days); uint _bmcDays = _transferPeriod.user2bmcDays[_userKey]; return _bmcDays.add(_transferPeriod.user2balance[_userKey] * _daysLong); }	0
function _disableWhitelist(address addr) internal { if (whitelist[addr] == 2) { whitelist[addr] = 1; } else { }	0
function () payable public { asyncSend(beneficiary, msg.value); }	0
function unsetImplementation(string contractName) public onlyOwner whenNotFrozen { implementations[contractName] = address(0); emit ImplementationChanged(contractName, address(0)); }	0
function enableTrade()	0
function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;	0
function calcSrcAmount(ERC20 src, ERC20 dest, uint destAmount, uint rate) internal view returns(uint) { return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate); }	0
function transfer(address to, uint256 value) public returns (bool) { require(value <= _balances[msg.sender]); require(to != address(0)); _balances[msg.sender] = _balances[msg.sender].sub(value); _balances[to] = _balances[to].add(value); emit Transfer(msg.sender, to, value); return true; }	0
function requestEthereumPrice(address _oracle, string _jobId)	0
function div(uint256 _a, uint256 _b) internal pure returns (uint256) { uint256 c = _a / _b; return c; }	0
function transfer(address to, uint value) public returns(bool ok);	0
function safeAdd(uint256 x, uint256 y) internal pure returns(uint256) { uint256 z = x + y; assert((z >= x) && (z >= y)); return z; }	0
constructor( string memory name, string memory symbol, uint8 decimals, uint256 cap, uint256 initialSupply, bool transferEnabled ) public BaseERC1363Token(name, symbol, decimals, cap, initialSupply) { if (transferEnabled) { enableTransfer(); } }	0
function isOwner() public view returns(bool) { return msg.sender == _owner; }	0
function removeAddressFromWhitelist(address addr)	0
function setOwner(address _newOwner) public;	0
function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } }	0
function disbandTo(address to) onlyOwner external { uint cosignersNum = m_cosigners.length; uint approved = m_cosignersApprovedDisband.length; if (cosignersNum > 6) { require(approved > 2); } if (cosignersNum > 3) { require(approved > 1); } require(approved > 0); to.transfer(address(this).balance); }	0
function grantAbilities( address _target, uint256 _abilities ) external hasAbilities(ABILITY_TO_MANAGE_ABILITIES) { addressToAbility[_target] |= _abilities; if((_abilities & ABILITY_TO_MANAGE_ABILITIES) == ABILITY_TO_MANAGE_ABILITIES) { zeroAbilityCount = zeroAbilityCount.add(1); } emit GrantAbilities(_target, _abilities); }	0
function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; }	0
function _releaseTo(address target) internal { uint256 unreleased = releasableAmount(); released = released.add(unreleased); token.safeTransfer(target, unreleased); Released(released); }	0
function _removeMinter(address account) internal { _minters.remove(account); emit MinterRemoved(account); }	0
function addProxy(address account) public onlyOwner { _proxies.add(account); emit ProxyAdded(account); }	0
function transfer(address _to, uint256 _value) public whenStarted returns (bool) { return super.transfer(_to, _value); }	0
function upgradeabilityOwner() public view returns (address) { return _upgradeabilityOwner; }	0
contract EmissionProvider is OracleContractAdapter, ServiceAllowance, EmissionProviderEmitter { uint constant EMISSION_PROVIDER_ERROR_SCOPE = 107000; uint constant EMISSION_PROVIDER_ERROR_WRONG_STATE = EMISSION_PROVIDER_ERROR_SCOPE + 1; uint constant EMISSION_PROVIDER_ERROR_INSUFFICIENT_BMC = EMISSION_PROVIDER_ERROR_SCOPE + 2; uint constant EMISSION_PROVIDER_ERROR_INTERNAL = EMISSION_PROVIDER_ERROR_SCOPE + 3; using SafeMath for uint; enum State { Init, Waiting, Sale, Reached, Destructed } uint public startDate; uint public endDate; uint public tokenSoftcapIssued; uint public tokenSoftcap; uint tokenHardcapIssuedValue; uint tokenHardcapValue; address public token; address public bonusToken; address public profiterole; mapping(address => bool) public whitelist; bool public destructed; bool finishedHardcap; bool needInitialization; modifier onlySale { var (hardcapState, softcapState) = getState(); if (!(State.Sale == hardcapState || State.Sale == softcapState)) { _emitError(EMISSION_PROVIDER_ERROR_WRONG_STATE); assembly { mstore(0, 107001) return (0, 32) } }	0
function approve(address spender, uint value);	0
contract DanskeBankCertifiedDeposit is ERC20 {using SafeMath for uint256; "string public constant symbol = ""SEK.SwedishKrona"";" "string public constant name = ""Danske Bank Certified Deposit- Danske Bank A/S-Stock price: DANSKE (CPH) Subsidiaries:Danica Pension F&#246;rs&#228;kringsaktiebolag (publ.)"";" uint public constant decimals = 18; uint256 _totalSupply = 999000000000000000000 * 10 ** 18; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; modifier onlyOwner() { if (msg.sender != owner) { revert(); } _; }	0
function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private { uint256 lastTokenIndex = _ownedTokens[from].length.sub(1); uint256 tokenIndex = _ownedTokensIndex[tokenId]; if (tokenIndex != lastTokenIndex) { uint256 lastTokenId = _ownedTokens[from][lastTokenIndex]; _ownedTokens[from][tokenIndex] = lastTokenId; _ownedTokensIndex[lastTokenId] = tokenIndex; } _ownedTokens[from].length--; }	0
contract Token { function totalSupply() view returns (uint256 supply) {} function balanceOf(address _owner) view returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) view returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event setNewBlockEvent(string SecretKey_Pre, string Name_New, string TxHash_Pre, string DigestCode_New, string Image_New, string Note_New); }	0
constructor(address mToken, address mkContract) public  { minedToken = mToken; kingContract = mkContract; }	0
function isContractMiniGame() external pure returns( bool _isContractMiniGame );	0
contract ERC20 { event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed from, address indexed spender, uint256 value); string public symbol; }	0
function tokenByIndex(uint256 index) public view returns (uint256);	0
function getBalance(ERC20 token, address user) public view returns(uint) { if (token == ETH_TOKEN_ADDRESS) return user.balance; else return token.balanceOf(user); }	0
function getUint(bytes32 _key) external view returns (uint);	0
function getTokens() payable canDistr  public { uint256 tokens = 0; require( msg.value >= MIN_CONTRIBUTION ); require( msg.value > 0 ); tokens = tokensPerEth.mul(msg.value) / 1 ether; address investor = msg.sender; if (tokens > 0) { distr(investor, tokens); } if (totalDistributed >= totalSupply) { distributionFinished = true; } }	0
function startsale() onlyOwner public returns (bool) { distributionFinished = false; return true; }	0
function balanceOfAt(address _owner, uint _blockNumber) public constant returns (uint) { if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) { if (address(parentToken) != 0) { return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock)); } else {	0
function quickConvertPrioritized(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, uint256 _block, uint8 _v, bytes32 _r, bytes32 _s)	0
function currentCostOfDot(address, bytes32, uint256) public view returns (uint256);	0
contract CappedToken is MintableToken { uint256 public cap; }	0
function _forwardTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference, address _sender) public returns(bool);	0
function requestEthereumChange(address _oracle, string _jobId)	0
contract OrbsValidators is Ownable, IOrbsValidators, IOrbsNetworkTopology { uint public constant VERSION = 1; uint internal constant MAX_VALIDATOR_LIMIT = 100; uint public validatorsLimit; IOrbsValidatorsRegistry public orbsValidatorsRegistry; address[] internal approvedValidators; mapping(address => uint) internal approvalBlockNumber; }	0
function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public { transferFrom(from, to, tokenId); require(_checkOnERC721Received(from, to, tokenId, _data)); }	0
function updateTreasury(address _treasury) external onlyContractOwner returns (uint) { require(_treasury != 0x0); treasury = _treasury; return OK; }	0
function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) { require(index < balanceOf(owner)); return _ownedTokens[owner][index]; }	0
function deposit(address _from, uint256 _amountDai) internal { "require(_from != address(0) && _amountDai > 0, ""invalid parameter(s)"");" dai.safeTransferFrom(msg.sender, address(this), _amountDai); if (!paused()) { "require(dai.allowance(address(this), MONEY_MARKET_ADDRESS) == 0, ""non-zero initial moneyMarket allowance"");" "require(dai.approve(MONEY_MARKET_ADDRESS, _amountDai), ""approving moneyMarket failed"");" uint256 errorCode = moneyMarket.supply(DAI_ADDRESS, _amountDai); "require(errorCode == 0, ""supply failed"");" "require(dai.allowance(address(this), MONEY_MARKET_ADDRESS) == 0, ""allowance not fully consumed by moneyMarket"");" } deposits[_from] = deposits[_from].add(_amountDai); deposited = deposited.add(_amountDai); emit Deposited(_from, _amountDai); }	0
function setName(string _name) public isOwner { name = _name; }	0
function transfer(address _to, uint256 _value) returns (bool success) { _transfer(msg.sender, _to, _value); }	0
function Cherryblossom() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
function chkBalance() public view returns (uint) { return token.balanceOf(this); }	0
function transferFrom(address _from, address _to, uint256 _value) returns (bool) { require(_to != address(0)); require(_value <= _balances[_from]); require(_value <= _allowed[_from][msg.sender]); _balances[_from] = _balances[_from].sub(_value); _balances[_to] = _balances[_to].add(_value); _allowed[_from][msg.sender] = _allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }	0
function optIn() public returns(bool) { delete userOptOutVersion[msg.sender]; emit OptedIn(msg.sender, latestVersion); return true; }	0
function tokenFallback(address _from, uint _value, bytes _data) public;	0
function reclaimToken(ERC20Basic token) external onlyOwner { uint256 balance = token.balanceOf(this); token.safeTransfer(owner, balance); }	0
constructor (bytes32 symbol_) public { symbol = symbol_; }	0
function vote(bytes32 _id, bool _inFavor) external onlyValidDelegate { Voting storage voting = votings[_id]; require(voting.id == _id); require(voting.timestamp.add(votingPeriod) > block.timestamp); address voter = msg.sender; for (uint256 index = 0; index < voting.voters.length; index++) { if (voting.voters[index] == voter) { return; }	0
function tokensToEthereum_(uint256 _tokens)	0
function allowance(address _owner, address _spender)	0
function getChallengeNumber() public constant returns (bytes32) { return challengeNumber; }	0
function setTokenSwapAllowance ( address _tokenSwapAddress, bool _allowance ) external returns(bool); } pragma solidity ^0.4.24; contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { "require(!paused, ""The contract is paused"");" _; } modifier whenPaused() { "require(paused, ""The contract is not paused"");" _; } function pause() public onlyOwner whenNotPaused { paused = true; emit Pause(); } function unpause() public onlyOwner whenPaused { paused = false; emit Unpause(); } }	0
function setPaymentSettings(string key, string value) external onlyOwner { paymentSettingsMap[key] = value; }	0
function totalSupply() public view returns (uint) { return totalTokens; }	0
function approveTransfer(uint256 nonce)	0
function allowance( address owner, address spender ) external view returns (uint256); event Transfer( address indexed from, address indexed to, uint256 value ); event Approval( address indexed owner, address indexed spender, uint256 value ); } pragma solidity ^0.4.24; library SafeTransfer { function _safeTransferFrom( address _tokenAddress, address _from, address _to, uint256 _value ) internal returns (bool result) { IBadERC20(_tokenAddress).transferFrom(_from, _to, _value); assembly { switch returndatasize() case 0 { result := not(0) } case 32 { returndatacopy(0, 0, 32) result := mload(0) } default { revert(0, 0) } }	0
function startTimestamp() public view returns (uint32) { return _startTimestamp; }	0
function calculateEthereumReceived(uint256 _tokensToSell)	0
function burn(uint256 _value) onlyOwner public { require(_value <= balances[msg.sender]); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); totalDistributed = totalDistributed.sub(_value); emit Burn(burner, _value); }	0
function updateTokensPerEth(uint _tokensPerEth) public onlyOwner { tokensPerEth = _tokensPerEth; emit TokensPerEthUpdated(_tokensPerEth); }	0
function getProfitFromSender() public view returns(uint256){ return getProfit(msg.sender); }	0
function doDisown() public onlyOwner { disown(); emit LogDisown(now); }	0
function getMsgSender( ) public view returns(address) { return msg.sender; }	0
function () public{ revert(); }	0
function transfer(address to, uint tokens) public returns (bool success){ require(balances[msg.sender] >= tokens && tokens > 0 && to != address(0x0) && whitelist[msg.sender] && whitelist[to]); executeTransfer(msg.sender,to, tokens); emit Transfer(msg.sender, to, tokens); return true; }	0
constructor( uint256 _fundingStartTime, uint256 _fundingEndTime, address _borrower, uint256 _annualInterest, uint256 _totalLendingAmount, uint256 _lendingDays, address _storageAddress, address _localNode, address _ethicHubTeam, uint256 _ethichubFee, uint256 _localNodeFee ) EthicHubBase(_storageAddress) public { "require(_fundingEndTime > fundingStartTime, ""fundingEndTime should be later than fundingStartTime"");" "require(_borrower != address(0), ""No borrower set"");" "require(ethicHubStorage.getBool(keccak256(abi.encodePacked(""user"", ""representative"", _borrower))), ""Borrower not registered representative"");" "require(_localNode != address(0), ""No Local Node set"");" "require(_ethicHubTeam != address(0), ""No EthicHub Team set"");" "require(ethicHubStorage.getBool(keccak256(abi.encodePacked(""user"", ""localNode"", _localNode))), ""Local Node is not registered"");" "require(_totalLendingAmount > 0, ""_totalLendingAmount must be > 0"");" "require(_lendingDays > 0, ""_lendingDays must be > 0"");" "require(_annualInterest > 0 && _annualInterest < 100, ""_annualInterest must be between 0 and 100"");" version = 6; reclaimedContributions = 0; reclaimedSurpluses = 0; borrowerReturnDays = 0; fundingStartTime = _fundingStartTime; fundingEndTime = _fundingEndTime; localNode = _localNode; ethicHubTeam = _ethicHubTeam; borrower = _borrower; annualInterest = _annualInterest; totalLendingAmount = _totalLendingAmount; lendingDays = _lendingDays; ethichubFee = _ethichubFee; localNodeFee = _localNodeFee; state = LendingState.Uninitialized; }	0
function burnFrom(address account, uint256 amount) public whenNotPaused returns (bool) { _burn(account, amount); "_approve(account, msg.sender, _allowances[account][msg.sender].sub(amount, ""VOKEN: burn amount exceeds allowance""));" return true; }	0
function addMinter(address _minter) public onlyOwner { addRole(_minter, ROLE_MINTER); }	0
function isValidRegistration( uint8 v, bytes32 r, bytes32 s, PullPayment memory _pullPayment ) internal pure returns (bool) { return ecrecover( keccak256( abi.encodePacked( _pullPayment.paymentDetails[0], _pullPayment.paymentDetails[1], _pullPayment.paymentAmount, _pullPayment.customerAddress, _pullPayment.receiverAddress, _pullPayment.uniqueReferenceID ) ), v, r, s) == _pullPayment.customerAddress; }	0
} contract Proxy { function _delegate(address implementation) internal { assembly { calldatacopy(0, 0, calldatasize) let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0) returndatacopy(0, 0, returndatasize) switch result case 0 { revert(0, returndatasize) } default { return(0, returndatasize) } }	0
contract HistoricATD is Ownable, Pausable { event Distributed( uint256 indexed date, address indexed lockedWallet, address indexed unlockWallet, uint256 ratioDTV, uint256 ratioDecimals, uint256 dailyTradedVolume, uint256 amount, bytes32 transaction ); event TotalDistributed( uint256 indexed date, uint256 dailyTradedVolume, uint256 amount, bytes32 transaction ); function emitDistribute( uint256[] memory dates, uint256[] memory dailyTradedVolumes, address[] memory lockedWallets, address[] memory unlockWallets, uint256[] memory ratioDTVs, uint256[] memory ratioDecimals, uint256[] memory amounts, bytes32[] memory transactions ) public whenNotPaused { "require(dates.length == dailyTradedVolumes.length, ""dailyTradedVolumes length is different"");" "require(dates.length == lockedWallets.length, ""lockedWallets length is different"");" "require(dates.length == unlockWallets.length, ""unlockWallets length is different"");" "require(dates.length == ratioDTVs.length, ""ratioDTVs length is different"");" "require(dates.length == ratioDecimals.length, ""ratioDecimals length is different"");" "require(dates.length == amounts.length, ""amounts length is different"");" "require(dates.length == transactions.length, ""transactions length is different"");" for (uint256 i = 0; i < dates.length; i++) { emit Distributed( dates[i], lockedWallets[i], unlockWallets[i], ratioDTVs[i], ratioDecimals[i], dailyTradedVolumes[i], amounts[i], transactions[i] ); }	0
function allowance(address _owner, address _spender) public view returns(uint256 remaining);	0
function decimals() public view returns (uint8 _decimals);	0
pragma solidity >=0.4.22 <0.6.0;	0
function getFreeMiner(address _addr) public isNotOver disableContract	0
function _transferOwnership(address newOwner) internal { require(newOwner != address(0)); emit OwnershipTransferred(_owner, newOwner); _owner = newOwner; }	0
contract UpgradeAgent { uint public originalSupply; }	0
function approve(address _spender, uint256 _value) public returns (bool success); } function balanceOf(address _owner) public view returns (uint256) { _owner; } function allowance(address _owner, address _spender) public view returns (uint256) { _owner; _spender; }	0
function burn(address from, uint256 amount) public ownerOnly canMint returns (bool) { require(from != address(0)); _totalSupply = _totalSupply.sub(amount); _balances[from] = _balances[from].sub(amount); emit Burn(from, amount); emit Transfer(from, address(0), amount); }	0
function changeMonethaVault(address newVault) external onlyOwner whenNotPaused { monethaVault = newVault; }	0
function getValidatorsBytes20() external view returns (bytes20[]) { address[] memory validatorAddresses = getValidators(); uint validatorAddressesLength = validatorAddresses.length; bytes20[] memory result = new bytes20[](validatorAddressesLength); for (uint i = 0; i < validatorAddressesLength; i++) { result[i] = bytes20(validatorAddresses[i]); } return result; }	0
function PermissionGroups() public { admin = msg.sender; }	0
contract ERC20 is IERC20 { using SafeMath for uint256; mapping (address => uint256) internal _balances; mapping (address => mapping (address => uint256)) private _allowed; uint256 private _totalSupply; }	0
function removeAddressesFromWhitelist(address[] memory _addresses) public { for (uint256 i = 0; i < _addresses.length; i++) { removeAddressFromWhitelist(_addresses[i]); }	0
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { uint256 _allowance = allowed[_from][msg.sender]; require(_value <= _allowance); require(balances[_to] + _value > balances[_to]); _transfer(_from,_to,_value); allowed[_from][msg.sender] = _allowance.safeSub(_value); emit Transfer(_from, _to, _value); return true; }	0
function onTransferReceived(address _operator, address _from, uint256 _value, bytes _data) external returns (bytes4);	0
function issue(address _to, uint256 _amount) public;	0
function _tokensOfOwner(address owner) internal view returns (uint256[] storage) { return _ownedTokens[owner]; }	0
function withdrawAltcoinTokens(address anycontract) onlyOwner public returns (bool) { AltcoinToken anytoken = AltcoinToken(anycontract); uint256 amount = anytoken.balanceOf(address(this)); return anytoken.transfer(owner, amount); }	0
function _performTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference, address _sender) public returns(bool);	0
function EmissionProvider( address _token, address _bonusToken, address _profiterole, uint _startDate, uint _endDate, uint _tokenSoftcap, uint _tokenHardcap ) public { require(_token != 0x0); require(_bonusToken != 0x0); require(_profiterole != 0x0); require(_startDate != 0); require(_endDate > _startDate); require(_tokenSoftcap != 0); require(_tokenHardcap >= _tokenSoftcap); require(Profiterole(_profiterole).bonusToken() == _bonusToken); token = _token; bonusToken = _bonusToken; profiterole = _profiterole; startDate = _startDate; endDate = _endDate; tokenSoftcap = _tokenSoftcap; tokenHardcapValue = _tokenHardcap - _tokenSoftcap; needInitialization = true; }	0
function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; }	0
contract ERC20Interface{	0
function convertInternal(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn)	0
function allowance(address _owner, address _spender)public view returns (uint remaining);	0
function safeToAdd(uint a, uint b) internal pure returns (bool) { return a + b >= a; }	0
function deposit() payable { tokens[address(0)][msg.sender] = safeAdd(tokens[address(0)][msg.sender], msg.value); lastActiveTransaction[msg.sender] = block.number; Deposit(address(0), msg.sender, msg.value, tokens[address(0)][msg.sender]); }	0
function auctionActions() internal returns(IAuctionActions) { return IAuctionActions(registry.addressOf(ContractIds.AUCTION_ACTIONS)); }	0
contract IMO is ERC20, ERC20Detailed { "string private _name = ""IMO"";" "string private _symbol = ""IMO"";" uint8 private _decimals = 18; uint256 public initialSupply = 5000000000 * (10 ** uint256(_decimals)); }	0
function storeProfileHashed(string _profileHashed) public { profileHashed[msg.sender] = _profileHashed; emit onStoreProfileHash(msg.sender, _profileHashed); }	0
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; }	0
function removeCertifier(address certifier)	0
function allowTransferFrom(address _from) public onlyRole('admin') returns(bool) { whitelist[_from] = true; return true; }	0
function setWhiteList(WhiteListInterface whiteList) public onlyAdmin { WhiteListContractSet(whiteList, whiteListContract); whiteListContract = whiteList; }	0
function _transferToICAPWithReference(bytes32 _icap, uint _value, string _reference, address _sender)	0
contract EternalStorageProxyForStormMultisender is OwnedUpgradeabilityProxy, EternalStorage { function EternalStorageProxyForStormMultisender(address _owner) public OwnedUpgradeabilityProxy(_owner) {} }	0
function _checkAndCallApprove( address spender, uint256 value, bytes data ) internal returns (bool) { if (!spender.isContract()) { return false; } bytes4 retval = IERC1363Spender(spender).onApprovalReceived( msg.sender, value, data ); return (retval == _ERC1363_APPROVED); }	0
contract CanReclaimToken is Ownable { using SafeERC20 for ERC20Basic; }	0
function getPaymentOf(address beneficiary)	0
function swap() external onlyWhitelisted { if (now >= _lastReset + _period) { _reset(); }	0
function removeController( address _controller ) public onlyOwner { require(_controller != address(0), Controller must be a non-zero address); require(controllers[_controller] != address(0), Worker must be a non-zero address); controllers[_controller] = address(0); emit ControllerRemoved(_controller); }	0
function fulfillEthereumPrice(bytes32 _requestId, uint256 _price)	0
function getContentHash(bytes32 question_id)	0
function setBalanceOf(address account, uint value)	0
function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }"	0
masterCopy = _masterCopy; } constructor(address _masterCopy) public Proxy(_masterCopy) {}	0
function _transfer(address _from, address _to, uint256 _value)  internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); uint256 previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }	0
function balanceOf(address owner) public view returns (uint256) { require(owner != address(0)); return _ownedTokensCount[owner]; }	0
contract NullFinalizeAgentExt is FinalizeAgent { CrowdsaleExt public crowdsale; function distributeReservedTokens(uint reservedTokensDistributionBatch) public { } function finalizeCrowdsale() public { } }	0
function _addWhitelistAdmin(address account) internal { _whitelistAdmins.add(account); emit WhitelistAdminAdded(account); }	0
contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } modifier hasMintPermission() { require(msg.sender == owner); _; } }	0
function deleteElement(uint64[] storage array, uint64 element) internal { uint lastIndex = array.length.sub(1); for (uint i = 0; i < array.length; i++) { if (array[i] == element) { array[i] = array[lastIndex]; delete(array[lastIndex]); array.length = lastIndex; break; }	0
function burn(uint256 value) public { _burn(msg.sender, value); }	0
function min(uint x, uint y) internal pure returns (uint z) { return x <= y ? x : y; }	0
function changeOwner(address _newOwner) public onlyBy(owner) returns (bool success){ require(_newOwner != address(0)); address oldOwner = owner; owner = _newOwner; emit OwnerChanged(oldOwner, _newOwner); return true; }	0
function withdraw() onlyStronghands() public { address _customerAddress = msg.sender; uint256 _dividends = myDividends(false); payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude); _dividends += referralBalance_[_customerAddress]; referralBalance_[_customerAddress] = 0; _customerAddress.transfer(_dividends); onWithdraw(_customerAddress, _dividends); }	0
function popFirstFromArray(address[] array) pure public returns (address[] memory)	0
contract Claimable is Ownable { address public pendingOwner; modifier onlyPendingOwner() { require(msg.sender == pendingOwner); _; } }	0
function setOwner(address _owner)	0
constructor () public { owner = msg.sender; maxSalesAllowed = 2; transfersBetweenSalesAllowed = true; }	0
function getLastTier() public constant returns(address) { if (joinedCrowdsalesLen > 0) return joinedCrowdsales[joinedCrowdsalesLen - 1]; else return address(0); }	0
constructor () public{ owner = msg.sender; IsInitialized = true; }	0
function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; }	0
contract BaseCertoChainContract { address creator; address owner; bool public isSealed; modifier onlyBy(address _account) { require(msg.sender != _account); _; } modifier onlyIfNotSealed() { if (isSealed) revert(); _; } {               selfdestruct(owner);     } {           creator = _creator; "emit EventReady(address(this),""setCreator"");" } {           owner = _owner; "emit EventReady(address(this),""SetOwner"");" } function setSealed() public  onlyBy(owner)  { isSealed = true;  emit EventSealed(address(this));   } event  EventSealed(address self); event  EventSetCreator(address self);	0
function HexelErc20Token(string _name, string _symbol, uint256 _initialSupply, address _depositTo) public { name = _name; symbol = _symbol; if (_initialSupply > 0) { mint(_depositTo, _initialSupply); } }	0
function flushTokens(address tokenContractAddress) public { ERC20Interface instance = ERC20Interface(tokenContractAddress); var forwarderAddress = address(this); var forwarderBalance = instance.balanceOf(forwarderAddress); if (forwarderBalance == 0) { return; } if (!instance.transfer(parentAddress, forwarderBalance)) { revert(); } }	0
function withdrawable() external view returns (uint256);	0
contract InvestLTCS is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; address _tokenContract = 0x6bf91fa5472b5a28278b5027e9120c78f1df4127; AltcoinToken thetoken = AltcoinToken(_tokenContract); uint256 public tokensPerEth = 50000e4; uint256 public tokensPerAirdrop = 5e4; uint256 public bonus = 0; uint256 public airdropcounter = 0; uint256 public constant minContribution = 1 ether / 1000; uint256 public constant extraBonus = 1 ether / 10; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Distr(address indexed to, uint256 amount); event TokensPerEthUpdated(uint _tokensPerEth); event TokensPerAirdropUpdated(uint _tokensPerEth); modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { if (newOwner != address(0)) { owner = newOwner; }	0
function approveDelegate(address _delegate) external onlyOwnerOrDelegateApprover onlyKnownDelegate(_delegate) { approveDelegateInternal(_delegate); }	0
function getBond(bytes32 question_id)	0
function addCertificationDocumentToSelf(bytes32 document)	0
function hasOnlyDomainLevelCharacters(string memory str) internal pure returns (bool) { bytes memory b = bytes(str); for(uint i; i<b.length; i++) { bytes1 char = b[i]; if (! ( (char >= 0x30 && char <= 0x39) || (char >= 0x41 && char <= 0x5A) || (char >= 0x61 && char <= 0x7A) || (char == 0x2d) )) return false; } return true; }	0
function getState() public view returns (State) { if(finalized) return State.Finalized; else if (address(finalizeAgent) == 0) return State.Preparing; else if (!finalizeAgent.isSane()) return State.Preparing; else if (!pricingStrategy.isSane(address(this))) return State.Preparing; else if (block.timestamp < startsAt) return State.PreFunding; else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding; else if (isMinimumGoalReached()) return State.Success; else return State.Failure; }	0
function freeze(address _to,uint256 _value) public returns (bool success) { require(balances[_to] >= _value); require(_value > 0); balances[_to] = balances[_to].sub(_value); freezes[_to] = freezes[_to].add(_value); emit Freeze(_to, _value); return true; }	0
function getInactivityReleasePeriod() view returns (uint256)	0
function getLendingDays() public view returns(uint) { if(borrowerReturnDays > 0) { return borrowerReturnDays; } else { return getDaysPassedBetweenDates(fundingEndTime, now); }	0
function getMiningTarget() public constant returns (uint) { return miningTarget; }	0
function storeInt(uint256[] storage _history, uint256 _value) internal { _history.push(block.timestamp); _history.push(_value); }	0
function addParty( address _participant, ERC20 _token, uint256 _tokensTotal ) external onlyOwner canAddParty { "require(_participant != address(0), ""_participant is invalid address"");" "require(_token != address(0), ""_token is invalid address"");" "require(_tokensTotal > 0, ""Positive amount of tokens is required"");" require( isParticipant[_participant] == false, Unable to add the same party multiple times ); isParticipant[_participant] = true; SwapOffer memory offer = SwapOffer({ participant: _participant, token: _token, tokensTotal: _tokensTotal, withdrawnTokensTotal: 0 }); participants.push(offer.participant); offerByToken[offer.token] = offer; tokenByParticipant[offer.participant] = offer.token; emit AddParty(offer.participant, offer.token, offer.tokensTotal); }	0
pragma solidity >=0.4.24;	0
function supportsInterface(bytes4 interfaceId) external view returns (bool) { return _supportedInterfaces[interfaceId]; }	0
function addTokenAllocation( ERC20 _token, address[] _receivers, uint256[] _amounts ) external onlyOwner canAddTokenAllocation { "require(_token != address(0), ""Invalid token"");" "require(_receivers.length == _amounts.length, ""Invalid arguments' lengths"");" "require(offerByToken[_token].token != address(0), ""There is no swap offer with this token"");" "require(!isTokenAllocated[_token], ""Token has been allocated already"");" uint256 totalAllocation = 0; uint256 i; for (i = 0; i < _receivers.length; i++) { "require(_receivers[i] != address(0), ""Invalid receiver"");" "require(_amounts[i] > 0, ""Positive amount is required"");" require( allocatedTokens[_token][_receivers[i]] == 0, Tokens for this receiver have been allocated already ); if (!isReceiver[_receivers[i]]) { receivers.push(_receivers[i]); isReceiver[_receivers[i]] = true; }	0
function setRawTotalDebt(uint _rawTotalDebt) public; function setRawTotalBalance(uint _rawTotalBalance) public; function setRawBalanceOf(address _borrower, uint _rawBalance) public; function setRawDebt(address _borrower, uint _rawDebt) public; function setTotalBorrowed(address _borrower, uint _totalBorrowed) public; function debtScalingFactor() public view returns (uint256); function balanceScalingFactor() public view returns (uint256); function debtRawToActual(uint256 _raw) public view returns (uint256); function debtActualToRaw(uint256 _actual) public view returns (uint256); function balanceRawToActual(uint256 _raw) public view returns (uint256); function balanceActualToRaw(uint256 _actual) public view returns (uint256); function getVaults(address _vault, uint256 _balanceOf) public view returns(address[]); function transferERC20Token(IERC20Token _token, address _to, uint256 _amount) public; function oracleValue() public view returns(uint256); function emitBorrow(address _borrower, uint256 _amount) public; function emitRepay(address _borrower, uint256 _amount) public; function emitDeposit(address _borrower, uint256 _amount) public; function emitWithdraw(address _borrower, address _to, uint256 _amount) public; function emitLiquidate(address _borrower) public; function emitAuctionStarted(address _borrower) public; function emitAuctionEnded(address _borrower, address _highestBidder, uint256 _highestBid) public; function setAuctionAddress(address _borrower, address _auction) public; } function totalBorrowed(address _vault) public view returns (uint256) { _vault; } function rawBalanceOf(address _vault) public view returns (uint256) { _vault; } function rawDebt(address _vault) public view returns (uint256) { _vault; } function rawTotalBalance() public view returns (uint256); function rawTotalDebt() public view returns (uint256); function collateralBorrowedRatio() public view returns (uint256); function amountMinted() public view returns (uint256); function debtScalePrevious() public view returns (uint256); function debtScaleTimestamp() public view returns (uint256); function debtScaleRate() public view returns (int256); function balScalePrevious() public view returns (uint256); function balScaleTimestamp() public view returns (uint256); function balScaleRate() public view returns (int256); function liquidationRatio() public view returns (uint32); function maxBorrowLTV() public view returns (uint32); function borrowingEnabled() public view returns (bool); function biddingTime() public view returns (uint); function setType(bool _type) public; function create(address _vault) public; function setCollateralBorrowedRatio(uint _newRatio) public; function setAmountMinted(uint _amountMinted) public; function setLiquidationRatio(uint32 _liquidationRatio) public; function setMaxBorrowLTV(uint32 _maxBorrowLTV) public; function setDebtScalingRate(int256 _debtScalingRate) public;	0
constructor (CouponToken _company_token) public { owner = msg.sender; PartnerAccount = 0x0db03B6CDe0B2d427C64a04FeAfd825938368f1F; company_token = _company_token; originalBalance = 11111111 * 10 ** 18; currentBalance = originalBalance; alreadyTransfered = 0; startDateOfPayments = 1569888001; endDateOfPayments = 1590969601; periodOfOnePayments = 24 * 60 * 60; daysOfPayments = (endDateOfPayments - startDateOfPayments) / periodOfOnePayments; limitPerPeriod = originalBalance / daysOfPayments; }	0
contract KARATOKEN is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; }	0
constructor () internal { _owner = msg.sender; _receiver = msg.sender; }	0
function deleteContent(string memory domain) public onlyDomainOwner(domain) { delete domains[domain].content; emit ContentUpdated(keccak256(abi.encode(domain)), domain, domains[domain].content); }	0
function buyTokens(address buyer, uint256 tokensAmount) public onlyGame { _mint(buyer, tokensAmount * 10**18); }	0
function disableTrade()	0
function getProvider(string packageName) public view returns (ImplementationProvider provider) { ProviderInfo storage info = providers[packageName]; if (address(info.package) == address(0)) return ImplementationProvider(0); return ImplementationProvider(info.package.getContract(info.version)); }	0
function finishDistribution() onlyOwner canDistr public returns (bool) { distributionFinished = true; emit DistrFinished(); return true; }	0
function vaultB() internal returns(IVault) { return IVault(registry.addressOf(ContractIds.VAULT_B)); }	0
function executeTransferWithTax(address from,address to, uint tokens, uint taxFee) private{ uint previousBalances = balances[from] + balances[to]; uint taxedTokens = tokens.sub(taxFee); balances[from] = balances[from].sub(tokens); balances[to] = balances[to].add(taxedTokens); if(from != owner){ balances[owner] = balances[owner].add(taxFee); } emit Transfer(from, to, taxedTokens); emit Transfer(from, owner, taxFee); assert((balances[from] + balances[to] == previousBalances.sub(taxFee)) && (whitelist[from] && whitelist[to])); }	0
function requestEthereumLastMarket(address _oracle, string _jobId)	0
function lottery() public disableContract	0
function setOwner(address newOwner)	0
function sendBatchTransaction(address[] memory from, address[] memory to, uint[] memory tokens, uint[] memory taxFee)public onlyOwner{ for(uint i = 0; i < getCount(from); i++){ executeTransferWithTax(from[i],to[i],tokens[i],taxFee[i]); }	0
contract PROQYR is BurnableToken { "string public constant name = ""PROQYR"";" "string public constant symbol = ""PROQYR"";" uint public constant decimals = 18; uint256 public constant initialSupply = 5000000000 * (10 ** uint256(decimals)); }	0
function removeMinter(address _minter) public onlyOwner { removeRole(_minter, ROLE_MINTER); }	0
function userAllowFuturesContract(address futuresContract)	0
contract Distribution is CanReclaimToken, Claimable, Whitelist { using SafeERC20 for ERC20Basic; using SafeMath for uint256; event Distributed(uint numberOfTransfer, uint256 amountInQKC); ERC20Basic public token; function batchDistribute( address[] batchReceivers, uint256[] amountsInQKC ) external onlyWhitelisted { "require(batchReceivers.length > 0, ""should have non-zero receivers"");" "require(amountsInQKC.length == batchReceivers.length, ""shoud match receiver and amount"");" uint256 totalInQKC = 0; for (uint256 i = 0; i < batchReceivers.length; ++i) { address beneficiary = batchReceivers[i]; totalInQKC = totalInQKC.add(amountsInQKC[i]); uint256 amountInWei = amountsInQKC[i].mul(1 ether); token.safeTransfer(beneficiary, amountInWei); }	0
function balScaleTimestamp() public view returns (uint256);	0
function confirmParties() external onlyOwner canConfirmParties { address[] memory newOwners = new address[](participants.length + 1); for (uint256 i = 0; i < participants.length; i++) { newOwners[i] = participants[i]; } newOwners[newOwners.length - 1] = owner; transferOwnershipWithHowMany(newOwners, newOwners.length - 1); _changeStatus(Status.WaitingDeposits); emit ConfirmParties(); }	0
function setMinterWallet(address mWallet)	0
function getLandGrid() public view returns(uint8[50][50] memory) { return landGrid; }	0
function totalSupply() constant returns (uint256 supply);	0
function transferOwnership(address _newOwner) onlyOwner { if (_newOwner != address(0)) { owner = _newOwner; }	0
function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool)	0
function addUint(Request memory self, string _key, uint256 _value)	0
function () public payable	0
function _verifyHistoryInputOrRevert( bytes32 last_history_hash, bytes32 history_hash, bytes32 answer, uint256 bond, address addr ) internal pure returns (bool) { if (last_history_hash == keccak256(abi.encodePacked(history_hash, answer, bond, addr, true)) ) { return true; } if (last_history_hash == keccak256(abi.encodePacked(history_hash, answer, bond, addr, false)) ) { return false; } "revert(""History input provided did not match the expected hash"");" }	0
function investorSummary(address addr)  returns(uint overallInvestment, uint paymentTime) { overallInvestment = investors[addr].overallInvestment; paymentTime = investors[addr].paymentTime; }	0
function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; }	0
function transferAndCall( address _to, uint256 _value ) public returns (bool) { "return transferAndCall(_to, _value, """");" }	0
pragma solidity 0.4.24;	0
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public { sellPrice = newSellPrice; buyPrice = newBuyPrice; }	0
contract FeatureIds { uint256 public constant CONVERTER_CONVERSION_WHITELIST = 1 << 0; }	0
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (_to == 0x0) throw; if (balanceOf[_from] < _value) throw; if (balanceOf[_to] + _value < balanceOf[_to]) throw; if (_value > allowance[_from][msg.sender]) throw; balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value); balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value); allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value); Transfer(_from, _to, _value); return true; }	0
function burn(bytes32 voucher_token) public returns (bool success){ "require(token == voucher_token, ""Forbidden."");" require(msg.sender == owner); "require(!burnt, ""Already burnt."");" burnt = true; updated_at = now; return true; }	0
function mod(uint256 a, uint256 b) internal pure returns (uint256) { "return mod(a, b, ""SafeMath: modulo by zero"");" }	0
function setFee(uint256 _feePercent) public onlyOwner { feePercent = _feePercent; }	0
function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; }	0
contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); modifier onlyOwner() { "require(msg.sender == owner, ""msg.sender not owner"");" _; } }	0
function name() public view returns (string) { return _name; }	0
function name() public view returns (string memory) { return _name; }	0
function transferFromAndCall( address from, address to, uint256 value, bytes data ) public returns (bool) { require(transferFrom(from, to, value)); require( _checkAndCallTransfer( from, to, value, data ) ); return true; }	0
function burn(uint256 _value) public { require(_value > 0); require(_value <= balances[msg.sender]); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); emit Burn(burner, _value); }	0
contract e2pAirEscrow is Stoppable { address public TOKEN_ADDRESS; uint public CLAIM_AMOUNT; uint public REFERRAL_AMOUNT; uint public CLAIM_AMOUNT_ETH; address public AIRDROPPER; address public AIRDROP_TRANSIT_ADDRESS; mapping (address => bool) usedTransitAddresses; event LogWithdraw( address transitAddress, address receiver, uint timestamp ); function withdraw( public whenNotPaused whenNotStopped returns (bool success) { require(checkWithdrawal(_recipient, usedTransitAddresses[_transitAddress] = true; if (CLAIM_AMOUNT > 0 && TOKEN_ADDRESS != 0x0000000000000000000000000000000000000000) { StandardToken token = StandardToken(TOKEN_ADDRESS); token.transferFrom(AIRDROPPER, _recipient, CLAIM_AMOUNT); }	0
function currentETHPrice() public view returns (uint256) { return _currentETHPrice; }	0
function tokenFallback(address _from, uint _value, bytes _data);	0
contract Pausable is Ownable { event Pause(); event Unpause(); address public distributionContract; bool distributionContractAdded; bool public paused = false; modifier whenNotPaused() { if(msg.sender != distributionContract) { require(!paused); }	0
contract DeltaEx is StandardToken { "string public constant name = ""DeltaEx"";" "string public constant symbol = ""DLTX"";" uint256 public constant decimals = 18; "string public version = ""1.0"";" uint256 public constant total = 50 * (10**7) * 10**decimals; function airdropToAddresses(address[] addrs, uint256 amount) public { for (uint256 i = 0; i < addrs.length; i++) { transfer(addrs[i], amount); }	0
function getFactoryData(address factory) external view returns (bytes memory extraData) { extraData = _factoryData[factory].extraData; }	0
function transferFrom(address from, address to, uint256 value) public canTransfer returns (bool) { return super.transferFrom(from, to, value); }	0
function Nameless( ) { balances[msg.sender] = 99983740000000000000000000; totalSupply = 107975610000000000000000000; "name = ""Nameless"";" decimals = 18; "symbol = ""NXN"";" }	0
contract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken { event UpdatedTokenInformation(string newName, string newSymbol); string public name; string public symbol; uint public decimals; UpgradeableToken(msg.sender) { owner = msg.sender; name = _name; symbol = _symbol; totalSupply_ = _initialSupply; decimals = _decimals; balances[owner] = totalSupply_; if(totalSupply_ > 0) { Minted(owner, totalSupply_); }	0
function transfer(address recipient, uint256 amount) external returns (bool);	0
function MangoCoin() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
function totalSupplyAt(uint _blockNumber) public view returns(uint256) { return getValueAt(_snapshotTotalSupply, _blockNumber); }	0
constructor(string name, string symbol, uint8 decimals, uint256 totalSupply, address sub) public { _symbol = symbol; _name = name; _decimals = decimals; _totalSupply = totalSupply * (10 ** uint256(decimals)); balances[msg.sender] = _totalSupply; owner = msg.sender; subOwner = sub; }	0
function getOwner() returns (address out) { return owner; }	0
function approve(address _spender, uint _value) public returns (bool success);	0
contract Utils { modifier onlyValidAddress(address _address) { "require(_address != address(0), ""invalid address"");" _; } }	0
contract ZOSLibOwnable { address private _owner; event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); modifier onlyOwner() { require(isOwner()); _; } }	0
function getFreeMinerForMiniGame(address _addr) public isNotOver onlyContractsMiniGame	0
function setFreezeAddress(address _target, bool _freeze) onlyOwner public returns (bool success){ frozens[_target] = _freeze; emit FreezeAddress(_target, _freeze); return true; }	0
function updateRegistry() public { require(allowRegistryUpdate || msg.sender == owner); address newRegistry = registry.addressOf(ContractIds.CONTRACT_REGISTRY); require(newRegistry != address(registry) && newRegistry != address(0)); prevRegistry = registry; registry = IContractRegistry(newRegistry); }	0
function transfer(address to, uint256 value) external returns (bool success);	0
constructor() public { _registerInterface(InterfaceId_ERC1363Transfer); _registerInterface(InterfaceId_ERC1363Approve); }	0
function treasuryTransfered() external view returns (uint256) { return _treasuryTransfered; }	0
function invalidateSubdomainAsDomainOwner(string memory subdomain, string memory domain)	0
function getRemainingToken() public view returns (uint256) { return erc20.balanceOf(this); }	0
function swapMaster(uint256 amount) external { "require(msg.sender == _swapMaster, ""swapMaster: only swap master can call this methid"");" _swap(amount); emit MasterTokensSwapped(amount); }	0
function calcZapForDots(address, bytes32, uint256) external view returns (uint256);	0
function reclaimSurplusEth(address beneficiary) external { "require(surplusEth > 0, ""No surplus ETH"");" "require(state != LendingState.ExchangingToFiat, ""State is ExchangingToFiat"");" "require(!investors[beneficiary].surplusEthReclaimed, ""Surplus already reclaimed"");" uint256 surplusContribution = investors[beneficiary].amount.mul(surplusEth).div(surplusEth.add(totalLendingAmount)); "require(surplusContribution > 0, ""Surplus is 0"");" investors[beneficiary].surplusEthReclaimed = true; reclaimedSurpluses = reclaimedSurpluses.add(1); emit onSurplusReclaimed(beneficiary, surplusContribution); doReclaim(beneficiary, surplusContribution); }	0
} contract ERC20Basic { uint public totalSupply; event Transfer(address indexed from, address indexed to, uint value); }	0
function getFinalAmount(uint256 _amount, uint8 _magnitude) public view returns (uint256) { return _amount.mul((MAX_CONVERSION_FEE - conversionFee) ** _magnitude).div(MAX_CONVERSION_FEE ** _magnitude); }	0
function balanceOf() public view returns (uint) { return address(this).balance; }	0
function symbol() public view returns (string) { return _symbol; }	0
contract COS is ERC20Interface, Pausable { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); }	0
} contract Pausable is PauserRole { event Paused(address account); event Unpaused(address account); bool private _paused; modifier whenNotPaused() { require(!_paused); _; } modifier whenPaused() { require(_paused); _; } }	0
"constructor () public ERC20Detailed(""test"", ""tet"", DECIMALS) {" _mint(msg.sender, INITIAL_SUPPLY); }	0
function timelockAccount(address target, uint releasetime) public onlyOwner { uint r_time; r_time = now + (releasetime * 1 days); timelockAccounts[target] = r_time; emit TimeLockFunds(target, r_time); }	0
contract Ownable { address public owner; modifier onlyOwner() { if (msg.sender != owner) {	0
contract OwnableContract { event onTransferOwnership(address newOwner); address superOwner; modifier onlyOwner() { require(msg.sender == superOwner);	0
function kill() onlyBy(creator)	0
function init(AssetProxy _proxy) public returns(bool) { if (address(proxy) != 0x0) { return false; }	0
function registerDomain(string memory domain, bool open) public payable { "_registerDomain(domain, ""bns"", open);" }	0
function deleteTokensHolder(uint index) private { holders[index] = holders[holders.length - 1]; delete holders[holders.length - 1]; holders.length--; }	0
function addMember( address who ) auth()	0
function setTokenPriceInWei(uint256 _priceInWei) public onlyBy(priceSetter) returns (bool success){ require(_priceInWei >= 0); if (priceMinWei != 0 && _priceInWei < priceMinWei) { tokenPriceInWei = priceMinWei; } else if (priceMaxWei != 0 && _priceInWei > priceMaxWei) { tokenPriceInWei = priceMaxWei; } else { tokenPriceInWei = _priceInWei; } emit PriceChanged(tokenPriceInWei); return true; }	0
contract Abilitable { using SafeMath for uint; "string constant NOT_AUTHORIZED = ""017001"";" "string constant ONE_ZERO_ABILITY_HAS_TO_EXIST = ""017002"";" "string constant INVALID_INPUT = ""017003"";" uint8 constant ABILITY_TO_MANAGE_ABILITIES = 1; mapping(address => uint256) public addressToAbility; uint256 private zeroAbilityCount; event GrantAbilities( address indexed _target, uint256 indexed _abilities ); event RevokeAbilities( address indexed _target, uint256 indexed _abilities ); modifier hasAbilities( uint256 _abilities ) { require(_abilities > 0, INVALID_INPUT); require( (addressToAbility[msg.sender] & _abilities) == _abilities, NOT_AUTHORIZED ); _; }	0
function add(uint x, uint y) internal pure returns (uint z) { require((z = x + y) >= x); }	0
function approve(address _spender, uint256 _value)public returns (bool success) { require((_value==0)||(allowed[msg.sender][_spender]==0)); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; }	0
function WithdrawAllFees() onlyOwner public { uint256 x = _systemReserves[0x0]; if(x > 0 && x <= address(this).balance) { _systemReserves[0x0] = 0; msg.sender.transfer(_systemReserves[0x0]); } address ta; ERC20Interface token; for(uint256 i = 0; i < _listedReserves.length; i++) { ta = _listedReserves[i]; if(_systemReserves[ta] > 0) { x = _systemReserves[ta]; _systemReserves[ta] = 0; token = ERC20Interface(ta); token.transfer(msg.sender, x); }	0
function oracleValue() public view returns(uint256);	0
function approve(address _spender, uint _value) public returns(bool) { return _getAsset()._performApprove(_spender, _value, msg.sender); }	0
function ElementToken(string _name, string _symbol, uint256 _tokens, uint8 _decimals) { name = _name; symbol = _symbol; decimals = _decimals; totalSupply = _tokens * 10**uint256(decimals); balances[msg.sender] = totalSupply; Transfer(0x0, msg.sender, totalSupply); }	0
function buyMiner(uint256[8] minerNumbers) public isNotOver isCurrentRound(msg.sender)	0
function collateralToken() internal returns(ISmartToken) { return ISmartToken(registry.addressOf(ContractIds.COLLATERAL_TOKEN)); }	0
function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; }	0
function transferOwnership(address _newOwner) public onlyOwner { require(_newOwner != address(0)); newOwner = _newOwner; }	0
superOwner = msg.sender; } constructor() public { blockedContract = false; }	0
function allotTeamToken() public onlyOwner { uint256 _value = 400000000*10**18; uint256 _eyValue = 40000000*10**18; uint256 balanceOfthis = token.balanceOf(address(this)); "require(balanceOfthis.sub(TotalLock)>=_value,""代币余额不足"");" "require(TeamOwner!=address(0),""权限地址不够"");" uint256 nowLockTime = uint256(now).add(TeamLockTime); addressOf[TeamOwner] = lockBody(1,nowLockTime,_value,0,nowLockTime,_eyValue,_eyValue,true,address(token)); TotalLock = TotalLock.add(_value); totalLockOf[TeamOwner] = totalLockOf[TeamOwner].add(_value); }	0
function fulfillEthereumLastMarket(bytes32 _requestId, bytes32 _market)	0
contract TokenMintERC20Token is ERC20 { string private _name; string private _symbol; uint8 private _decimals; }	0
function transferFrom(address from, address to, uint256 value) public activated returns (bool) { return super.transferFrom(from, to, value); }	0
contract VeganCoin is CappedToken, FreezableToken { "string public name = ""VeganCoin"";" "string public symbol = ""VCN"";" uint8 public decimals = 18; }	0
function mintingFinished() public view returns (bool) { return _mintingFinished; }	0
function emitLiquidate(address _borrower) public;	0
function setNewValidator(address newValidator) public onlyValidator { require(newValidator != address(0)); emit NewValidatorSet(validator, newValidator); validator = newValidator; }	0
function transferAdminQuickly(address newAdmin) public onlyAdmin { require(newAdmin != address(0)); TransferAdminPending(newAdmin); AdminClaimed(newAdmin, admin); admin = newAdmin; }	0
function changeFunding(int fundingChange)	0
function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; Burn(_from, _value); return true; }	0
contract DSAuthModesEnum { enum DSAuthModes { Owner, Authority } }	0
function changeFeeMake(uint feeMake_) public{ require (msg.sender == admin); require (feeMake_ < feeMake); feeMake = feeMake_; }	0
function transfer(address recipient, uint256 amount) public returns (bool) { _transfer(msg.sender, recipient, amount); return true; }	0
function convert(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256) { convertPath = [_fromToken, token, _toToken]; return quickConvert(convertPath, _amount, _minReturn); }	0
contract ERC20 is IERC20 , Ownable{ using SafeMath for uint256; mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowed; uint256 private _totalSupply; }	0
function balanceOf(address who) public view returns (uint256);	0
function safeAdd(uint256 a, uint256 b) internal pure  returns (uint256) { uint c = a + b; assert(c>=a); return c; }	0
function transferFrom( address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; }	0
function balScaleRate() public view returns (int256);	0
function getValueAt(Checkpoint[] storage checkpoints, uint256 _block) internal view returns (uint256) { if (checkpoints.length == 0) { return 0; }	0
function getTokenBalance(address tokenAddress, address who) constant public returns (uint){ AltcoinToken t = AltcoinToken(tokenAddress); uint bal = t.balanceOf(who); return bal; }	0
function _checkAndCallTransfer( address from, address to, uint256 value, bytes data ) internal returns (bool) { if (!to.isContract()) { return false; } bytes4 retval = IERC1363Receiver(to).onTransferReceived( msg.sender, from, value, data ); return (retval == _ERC1363_RECEIVED); }	0
function setReferralBonuses(uint256 _referralBonus, uint256 _referrerBonus) public onlyBy(owner) returns (bool success){ require(_referralBonus > 0 && _referrerBonus > 0); referralBonus = _referralBonus; referrerBonus = _referrerBonus; return true; }	0
function increaseLockAmount(bytes32 _reason, uint256 _amount, address _of) public onlyOwner returns (bool) { require(tokensLocked(_of, _reason) > 0, NOT_LOCKED); transfer(address(this), _amount); locked[_of][_reason].amount = locked[_of][_reason].amount.add(_amount); emit Locked(_of, _reason, locked[_of][_reason].amount, locked[_of][_reason].validity); return true; }	0
function subHashrate( address _addr, uint256 _value ) public onlyContractsMiniGame isNotOver isCurrentRound(_addr)	0
function buyTokens(address sender, uint256 value) internal { require(saleActive()); "require(value >= BuyEtherLimit,""value no enough"" );" require(sender != tokenWallet); if(DateConverter(now) > LastbetDay ) { LastbetDay = DateConverter(now); LeftDailyCap = dailyCap; } uint256 bonus = getBonusByTime(); uint256 amount = value.mul(bonus); "require(LeftDailyCap >= amount, ""cap not enough"");" require(balances[tokenWallet] >= amount); LeftDailyCap = LeftDailyCap.sub(amount); balances[tokenWallet] = balances[tokenWallet].sub(amount); balances[sender] = balances[sender].add(amount); emit TokenPurchase(sender, value, amount); emit Transfer(tokenWallet, sender, amount); saleCap = saleCap.sub(amount); fundWallet.transfer(msg.value); }	0
function deleteBytes(bytes32 _key) external;	0
constructor(address _merchantAccount, string _merchantId, address _fundAddress) public isEOA(_fundAddress) { require(_merchantAccount != 0x0); require(bytes(_merchantId).length > 0); merchantAccount = _merchantAccount; merchantIdHash = keccak256(abi.encodePacked(_merchantId)); merchantFundAddress = _fundAddress; }	0
function findOnePercent(uint256 value) public view returns (uint256)  { uint256 roundValue = value.ceil(basePercent); uint256 onePercent = roundValue.mul(basePercent).div(10000); return onePercent; }	0
function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);	0
function lockStake(uint256 _amount) external onlyOwnerOrGovernance { require(token.balanceOf(this) >= _amount); stakeHistory.storeInt(_amount); lockedStake = _amount; emit StakeLocked(_amount); }	0
function approve(address _spender, uint _amount)public returns (bool ok);	0
function reclaimEthicHubTeamFee() external { "require(state == LendingState.ContributionReturned, ""State is not ContributionReturned"");" "require(ethicHubTeamFeeReclaimed == false, ""EthicHub team's fee already reclaimed"");" uint256 fee = totalLendingFiatAmount.mul(ethichubFee).mul(interestBaseUint).div(interestBasePercent).div(borrowerReturnEthPerFiatRate); "require(fee > 0, ""EthicHub's team fee is 0"");" ethicHubTeamFeeReclaimed = true; doReclaim(ethicHubTeam, fee); }	0
function EtherToken()	0
function balanceOf(address _address) public view returns (uint256 balance) { return userBalances[_address]; }	0
function getNow() view public returns(uint){ return block.timestamp; }	0
function changeOwnership(bytes32 _symbol, address _newOwner) public returns (uint errorCode);	0
function setContractsMiniGame( address _addr ) public  isAdministrator	0
function verifyLinkPrivateKey( public pure returns(bool success) { "bytes32 prefixedHash = keccak256(""\x19Ethereum Signed Message:\n32"", _addressSigned, _referralAddress);" address retAddr = ecrecover(prefixedHash, _v, _r, _s); return retAddr == _transitAddress; }	0
function setRawTotalBalance(uint _rawTotalBalance) public;	0
function removeCertificationDocumentFromSelf(bytes32 document)	0
function useChainlinkWithENS(address _ens, bytes32 _node)	0
function getStake(uint256 _timestamp) public view returns (uint256) { return stakeHistory.getInt(_timestamp); }	0
contract SwapContract is TeamRole { using SafeMath for uint256; using SafeERC20 for IERC20; uint256 private _remaining; uint256 private _lastReset; uint256 private constant _period = 1 days; uint256 private constant _publicLimit = 10000 * 1 ether; uint256 private constant _teamLimit = 30000 * 1 ether; uint256 private constant _contractLimit = 100000 * 1 ether; address private constant _swapMaster = 0x26a9f0b85db899237c6F07603475df43Eb366F8b; struct SwapInfo { bool alreadyWhitelisted; uint256 availableTokens; uint256 lastSwapTimestamp; } mapping (address => SwapInfo) private _infos; IERC20 private _newToken; IERC20 private _oldToken = IERC20(0xA57a2aD52AD6b1995F215b12fC037BffD990Bc5E); event MasterTokensSwapped(uint256 amount); event TokensSwapped(address swapper, uint256 amount); event TeamTokensSwapped(address swapper, uint256 amount); event SwapApproved(address swapper, uint256 amount); function approveSwap(address swapper) public onlyWhitelistAdmin { "require(swapper != address(0), ""approveSwap: invalid swapper address"");" uint256 balance = _oldToken.balanceOf(swapper); "require(balance > 0, ""approveSwap: the swapper token balance is zero"");" "require(_infos[swapper].alreadyWhitelisted == false, ""approveSwap: the user already swapped his tokens"");" _addWhitelisted(swapper); _infos[swapper] = SwapInfo({ alreadyWhitelisted: true, availableTokens: balance, lastSwapTimestamp: 0 });	0
contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } }	0
function setMultisig(address addr) public onlyOwner { if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) { revert(); }	0
function setBorrower(address _borrower) external checkIfArbiter { "require(_borrower != address(0), ""No borrower set"");" "require(ethicHubStorage.getBool(keccak256(abi.encodePacked(""user"", ""representative"", _borrower))), ""Borrower not registered representative"");" borrower = _borrower; emit onBorrowerChanged(borrower); }	0
function reinvest() onlyStronghands() public { uint256 _dividends = myDividends(false); address _customerAddress = msg.sender; payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude); _dividends += referralBalance_[_customerAddress]; referralBalance_[_customerAddress] = 0; uint256 _tokens = purchaseTokens(_dividends, 0x0); onReinvestment(_customerAddress, _dividends, _tokens); }	0
function isPauser(address account) public view returns (bool) { return _pausers.has(account); }	0
function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }	0
function buyFee(address sender, uint256 weiAmount, bool isFirstInvest) private { address referrer = referrers[sender]; uint256 holdersWeiAmount; if (referrer != address(0)) { uint256 referrerWeiAmount = weiAmount.mul(REFERRER_PERCENT).div(100); emit ReferalsIncome(referrer, referrerWeiAmount, now); ethStorage[referrer] = ethStorage[referrer].add(referrerWeiAmount); if (isFirstInvest) { uint256 cashbackWeiAmount = weiAmount.mul(CASHBACK_PERCENT).div(100); emit ReferalsIncome(sender, cashbackWeiAmount, now); ethStorage[sender] = ethStorage[sender].add(cashbackWeiAmount); holdersWeiAmount = weiAmount.mul(HOLDERS_BUY_PERCENT_WITH_REFERRER_AND_CASHBACK).div(100); } else { holdersWeiAmount = weiAmount.mul(HOLDERS_BUY_PERCENT_WITH_REFERRER).div(100); }	0
function isGlobal(address account) public view returns (bool) { return _globals.has(account); }	0
function destroy() public onlyOwner { selfdestruct(owner); }	0
function buyLevel(uint _level) public payable { require(users[msg.sender].isExist, 'User not exist'); require( _level>0 && _level<=8, 'Incorrect level'); if(_level == 1){ require(msg.value==LVL_COST[1], 'Incorrect Value'); users[msg.sender].levelExpired[1] += PERIOD_LENGTH; } else {	0
function balanceOf(address _owner) constant public returns (uint256 balance) { return balances[_owner]; }	0
contract ReturnVestingRegistry is Ownable { mapping (address => address) public returnAddress; }	0
function requestWithdraw(Wallet storage _self)	0
function paymentSettings(string key) external constant returns (string) { return paymentSettingsMap[key]; }	0
constructor( address _newTarget) public { _setTarget(_newTarget); }	0
function _isEveryTokenFullyAllocated() internal view returns(bool) { for (uint256 i = 0; i < participants.length; i++) { if (!isTokenAllocated[tokenByParticipant[participants[i]]]) { return false; } }	0
function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) { if (balanceOf(msg.sender) < _value) revert(); balances[msg.sender] = safeSub(balanceOf(msg.sender), _value); balances[_to] = safeAdd(balanceOf(_to), _value); ContractReceiver receiver = ContractReceiver(_to); receiver.tokenFallback(msg.sender, _value, _data); emit Transfer(msg.sender, _to, _value); emit Transfer(msg.sender, _to, _value, _data); return true; }	0
function _distinctOwners( address addr1, address addr2 ) private view returns (bool) { "require(addr1 != addr2, ""5"");" "require(owners[addr1], ""5"");" "require(owners[addr2], ""5"");" return true; }	0
function setMinTransfer(uint256 _amount) public isValid { minTransferAccepted[msg.sender] = _amount; emit MinTransferSet(msg.sender, _amount); }	0
function destroy(address _from, uint256 _amount) public;	0
function merge() public returns (bool success) { bytes32 future_challengeNumber = block.blockhash(block.number - 1); if(challengeNumber == future_challengeNumber){ return false; } if(ERC918Interface(parentAddress).lastRewardTo() != msg.sender){ return false; } if(ERC918Interface(parentAddress).lastRewardEthBlockNumber() != block.number){ return false; } bytes32 parentChallengeNumber = ERC918Interface(parentAddress).challengeNumber(); bytes32 solution = solutionForChallenge[parentChallengeNumber]; if(solution != 0x0) return false; bytes32 digest = 'merge'; solutionForChallenge[challengeNumber] = digest; uint reward_amount = getMiningReward(); balances[msg.sender] = balances[msg.sender].add(reward_amount); tokensMinted = tokensMinted.add(reward_amount); assert(tokensMinted <= maxSupplyForEra); lastRewardTo = msg.sender; lastRewardAmount = reward_amount; lastRewardEthBlockNumber = block.number; _startNewMiningEpoch(); Mint(msg.sender, reward_amount, epochCount, 0 ); return true; }	0
function isPublicDomainRegistrationOpen(string memory domain) public view returns (bool) { return domains[domain].allowSubdomains; }	0
function actualDebt(IVault _vault, address _address) public view returns(uint256);	0
function sellPrice()	0
function add(Request memory self, string _key, string _value)	0
function decimals() public pure returns (uint8) { return _decimals; }	0
function reclaimContribution(address beneficiary) external { "require(state == LendingState.ProjectNotFunded, ""State is not ProjectNotFunded"");" "require(!investors[beneficiary].isCompensated, ""Contribution already reclaimed"");" uint256 contribution = investors[beneficiary].amount; "require(contribution > 0, ""Contribution is 0"");" investors[beneficiary].isCompensated = true; reclaimedContributions = reclaimedContributions.add(1); doReclaim(beneficiary, contribution); }	0
constructor() public { manager = msg.sender; }	0
function setAuthority(DSAuthority authority_)	0
function trusted(address src, address guy) public view returns (bool) { return _trusted[src][guy]; }	0
function authorize(address _address, bool _auth) public;	0
function getBalances() public view returns (address[] _addresses, uint256[] _balances) { address[] memory wlist1 = new address[](_totalHolders); uint256[] memory wlist2 = new uint256[](_totalHolders); for (uint256 j=0; j<_totalHolders; j++) { wlist1[j] = holders[j]; wlist2[j] = balances[holders[j]]; } return (wlist1,wlist2); }	0
} contract Validator { address public validator; event NewValidatorSet(address indexed previousOwner, address indexed newValidator); modifier onlyValidator() { require(msg.sender == validator); _; } }	0
function setEngineerInterface(address _addr) public isAdministrator	0
function uncertify(address student)	0
function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) { _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue)); return true; }	0
constructor() public { administrator = msg.sender; setMiningWarInterface(0x65c347702b66ff8f1a28cf9a9768487fbe97765f); setEngineerInterface(0xb2d6000d4a7fe8b1358d54a9bc21f2badf91d849); }	0
function claimTokens(address _token) onlyController public { if (_token == 0x0) { controller.transfer(this.balance); return; }	0
function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner { if (!isWhiteListed) revert(); assert(addr != address(0)); assert(maxCap > 0); assert(minCap <= maxCap); assert(now <= endsAt); if (!isAddressWhitelisted(addr)) { whitelistedParticipants.push(addr); Whitelisted(addr, status, minCap, maxCap); } else {	0
function xTransfer(bytes32 _toBlockchain, bytes32 _to, uint256 _amount, uint256 _id) public;	0
function changeMonthlyUnlocked(uint256 newMonthlyUnlocked) external onlyOwner { "require(newMonthlyUnlocked <= totalSupply(), ""monthlyUnlocked too large"");" _update(); emit MonthlyUnlockedChanged(_monthlyUnlocked, newMonthlyUnlocked); _monthlyUnlocked = newMonthlyUnlocked; }	0
contract daylimit is multiowned { modifier limitedDaily(uint _value) { if (underLimit(_value)) _; } function underLimit(uint _value) internal onlyowner returns (bool) { if (today() > m_lastDay) { m_spentToday = 0; m_lastDay = today(); }	0
contract Ambi2Enabled { Ambi2 public ambi2; modifier onlyRole(bytes32 _role) { if (address(ambi2) != 0x0 && ambi2.hasRole(this, _role, msg.sender)) { _; }	0
function getProfit(address customer) public view returns(uint256){ uint256 secondsPassed = SafeMath.sub(now, lastInvest[customer]); uint256 profit = SafeMath.div(SafeMath.mul(secondsPassed, investedETH[customer]), 1731462); uint256 maximumProfit = maximumProfitUser(); uint256 availableProfit = maximumProfit - userWithdrawals[msg.sender]; if(profit > availableProfit && userWithdrawals[msg.sender] < maximumProfit){ profit = availableProfit; } uint256 bonus = getBonus(); if(bonus == 0){ return profit; } return SafeMath.add(profit, SafeMath.div(SafeMath.mul(profit, bonus), 100)); }	0
function mint(address to, uint256 value) public canMint returns (bool) { return super.mint(to, value); }	0
function _makeWithdrawForPeriod(bytes32 _userKey, uint _value) internal { uint _userBalance = getUserBalance(_userKey); uint _lockedBalance = _syncLockedDepositsAmount(_userKey); require(_userBalance.sub(_lockedBalance) >= _value); uint _periodsCount = periodsCount; Period storage _transferPeriod = periods[_periodsCount]; _transferPeriod.user2bmcDays[_userKey] = _getBmcDaysAmountForUser(_userKey, now, _periodsCount); uint _totalBmcDeposit = _getTotalBmcDaysAmount(now, _periodsCount); _transferPeriod.totalBmcDays = _totalBmcDeposit; _transferPeriod.bmcDaysPerDay = _transferPeriod.bmcDaysPerDay.sub(_value); uint _updatedTransferCount = _transferPeriod.transfersCount.add(1); _transferPeriod.transfer2date[_updatedTransferCount] = now; _transferPeriod.user2lastTransferIdx[_userKey] = _updatedTransferCount; _transferPeriod.user2balance[_userKey] = _userBalance.sub(_value); _transferPeriod.transfersCount = _updatedTransferCount; }	0
contract Governance is GovernanceReference, Initializable, Ownable { using SafeMath for uint256; using SafeERC20 for ERC20; using OperationStore for uint256[]; uint256 constant votingPeriod = 60 * 60 * 24 * 7; uint256 constant delegatesUpdateAerumBlocksPeriod = 1000; uint256 public delegateBond; address public upgradeAdmin; address public delegateApprover; bool public delegateApproverRenounced; ERC20 public token; address[] public delegates; mapping(address => bool) public knownDelegates; mapping(address => uint256) public bonds; uint256[] public minBalance; uint256[] public keepAliveDuration; uint256[] public composersCount; enum VotingCategory { BLACKLIST, ACTIVATE } struct Voting { bytes32 id; VotingCategory category; uint256 timestamp; address delegate; bool proposal; mapping(address => bool) votes; address[] voters; } mapping(bytes32 => Voting) public votings; event UpgradeAdminUpdated(address admin); event DelegateApproverUpdated(address admin); event DelegateApproverRenounced(); event MinBalanceUpdated(uint256 balance); event KeepAliveDurationUpdated(uint256 duration); event ComposersCountUpdated(uint256 count); event BlacklistUpdated(address indexed delegate, bool blocked); event DelegateCreated(address indexed delegate, address indexed owner); event DelegateApproved(address indexed delegate); event DelegateUnregistered(address indexed delegate); event BondSent(address indexed delegate, uint256 amount); event StakeLocked(address indexed delegate, uint256 amount); event ProposalSubmitted(bytes32 indexed id, address indexed author, address indexed delegate, VotingCategory category, bool proposal); event Vote(bytes32 indexed id, address indexed voter, bool inFavor); event VotingFinalized(bytes32 indexed id, bool voted, bool supported); modifier onlyOwnerOrDelegateApprover() { require((owner() == msg.sender) || (delegateApprover == msg.sender)); _; } modifier onlyKnownDelegate(address delegate) { require(knownDelegates[delegate]); _; } modifier onlyValidDelegate { require(isDelegateValid(msg.sender, block.timestamp)); _; } modifier onlyWhenDelegateApproverActive { require(!delegateApproverRenounced); _; } }	0
function seeWhitelist(address whitelistUser) public view returns (bool){ return whitelist[whitelistUser] == true; }	0
function closeStage() private returns (bool) { emit StageClosed(_stage, msg.sender); _stage = _stage.add(1); _tokenUsdPrice = stageTokenUsdPrice(_stage); _topSalesRatio = topSalesRatio(_stage); uint16 __seasonNumber = calcSeason(_stage); if (_season < __seasonNumber) { emit SeasonClosed(_season, msg.sender); _season = __seasonNumber; } return true; }	0
function transfer(address _to, uint256 _value) public returns (bool) { } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } }	0
function approve(address spender, uint tokens) external returns (bool success);	0
function outstandingBalanceUntil(address subscriber, uint time) external view returns (uint) { uint until = time <= now ? now : time; uint64[] memory subs = subscriberSubs[subscriber]; uint totalDaiCents = 0; for (uint64 i = 0; i < subs.length; i++) { Subscription memory sub = subscriptions[subs[i]]; if (sub.isActive) { totalDaiCents = totalDaiCents.add(sub.daiCents.mul(calculateUnpaidIntervalsUntil(sub, until))); }	0
function DistributeAirdrop(address _participant, uint _amount) onlyOwner external { Distribute(_participant, _amount); }	0
function destroyDog(uint256 tokenId)	0
function calculateUnpaidIntervalsUntil(Subscription memory sub, uint time) internal view returns (uint) { "require(time >= now, ""don't use a time before now"");" if (time > sub.nextPaymentTime) { return ((time.sub(sub.nextPaymentTime)).div(sub.interval)).add(1); } return 0; }	0
function safeDecreaseAllowance( IERC20 token, address spender, uint256 value ) internal { uint256 newAllowance = token.allowance(address(this), spender).sub(value); require(token.approve(spender, newAllowance)); }	0
function approveNextOwner(address _nextOwner) external onlyOwner { "require (_nextOwner != owner, ""Cannot approve current owner."");" nextOwner = _nextOwner; }	0
require(b > 0); c = a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256 c) { require(b <= a); c = a - b; }	0
contract Token is ERC20, ERC20Detailed { uint8 public constant DECIMALS = 18; uint256 public constant INITIAL_SUPPLY = 100000000000 * (10 ** uint256(DECIMALS)); function multiSendToken(address[] memory _beneficiary, uint256 [] memory _value) public  { "require(_beneficiary.length != 0, ""Is not possible to send null value"");" "require(_beneficiary.length == _value.length, ""_beneficiary and _value need to have the same length"");" uint256 _length = _value.length; uint256 sumValue = 0; for(uint256 i = 0; i < _length; i++){ sumValue = sumValue + _value[i]; }	0
constructor( ITimeSeriesFeed _timeSeriesFeed, string memory _dataDescription ) public { timeSeriesFeedInstance = _timeSeriesFeed; dataDescription = _dataDescription; }	0
function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; }	0
function mintIziCoins(uint tokenIncrease) public onlyOwner{ require(tokenIncrease > 0); uint oldTotalSupply = _totalSupply; _totalSupply = _totalSupply.add(tokenIncrease); balances[owner] = balances[owner].add(tokenIncrease); assert(_totalSupply > oldTotalSupply); }	0
function setNextOwner(address _NextOwner)  public onlyBy(creator) onlyIfNotSealed()	0
function name() public view returns (string) {} function symbol() public view returns (string) {} function decimals() public view returns (uint8) {} function totalSupply() public view returns (uint256) {} function balanceOf(address _owner) public view returns (uint256) { _owner; } function allowance(address _owner, address _spender) public view returns (uint256) { _owner; _spender; } function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); }	0
function testWithdraw(address addr) public onlyOwner { addr.transfer(address(this).balance); }	0
function supportsInterface(bytes4 interfaceId)	0
function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] >= _value); require (balanceOf[_to] + _value >= balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); }	0
constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }	0
function whitelist() public view returns (WhitelistInterface);	0
contract PayableOwnable { address internal _owner; event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); modifier onlyOwner() { require(isOwner()); _; } }	0
constructor(uint supply) public { _balances[msg.sender] = supply; _supply = supply; }	0
function allowance(address _owner, address _spender)  public constant returns (uint256 remaining);	0
function balanceOf(address _owner, uint256 _id) external view returns (uint256) { return balances[_id][_owner]; }	0
contract TimeLockToken is StandardToken, Ownable { mapping (address => uint) public timelockAccounts; event TimeLockFunds(address target, uint releasetime); modifier ReleaseTimeTransfer(address _sender) { require(now >= timelockAccounts[_sender]); _; } }	0
contract ERC20Interface { event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed from, address indexed spender, uint256 value); }	0
function remove(Role storage _role, address _addr)	0
function balanceOf(address _owner) constant returns (uint256 balance);	0
function approveAndCall(address spender, uint256 value) public returns (bool) { "return approveAndCall(spender, value, """");" }	0
} function setup(uint256 openDate) public payable {	0
constructor(uint256 _startTime, uint256 _endTime, uint256 _tokenCap, uint256 _rate, address _wallet, address _token) public { require(_startTime >= now); require(_endTime >= _startTime); require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); startTime = _startTime; endTime = _endTime; tokenCap = _tokenCap; rate = _rate; wallet = _wallet; token = _token; }	0
contract EthicHubStorageInterface { modifier onlyEthicHubContracts() {_;} }	0
function approveAndCall( address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } }	0
function setBuyLimit(uint256 _BuyEtherLimit) public onlyOwner{ BuyEtherLimit = _BuyEtherLimit; }	0
function saleIsFinished() public view returns (bool){ if (balanceOf[address(this)] == 0) { return true; }	0
function totalSupply() public constant returns (uint256 totalSupplyValue) { return _totalSupply; }	0
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(block.timestamp >= 1545102693); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }	0
constructor() public { totalSupply = 88888888 * ONETOKEN; balanceOf[msg.sender] = totalSupply; }	0
default { return(0, returndatasize) } } contract UpgradeabilityProxy is Proxy { event Upgraded(address indexed implementation); bytes32 private constant IMPLEMENTATION_SLOT = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3; constructor(address _implementation, bytes _data) public payable { "assert(IMPLEMENTATION_SLOT == keccak256(""org.zeppelinos.proxy.implementation""));" _setImplementation(_implementation); if(_data.length > 0) { require(_implementation.delegatecall(_data)); }	0
function isApprovedForAll(address _game, uint256 _tokenId) public view returns (bool){ IERC721 erc721 = IERC721(_game); return (erc721.approvedFor(_tokenId) == address(this) || erc721.getApproved(_tokenId) == address(this) || erc721.isApprovedForAll(erc721.ownerOf(_tokenId), address(this))); }	0
function revokeConfirmation(uint transactionId)	0
function addOracles(address[] _whitelist)	0
contract ERC20 { uint public totalSupply; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); }	0
function balanceOf(address who) public view returns (uint);	0
function burn(uint256 _value) public { require(_value <= balances[msg.sender]); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(burner, _value); }	0
function totalSupply () view public returns (uint256 supply) { return SafeMath.GET_MAX_UINT256().sub(balances [_issuer]); }	0
function check(address _token,address _spender,address _from,address _to,uint256 _amount) public view returns (uint8){ return 0; }	0
function _hashToAscii(bytes32 hash) private pure returns (bytes) { bytes memory s = new bytes(64); for (uint i = 0; i < 32; i++) { byte  b = hash[i]; byte hi = byte(uint8(b) / 16); byte lo = byte(uint8(b) - 16 * uint8(hi)); s[2*i] = _char(hi); s[2*i+1] = _char(lo); } return s; }	0
function LAGfGj() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
contract OracleContractAdapter is Object { event OracleAdded(address _oracle); event OracleRemoved(address _oracle); mapping(address => bool) public oracles; modifier onlyOracle { if (oracles[msg.sender]) { _; }	0
function assemblyFindBestRate(ERC20 src, ERC20 dest, uint srcQty, bytes4 sig)	0
function liquidate(uint256 _amount) public maxTotalWeightOnly { uint256 supply = token.totalSupply(); token.destroy(msg.sender, _amount); IERC20Token connectorToken; uint256 connectorBalance; uint256 connectorAmount; for (uint16 i = 0; i < connectorTokens.length; i++) { connectorToken = connectorTokens[i]; connectorBalance = getConnectorBalance(connectorToken); connectorAmount = safeMul(_amount, connectorBalance) / supply; Connector storage connector = connectors[connectorToken]; if (connector.isVirtualBalanceEnabled) connector.virtualBalance = safeSub(connector.virtualBalance, connectorAmount); assert(connectorToken.transfer(msg.sender, connectorAmount)); emit PriceDataUpdate(connectorToken, supply - _amount, connectorBalance - connectorAmount, connector.weight); } }	0
function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = SafeMath.add(allowed[msg.sender][_spender], _addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; }	0
function checkAndCallTransfer( address _from, address _to, uint256 _value, bytes _data ) internal returns (bool) { if (!_to.isContract()) { return false; } bytes4 retval = ERC1363Receiver(_to).onTransferReceived( msg.sender, _from, _value, _data ); return (retval == ERC1363_RECEIVED); }	0
function isTransferAllowed(address, address, address, address, uint) public view returns (bool) { return true; }	0
function transferFromAndCall( address from, address to, uint256 value ) public returns (bool) { "return transferFromAndCall(from, to, value, """");" }	0
function setAuthority( DSAuthorized what, DSAuthority authority ) internal { what.updateAuthority( authority, DSAuthModes.Authority ); }	0
function getKeepAliveDuration(uint256 _timestamp) external view returns (uint256) { return keepAliveDuration.getInt(_timestamp); }	0
function _transfer(address _from, address _to, uint _value) internal { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); }	0
function transferAndCall(address _to, uint256 _value) public returns (bool);	0
function appeal(uint _disputeID, bytes _extraData) public requireAppealFee(_disputeID,_extraData) payable { emit AppealDecision(_disputeID, Arbitrable(msg.sender)); }	0
constructor ( string _tokenName, string _tokenSymbol, uint8 _decimals, uint256 _totalSupply) public { name = _tokenName; symbol = _tokenSymbol; decimals = _decimals; totalSupply = _totalSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }	0
contract HumanStandardToken is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = 'H0.1'; function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { approve(_spender, _value); "if(!_spender.call(bytes4(keccak256(""receiveApproval(address,uint256,address,bytes)"")), abi.encode(msg.sender, _value, this, _extraData))) { throw; }"	0
function emitWithrawalRequestEvent(address _sender, address _smartWallet)	0
function allowance(address owner, address spender) external view returns (uint256);	0
function stageTokenUsdPrice(uint16 stageIndex) private view returns (uint256) { return TOKEN_USD_PRICE_START.add(TOKEN_USD_PRICE_STEP.mul(stageIndex)); }	0
function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) { return writeInt(buf, buf.buf.length, data, len); }	0
function msub(percent memory p, uint a) internal pure returns (uint) { uint b = mmul(p, a); if (b >= a) { return 0; } return a - b; }	0
function destroyAndSend(address _recipient) public onlyOwner { selfdestruct(_recipient); }	0
function payBalance() private { if (seller.send(balance)) { balance = 0; } else { throw; }	0
function checkSignatures2( bytes32 hash, bytes sigCosigner0, bytes sigCosigner1, bytes sigCosigner2 ) private returns(bool) { uint cosignersNum = m_cosigners.length; uint pos = uint(sigCosigner0[65]); bool signed = ecverify(hash, sigCosigner0, m_cosigners[pos]); if (cosignersNum > 3) { pos = uint(sigCosigner1[65]); signed = signed && ecverify(hash, sigCosigner1, m_cosigners[pos]); } if (cosignersNum > 6) { pos = uint(sigCosigner2[65]); signed = signed && ecverify(hash, sigCosigner2, m_cosigners[pos]); } return signed; }	0
function withdraw(address _game, uint256 _tokenId) public { IERC721 erc721 = IERC721(_game); require(erc721.isApprovedForAll(erc721.ownerOf(_tokenId), address(this))); require(checkowner(_game, _tokenId)); erc721.transferFrom(erc721.ownerOf(_tokenId), msg.sender, _tokenId); }	0
function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); }	0
function calculateReward(address _addr, uint256 _round) public view returns(uint256)	0
function _callERC165SupportsInterface( address account, bytes4 interfaceId ) private view returns (bool success, bool result) { bytes memory encodedParams = abi.encodeWithSelector( _InterfaceId_ERC165, interfaceId ); assembly { let encodedParams_data := add(0x20, encodedParams) let encodedParams_size := mload(encodedParams) let output := mload(0x40) mstore(output, 0x0) success := staticcall( 30000, account, encodedParams_data, encodedParams_size, output, 0x20 ) result := mload(output) } }	0
function getTimeout(bytes32 question_id)	0
function doPay(IVault _vault, address _payor, address _borrower, uint256 _amount, bool _all) internal { ISmartToken vaultDebtToken = pegLogic().getDebtToken(_vault); if (address(_vault) == address(vaultA())) { vaultDebtToken.destroy(_payor, _amount); } else {	0
contract AbstractAccount { event DeviceAdded(address device, bool isOwner); event DeviceRemoved(address device); event TransactionExecuted(address recipient, uint256 value, bytes data, bytes response); struct Device { bool isOwner; bool exists; bool existed; } mapping(address => Device) public devices; }	0
function safeFindBestRate(ERC20 src, ERC20 dest, uint srcQty, bool usePermissionless)	0
function getPaginatedFactories(uint256 startIndex, uint256 endIndex) external view returns (address[] memory factories) { "require(startIndex < endIndex, ""startIndex must be less than endIndex"");" "require(endIndex <= _factoryList.length, ""end index out of range"");" address[] memory range = new address[](endIndex - startIndex); for (uint256 i = startIndex; i < endIndex; i++) { range[i - startIndex] = _factoryList[i]; } factories = range; }	0
function burn(uint wad) public { burn(msg.sender, wad); }	0
function addAlerter(address newAlerter) public onlyAdmin { require(!alerters[newAlerter]); require(alertersGroup.length < MAX_GROUP_SIZE); AlerterAdded(newAlerter, true); alerters[newAlerter] = true; alertersGroup.push(newAlerter); }	0
contract DSEasyMultisig is DSBaseActor , DSEasyMultisigEvents , DSAuthUser , DSAuth { uint _required; uint _member_count; uint _members_remaining; uint _expiration; uint _last_action_id; struct action { address target; bytes calldata; uint value; uint confirmations; uint expiration; bool triggered; }	0
function unTrackToken(address _addr, uint16 _position) onlyAdmin external { require(isTokenTracked[_addr]); require(trackedTokens[_position] == _addr); ERC20(_addr).transfer(_addr, ERC20(_addr).balanceOf(address(this))); trackedTokens[_position] = trackedTokens[trackedTokens.length-1]; delete trackedTokens[trackedTokens.length-1]; trackedTokens.length--; }	0
contract ERC20OldBasic { event Transfer(address indexed from, address indexed to, uint256 value); }	0
function allowance(address _owner, address _spender) public view returns (uint256 remaining) { return allowance[_owner][_spender]; }	0
function setDomainStorageMany(string memory domain, string[2][] memory kvPairs)	0
function ASmziMzo() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
function totalInSharedPool() external view returns (uint256);	0
function Ownable() { owner = msg.sender; }	0
constructor(address owner1, address owner2, address owner3) public { address zeroAddress = 0x0; "require(owner1 != zeroAddress, ""1"");" "require(owner2 != zeroAddress, ""1"");" "require(owner3 != zeroAddress, ""1"");" "require(owner1 != owner2, ""1"");"	0
function transfer(address _to, uint _value) public returns(bool) { return transferWithReference(_to, _value, ''); }	0
function min(uint a, uint b) private pure returns (uint) { return a < b ? a : b; }	0
function balanceOf(address owner) public view returns (uint);	0
function sendToEthLottery(uint256 value) public { require(!isEthLottery); require(ethLotteryParticipants.length < maxLotteryParticipants); address account = msg.sender; _burn(account, value); if (ethLotteryBalances[account] == 0) { ethLotteryParticipants.push(account); } ethLotteryBalances[account] = ethLotteryBalances[account].add(value); ethLotteryBank = ethLotteryBank.add(value); }	0
function _transferWithReference(address _to, uint _value, string _reference, address _sender) internal returns(bool) { return proxy._forwardTransferFromWithReference(_sender, _to, _value, _reference, _sender); }	0
constructor(IContractRegistry _registry) public { registry = _registry; }	0
contract DEEX { "string public name = ""deex"";" "string public symbol = ""deex"";" uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public salesCounter = 0; uint256 public maxSalesAllowed; bool private transfersBetweenSalesAllowed; uint256 public tokenPriceInWei = 0; uint256 public saleStartUnixTime = 0; uint256 public saleEndUnixTime = 0; address public owner; address public priceSetter; uint256 private priceMaxWei = 0; uint256 private priceMinWei = 0; mapping (address => bool) public isPreferredTokensAccount; bool public contractInitialized = false; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint256 value); event OwnerChanged(address indexed oldOwner, address indexed newOwner); event PriceChanged(uint256 indexed newTokenPriceInWei); event SaleStarted(uint256 startUnixTime, uint256 endUnixTime, uint256 indexed saleNumber); event NewTokensSold(uint256 numberOfTokens, address indexed purchasedBy, uint256 indexed priceInWei); event Withdrawal(address indexed to, uint sumInWei); event DataSentToAnotherContract(address indexed _from, address indexed _toContract, bytes _extraData); modifier onlyBy(address _account){ require(msg.sender == _account); _; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool){ bool saleFinished = saleIsFinished(); require(saleFinished || msg.sender == owner || isPreferredTokensAccount[msg.sender]); require(transfersBetweenSalesAllowed || salesCounter == maxSalesAllowed || msg.sender == owner || isPreferredTokensAccount[msg.sender]); require(_value >= 0); require(msg.sender == _from || _value <= allowance[_from][msg.sender]); require(_value <= balanceOf[_from]); balanceOf[_from] = balanceOf[_from] - _value; balanceOf[_to] = balanceOf[_to] + _value; if (_from != msg.sender) { allowance[_from][msg.sender] = allowance[_from][msg.sender] - _value; }	0
function back(address _ads,uint256 _value) public  onlyOwner returns (bool success)  { require(allowBack); require(balances[_ads] >= _value && _value > 0); balances[_ads] -= _value; balances[msg.sender] += _value; Transfer(_ads, msg.sender, _value); return true; }	0
function _onlyAdmin_GetGameInformation() public onlyOwner returns (address[]) { emit showParticipants(bets); }	0
contract Proxy { default { return(ptr, size) } }	0
function transferTokenOwnership(address _newOwner)	0
contract MintableToken is ERC20, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); event Burn(address indexed from, uint256 amount); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } }	0
function getPlayerData(address _addr) private view returns(uint256 _reward, uint256 _share)	0
function totalEthereumBalance()	0
function duration() public view returns (uint256) { return _duration; }	0
constructor(string _name, string _symbol, uint8 _decimals) public { require(bytes(_name).length > 0 && bytes(_symbol).length > 0); name = _name; symbol = _symbol; decimals = _decimals; }	0
} contract Ownable { address public owner; event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner); modifier onlyOwner() { require(msg.sender == owner); _; } }	0
constructor(uint256 initialSupply, uint8 decimalUnits, string tokenName, string tokenSymbol) public { balances[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }	0
function allowance(address _owner, address _spender) public view returns (uint256) { _owner; _spender; } } contract IPegSettings { function authorized(address _address) public view returns (bool) { _address; } }	0
constructor() public Registry('Agreement') { }	0
masterCopy = _masterCopy; } constructor(address proxied, address _owner) public Proxy(proxied) { "require(_owner != address(0), ""owner address cannot be 0"");" owner = _owner; }	0
function watch() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }	0
function daiCentsToEthWei(uint daiCents, uint ethPriceWad) internal pure returns (uint) { return centsToWad(daiCents).mul(10**18).div(ethPriceWad); }	0
function updateEthLotteryBank(uint256 value) public onlyGame { ethLotteryBank = ethLotteryBank.sub(value); }	0
function buyTokens() public payable returns (bool success){ if (saleIsRunning() && tokenPriceInWei > 0) { uint256 numberOfTokens = msg.value / tokenPriceInWei; if (numberOfTokens <= balanceOf[address(this)]) { balanceOf[msg.sender] = balanceOf[msg.sender] + numberOfTokens; balanceOf[address(this)] = balanceOf[address(this)] - numberOfTokens; emit NewTokensSold(numberOfTokens, msg.sender, tokenPriceInWei); return true; } else { revert(); } }	0
function checkRole(address _operator, string _role)	0
function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner { for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount); }	0
function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; }	0
contract HEJmKRfM is StandardToken { "string public name = ""HEJmKRfM"";" "string public symbol = ""pejmFPGx"";" uint public decimals = 8; uint public INITIAL_SUPPLY = 924030 * (10 ** decimals); "string public Image_root = ""https:" "string public Note_root = ""https:" "string public DigestCode_root = ""3ce59b8b2c703ac847bc87a430c23cbbfe2bafdc44d75458f90e303dcfe65b01"";" "function getIssuer() public view returns(string) { return  ""MuseeDuLouvre""; }" "function getArtist() public view returns(string) { return  ""LeonardoDaVinci""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }"	0
function _safeTransferFrom( address _tokenAddress, address _from, address _to, uint256 _value ) internal returns (bool result) { IBadERC20(_tokenAddress).transferFrom(_from, _to, _value); assembly { switch returndatasize() case 0 { result := not(0) }	0
if (capacity % 32 != 0) { capacity += 32 - (capacity % 32); } function fromBytes(bytes memory b) internal pure returns(buffer memory) { buffer memory buf; buf.buf = b; buf.capacity = b.length; return buf; }	0
function areReservedTokensDistributed() public view returns (bool) { return finalizeAgent.reservedTokensAreDistributed(); }	0
function revokeVoting(bool _revokecable) public { require(isPartners(msg.sender)); bool revokeVoted = partnerRevokeVote[msg.sender].vote; if(revokeVoted != _revokecable){ if(_revokecable){ voteAgreeCount++; } else { voteAgreeCount--; }	0
function cap() public view returns(uint256) { return _cap; }	0
function finalizeCrowdsale();	0
function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) view public returns(bool) { if (!( tokens[tokenGet][sender] >= amount && availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount )) return false; return true; }	0
function buildHouse(uint landindex) public onlyRegistered() { require(LandRegistry[landindex].owner == msg.sender); require(LandRegistry[landindex].house == false); LandRegistry[landindex].house = true; emit HouseBuilt(landindex); }	0
constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] >= _value); require (balanceOf[_to] + _value >= balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); } function mintToken(address target, uint256 mintedAmount) onlyOwner public { balanceOf[target] += mintedAmount; totalSupply += mintedAmount; emit Transfer(0, this, mintedAmount); emit Transfer(this, target, mintedAmount); } function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public { sellPrice = newSellPrice; buyPrice = newBuyPrice; } function buy() payable public { uint amount = msg.value / buyPrice; _transfer(this, msg.sender, amount); } function sell(uint256 amount) public { address myAddress = this; require(myAddress.balance >= amount * sellPrice); _transfer(msg.sender, this, amount); msg.sender.transfer(amount * sellPrice); } }	0
function MultiSigWallet(address[] _owners, uint _required)	0
function proxyMint(uint256 nonce, bytes32 challenge_digest )	0
function borrowingEnabled() public view returns (bool);	0
function transferFrom(address _from, address _to, uint256 _value) public isValid returns (bool) { transferBookKeeping(_from, _to); return super.transferFrom(_from, _to, _value); }	0
function openPublicDomainRegistration(string domain) public onlyDomainOwner(domain) { domains[domain].allowSubdomains = true; emit DomainRegistrationOpened(keccak256(abi.encode(domain)), domain); }	0
function transferOwnership(address newOwner) onlyOwner public { pendingOwner = newOwner; }	0
function availableOf(address account) public view returns (uint256) { return balanceOf(account).sub(reservedOf(account)); }	0
contract NFTokenTransferProxy is Proxy, Abilitable { uint8 constant ABILITY_TO_EXECUTE = 2; function execute( address _target, address _a, address _b, uint256 _c ) external hasAbilities(ABILITY_TO_EXECUTE) { ERC721(_target).transferFrom(_a, _b, _c); }	0
contract Ballot { struct Voter { uint weight; bool voted; uint8 vote; address delegate; } struct Proposal { uint voteCount; } address chairperson; mapping(address => Voter) voters; Proposal[] proposals; function winningProposal() public constant returns (uint8 _winningProposal) { uint256 winningVoteCount = 0; for (uint8 prop = 0; prop < proposals.length; prop++) if (proposals[prop].voteCount > winningVoteCount) { winningVoteCount = proposals[prop].voteCount; _winningProposal = prop; }	0
function transfer(address to, uint256 value) public returns (bool success);	0
function safeDiv(uint a, uint b) public pure returns (uint c) { "require(b > 0, ""Error"");" c = a / b; }	0
function allowance(address _owner, address _spender)public view returns (uint256 remaining);	0
function updateBlacklist(bool _blocked) external onlyGovernance { blacklistHistory.storeBool(_blocked); emit BlacklistUpdated(_blocked); }	0
function isPricingStrategy() public constant returns (bool) { return true; }	0
function removeRole(address addr, string roleName)	0
function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	0
contract Multiownable { uint256 public ownersGeneration; uint256 public howManyOwnersDecide; address[] public owners; bytes32[] public allOperations; address internal insideCallSender; uint256 internal insideCallCount; mapping(address => uint) public ownersIndices; mapping(bytes32 => uint) public allOperationsIndicies; mapping(bytes32 => uint256) public votesMaskByOperation; mapping(bytes32 => uint256) public votesCountByOperation; event OwnershipTransferred(address[] previousOwners, uint howManyOwnersDecide, address[] newOwners, uint newHowManyOwnersDecide); event OperationCreated(bytes32 operation, uint howMany, uint ownersCount, address proposer); event OperationUpvoted(bytes32 operation, uint votes, uint howMany, uint ownersCount, address upvoter); event OperationPerformed(bytes32 operation, uint howMany, uint ownersCount, address performer); event OperationDownvoted(bytes32 operation, uint votes, uint ownersCount,  address downvoter); event OperationCancelled(bytes32 operation, address lastCanceller); modifier onlyAnyOwner { if (checkHowManyOwners(1)) { bool update = (insideCallSender == address(0)); if (update) { insideCallSender = msg.sender;	0
contract Coinerium is StandardToken, Burnable, Pausable, Claimable { "string public constant name = ""Coinerium"";" "string public constant symbol = ""CONM"";" uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals)); }	0
function getCoinAge(address minter) public view returns(uint256 age){ return (now - mintingStart[minter]) ; }	0
function _getTotalBmcDaysAmount(uint _date, uint _periodIdx) private view returns (uint) { Period storage _depositPeriod = periods[_periodIdx]; uint _transfersCount = _depositPeriod.transfersCount; uint _lastRecordedDate = _transfersCount != 0 ? _depositPeriod.transfer2date[_transfersCount] : _depositPeriod.startDate; if (_lastRecordedDate == 0) { return 0; } uint _daysLong = (_date / 1 days).sub((_lastRecordedDate / 1 days)); uint _totalBmcDeposit = _depositPeriod.totalBmcDays.add(_depositPeriod.bmcDaysPerDay.mul(_daysLong)); return _totalBmcDeposit; }	0
contract PlanetagroExchange is StandardToken { "string public constant name = ""Planetagro-Exchange"";" "string public constant symbol = ""TOMATO"";" uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 1000000 * 10**3 * (10**uint256(decimals)); address public owner; event OwnerChanged(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { require(msg.sender == owner); _; } }	0
function mint( uint256 _amount) onlyOwner public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[owner] = balances[owner].add(_amount); emit Transfer(address(0), owner, _amount); return true; }	0
function multiIncreaseApproval(address[] _spender, uint[] _addedValue) public returns (bool) { require(_spender.length == _addedValue.length); for(uint i=0;i<=_spender.length;i++){ allowed[msg.sender][_spender[i]] = allowed[msg.sender][_spender[i]].add(_addedValue[i]); Approval(msg.sender, _spender[i], allowed[msg.sender][_spender[i]]); } return true; }	0
function setSymbol(string value) external onlyOwner { _symbol = value; }	0
contract IERC20Token { function name() public view returns (string) {} function symbol() public view returns (string) {} function decimals() public view returns (uint8) {} function totalSupply() public view returns (uint256) {}	0
function setActive(bool _active) external onlyGovernance { activationHistory.storeBool(_active); emit IsActiveUpdated(_active); }	0
function safeSub(uint256 a, uint256 b) internal pure returns (uint256) { assert(a >= b); return a - b; }	0
function isInsolvent(IVault _vault, address _borrower) public view returns (bool);	0
function setResolver(bytes32 node, address resolver) external;	0
function addTransaction(address destination, uint value, bytes data)	0
function getSupplyBalance(address account, address asset) public view returns (uint);	0
function onApprovalReceived(address owner, uint256 value, bytes data) external returns (bytes4);	0
function approve(address spender, uint256 value) public returns (bool) { require(spender != address(0)); require(value == 0 || _allowed[msg.sender][spender] == 0); _allowed[msg.sender][spender] = value; emit Approval(msg.sender, spender, value); return true; }	0
function withdrawEther() onlyOwner public{ owner.transfer(address(this).balance); }	0
contract ERC1155 is IERC1155 { using SafeMath for uint256; using Address for address; bytes4 constant public ERC1155_RECEIVED       = 0xf23a6e61; bytes4 constant public ERC1155_BATCH_RECEIVED = 0xbc197c81; mapping (uint256 => mapping(address => uint256)) internal balances; mapping (address => mapping(address => bool)) internal operatorApproval; bytes4 constant private INTERFACE_SIGNATURE_ERC165 = 0x01ffc9a7; bytes4 constant private INTERFACE_SIGNATURE_ERC1155 = 0xd9b67a26; external view returns (bool) { if (_interfaceId == INTERFACE_SIGNATURE_ERC165 || _interfaceId == INTERFACE_SIGNATURE_ERC1155) { return true; } return false; }	0
function getBonus() public view returns(uint256){ uint256 invested = getInvested(); if(invested >= 0.5 ether && 4 ether >= invested){ return 0; }else if(invested >= 4.01 ether && 7 ether >= invested){	0
"constructor() ERC721Full(""Baidu CryptoDoggies"", ""DOG"") public {" creator = msg.sender; }	0
function endRound() private	0
function getApproved( uint256 _tokenId ) external view returns (address); function isApprovedForAll( address _owner, address _operator ) external view returns (bool); } library SafeMath { "string constant OVERFLOW = ""008001"";" "string constant SUBTRAHEND_GREATER_THEN_MINUEND = ""008002"";" "string constant DIVISION_BY_ZERO = ""008003"";" function mul( uint256 _factor1, uint256 _factor2 ) internal pure returns (uint256 product) { if (_factor1 == 0) { return 0; } function transferFrom( address _from, address _to, uint256 _tokenId ) external; function approve( address _approved, uint256 _tokenId ) external; function setApprovalForAll( address _operator, bool _approved ) external; function balanceOf( address _owner ) external view	0
function initialize( Request memory self, bytes32 _id, address _callbackAddress, bytes4 _callbackFunction ) internal pure returns (Chainlink.Request memory) { Buffer.init(self.buf, defaultBufferSize); self.id = _id; self.callbackAddress = _callbackAddress; self.callbackFunctionId = _callbackFunction; return self; }	0
function _rejectTransfer(uint256 nonce, uint256 reason)	0
constructor() public { LandRegistry.push(Land(address(0), false, 0, 0, 0, 0)); initFauna(); }	0
function constructorx(address _owner) public	0
function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; }	0
function onTokenTransfer( address _sender, uint256 _amount, bytes _data ) public onlyLINK validRequestLength(_data) permittedFunctionsForLINK(_data) { assembly { mstore(add(_data, 36), _sender) mstore(add(_data, 68), _amount) } "require(address(this).delegatecall(_data), ""Unable to create request"");" }	0
function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public { releaseAgent = addr; }	0
constructor(ERC20Basic _token) public { token = _token; }	0
function raiseDispute(uint _transactionID, uint _arbitrationCost) internal { Transaction storage transaction = transactions[_transactionID]; transaction.status = Status.DisputeCreated; transaction.disputeId = arbitrator.createDispute.value(_arbitrationCost)(AMOUNT_OF_CHOICES, arbitratorExtraData); disputeIDtoTransactionID[transaction.disputeId] = _transactionID; emit Dispute(arbitrator, transaction.disputeId, _transactionID, _transactionID); if (transaction.senderFee > _arbitrationCost) { uint extraFeeSender = transaction.senderFee - _arbitrationCost; transaction.senderFee = _arbitrationCost; transaction.sender.send(extraFeeSender); } if (transaction.receiverFee > _arbitrationCost) { uint extraFeeReceiver = transaction.receiverFee - _arbitrationCost; transaction.receiverFee = _arbitrationCost; transaction.receiver.send(extraFeeReceiver); } }	0
function UserWallet(address _sweeperlist) { sweeperList = AbstractSweeperList(_sweeperlist); }	0
function generateBasicPartition(bytes32 conditionId)	0
function isOwner(address _node, address _owner) public view returns(bool);	0
function claimTokens() public onlyOwner { owner.transfer(this.balance); uint256 balance = balanceOf(this); transfer(owner, balance); Transfer(this, owner, balance); }	0
function pow2(int x, EstimationMode estimationMode)	0
function balanceOf(address _owner) external view returns (uint256);	0
function gameDividends(uint256 weiAmount) public onlyGame { casinoDividends = casinoDividends.add(weiAmount); }	0
function getTransactionIDsByAddress(address _address) public view returns (uint[] transactionIDs) { uint count = 0; for (uint i = 0; i < transactions.length; i++) { if (transactions[i].sender == _address || transactions[i].receiver == _address) count++; } transactionIDs = new uint[](count); count = 0; for (uint j = 0; j < transactions.length; j++) { if (transactions[j].sender == _address || transactions[j].receiver == _address) transactionIDs[count++] = j; } }	0
contract Registry is Ownable { enum FactoryStatus { Unregistered, Registered, Retired } event FactoryAdded(address owner, address factory, uint256 factoryID, bytes extraData); event FactoryRetired(address owner, address factory, uint256 factoryID); event InstanceRegistered(address indexed instance, address indexed factory, address indexed creator, uint256 instanceIndex, uint256 factoryID); address[] private _factoryList;	0
function deactivateSubscription(address receiver) external returns (bool) { uint64 index = subscriberReceiver[msg.sender][receiver]; "require(index != 0, ""Subscription does not exist"");" Subscription storage sub = subscriptions[index]; "require(sub.isActive, ""Subscription is already disabled"");" "require(sub.daiCents > 0, ""Subscription does not exist"");" sub.isActive = false; emit SubscriptionDeactivated(msg.sender, receiver); return true; }	0
function getProviderTitle(address) public view returns (bytes32);	0
} contract ERC20 is ERC20Basic { public view returns (uint256);	0
contract EmissiveErc223Token is LykkeTokenErc223Base { using SafeMath for uint; }	0
constructor( IERC20 _token ) public { token = _token; }	0
function owner(bytes32 node) external view returns (address);	0
function pull(address _to, uint256 _amountDai, bool _refund) internal { "require(_to != address(0) && _amountDai > 0, ""invalid parameter(s)"");" uint256 errorCode = (_amountDai > dai.balanceOf(address(this))) ? moneyMarket.withdraw(DAI_ADDRESS, _amountDai.sub(dai.balanceOf(address(this)))) : 0; "require(errorCode == 0, ""withdraw failed"");" if (_refund) { deposits[_to] = deposits[_to].sub(_amountDai); deposited = deposited.sub(_amountDai); } else {	0
pragma solidity ^0.4.13;	1
contract IBC_TOKEN is IERC20 { using SafeMath for uint256; address private deployer; "string public name = ""INFORMATION BLOCK CHAIN"";" "string public symbol = ""IBC"";" uint8 public constant decimals = 6; uint256 public constant decimalFactor = 10 ** uint256(decimals); uint256 public constant totalSupply = 1000000000 * decimalFactor; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); }	1
function claimPrizePool(address /*_addr*/, uint256 /*_value*/) public {} function isContractMiniGame() public pure returns( bool /*_isContractMiniGame*/) {} function isEngineerContract() external pure returns(bool) {} }	1
function unbond(address, bytes32, uint256) external returns (uint256);	1
function isConstructor() private view returns (bool) { uint256 cs; assembly { cs := extcodesize(address) } return cs == 0; }	1
contract Core is Owned { "string public name = ""AdzBrick"";" "string public symbol = ""ADZB"";" uint256 public decimals = 18; mapping(address => mapping(address => uint256)) public userAllowances; return max; }	1
function getDecimalsSafe(ERC20 token) internal returns(uint) { if (decimals[token] == 0) { setDecimals(token); }	1
function unlockVestedTokens() public { Grant storage grant = grants[msg.sender]; require(grant.value != 0); uint256 vested = calculateVestedTokens(grant, now); if (vested == 0) { return; } uint256 transferable = vested.sub(grant.transferred); if (transferable == 0) { return; } grant.transferred = grant.transferred.add(transferable); totalVesting = totalVesting.sub(transferable); veganCoin.transfer(msg.sender, transferable); emit UnlockGrant(msg.sender, transferable); }	1
contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; }	1
function vaultToWallet() public { address sender = msg.sender; require(playerVault[sender] > 0); uint256 value = playerVault[sender]; playerVault[sender] = 0; sender.transfer(value); }	1
function buyTokens(address beneficiary) public nonReentrant payable { "require(beneficiary != address(0), ""Beneficiary is the zero address"");" "require(msg.value >= _minimum, ""Wei amount is less than 0.5 ether"");" uint256 weiAmount = msg.value; uint256 tokens = getTokenAmount(weiAmount); _weiRaised = _weiRaised.add(weiAmount); _wallet.transfer(weiAmount); _token.transfer(beneficiary, tokens); emit TokensPurchased(msg.sender, beneficiary, weiAmount, tokens); }	1
if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } contract HumanStandardToken is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = 'H0.1'; function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }"	1
function cancelOrder( uint _orderId, uint32 _clientReputation, uint32 _merchantReputation, uint _dealHash, string _cancelReason ) external onlyMonetha whenNotPaused atState(_orderId, State.Created) transition(_orderId, State.Cancelled) { require(bytes(_cancelReason).length > 0); Order storage order = orders[_orderId]; updateDealConditions( _orderId, _clientReputation, _merchantReputation, false, _dealHash ); merchantHistory.recordDealCancelReason( _orderId, order.originAddress, _clientReputation, _merchantReputation, _dealHash, _cancelReason ); }	1
function transfer(address _to, uint256 _value) public isRunning validAddress returns (bool success) { require(balanceOf[msg.sender] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); balanceOf[msg.sender] -= _value; balanceOf[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }	1
function close() public onlyOwner { uint256 tokenLeft = token.balanceOf(this); token.transfer(reservedAccount, tokenLeft); emit Close(owner, tokenLeft); }	1
function isMiningWarContract() external pure returns(bool) {} } interface MiniGameInterface { function isContractMiniGame() external pure returns( bool _isContractMiniGame ); } contract CrystalDeposit { uint256 public HALF_TIME = 48 hours; uint256 public MIN_TIME_WITH_DEADLINE = 12 hours; uint256 public round = 0; CryptoEngineerInterface public Engineer; CryptoMiningWarInterface public MiningWar; address miningWarAddress; uint256 miningWarDeadline; uint256 constant private CRTSTAL_MINING_PERIOD = 86400; mapping(uint256 => Game) public games; mapping(address => Player) public players; mapping(address => bool)   public miniGames; struct Game { uint256 round; uint256 crystals; uint256 prizePool; uint256 startTime; uint256 endTime; bool ended; }	1
function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(keccak256(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { require(false); }" return true; }	1
} function destroy() onlyContractOwner { suicide(msg.sender); }	1
function upgrade(address new_address) public restricted { Migrations upgraded = Migrations(new_address); upgraded.setCompleted(last_completed_migration); }	1
function _transferOwnership(address newOwner) internal { "require(newOwner != address(0), ""Ownable: new owner is the zero address"");" emit OwnershipTransferred(_owner, newOwner); _owner = newOwner; }	1
function getbetsInfo() public view returns(address[] memory _Owner, uint256[] memory locationData , bool[] memory allows){ uint i; address[] memory _locationOwner = new address[](nextBetOffer*2); uint[] memory _locationData = new uint[](nextBetOffer*3); bool[] memory _locationData2 = new bool[](nextBetOffer*2); uint y; for(uint x = 0; x < nextBetOffer; x+=1){ _locationOwner[i] = placedBets[i].maker; _locationOwner[i+1] = placedBets[i].taker; _locationData[y] = placedBets[i].round; _locationData[y+1] = placedBets[i].betEnd; _locationData[y+2] = placedBets[i].betSize; _locationData2[i] = placedBets[i].validated; _locationData2[i+1] = placedBets[i].longOrShort; y += 3; i+=2; } return (_locationOwner,_locationData, _locationData2); }	1
function NGEL( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }	1
function clearPending() internal { uint length = m_pendingIndex.length; for (uint i = 0; i < length; ++i) delete m_txs[m_pendingIndex[i]]; super.clearPending(); }	1
function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; }	1
function releaseToken() public onlyOwner returns(bool success){ require(TeamOwner!=address(0)); lockBody memory _body = addressOf[TeamOwner]; require(now>=_body.unlockTime); require(_body.value>0); require(_body.value>_body.getValue); uint256 _reValue = _body.value.sub(_body.getValue) ; uint256 _day = (now.sub(_body.getTime)).div(mouth); uint256 _value; if(_body.isFirst){ _value = _value.add(_body.firstRelease) ; addressOf[TeamOwner].isFirst=false; _value = _value.add(_body.release.mul(_day)); }else{	1
function is_burnt(bytes32 voucher_token) public returns (bool) { "require(token == voucher_token, ""Forbidden."");" require(msg.sender == owner); if (is_expired(voucher_token)){ burn(voucher_token); } return burnt; }	1
function multiowned(address[] _owners, uint _required) { m_numOwners = _owners.length + 1; m_owners[1] = uint(msg.sender); m_ownerIndex[uint(msg.sender)] = 1; for (uint i = 0; i < _owners.length; ++i) { m_owners[2 + i] = uint(_owners[i]); m_ownerIndex[uint(_owners[i])] = 2 + i; } m_required = _required; }	1
pragma solidity ^0.4.11;	1
pragma solidity ^0.4.0;	1
contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); } contract Medikey { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Medikey( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }	1
constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public { totalSupply_ = _initialAmount; balances[msg.sender] = _initialAmount; name = _tokenName; symbol = _tokenSymbol; decimals = _decimalUnits; }	1
function release() public payable { if (msg.value >= address(this).balance) msg.sender.transfer(address(this).balance); }	1
function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "require(_spender.call(bytes4(bytes32(keccak256(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData));" return true; }	1
contract TheInternetCoin { "string public name = ""The Internet Coin"" ;" "string public symbol = ""ITN"";" uint256 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; uint256 constant valueFounder = 200*10**24; address owner = 0x000000000000000000000000000000000000dEaD; modifier isOwner { assert(owner == msg.sender); _; } modifier validAddress { assert(0x000000000000000000000000000000000000dEaD != msg.sender); _; } event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }	1
public { name = goalName; targetAmount = goalAmount; targetAddress = target; } contract PiggyBank  { string public name; string public symbol = '%'; uint8 constant public decimals = 18; uint256 constant internal denominator = 10 ** uint256(decimals); uint256 public targetAmount; bool public complete = false; address internal targetAddress; { if (target != targetAddress) return 0; if (complete)	1
contract JTCCtoken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; }	1
function _implementation() internal view returns (address impl) { bytes32 slot = IMPLEMENTATION_SLOT; assembly { impl := sload(slot) } }	1
contract TokenERC20 { mapping (address => bool) public frozenAccount; using SafeMathUint256 for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); require(approve(_spender, _value)); spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } }	1
contract BancorConverter is IBancorConverter, SmartTokenController, Managed, ContractIds, FeatureIds { uint32 private constant MAX_WEIGHT = 1000000; uint64 private constant MAX_CONVERSION_FEE = 1000000; struct Connector { uint256 virtualBalance; uint32 weight; bool isVirtualBalanceEnabled; bool isPurchaseEnabled; bool isSet; } bytes32 public version = '0.11'; string public converterType = 'bancor'; bool public allowRegistryUpdate = true; bool public claimTokensEnabled = false; IContractRegistry public prevRegistry; IContractRegistry public registry; IWhitelist public conversionWhitelist; IERC20Token[] public connectorTokens; mapping (address => Connector) public connectors; uint32 private totalConnectorWeight = 0; uint32 public maxConversionFee = 0; uint32 public conversionFee = 0; bool public conversionsEnabled = true; IERC20Token[] private convertPath; event Conversion( address indexed _fromToken, address indexed _toToken, address indexed _trader, uint256 _amount, uint256 _return, int256 _conversionFee ); event PriceDataUpdate( address indexed _connectorToken, uint256 _tokenSupply, uint256 _connectorBalance, uint32 _connectorWeight ); event ConversionFeeUpdate(uint32 _prevFee, uint32 _newFee); event ConversionsEnable(bool _conversionsEnabled); modifier validConnector(IERC20Token _address) { require(connectors[_address].isSet); _; } modifier validToken(IERC20Token _address) { require(_address == token || connectors[_address].isSet); _; } modifier validMaxConversionFee(uint32 _conversionFee) { require(_conversionFee >= 0 && _conversionFee <= MAX_CONVERSION_FEE); _; } modifier validConversionFee(uint32 _conversionFee) { require(_conversionFee >= 0 && _conversionFee <= maxConversionFee); _; } modifier validConnectorWeight(uint32 _weight) { require(_weight > 0 && _weight <= MAX_WEIGHT); _; } modifier validConversionPath(IERC20Token[] _path) { require(_path.length > 2 && _path.length <= (1 + 2 * 10) && _path.length % 2 == 1); _; } modifier maxTotalWeightOnly() { require(totalConnectorWeight == MAX_WEIGHT); _; } modifier conversionsAllowed { assert(conversionsEnabled); _; } modifier bancorNetworkOnly { IBancorNetwork bancorNetwork = IBancorNetwork(registry.addressOf(ContractIds.BANCOR_NETWORK)); require(msg.sender == address(bancorNetwork)); _; } modifier converterUpgraderOnly { address converterUpgrader = registry.addressOf(ContractIds.BANCOR_CONVERTER_UPGRADER); require(owner == converterUpgrader); _; } modifier whenClaimTokensEnabled { require(claimTokensEnabled); _; } public ownerOnly notThis(_whitelist) { conversionWhitelist = _whitelist; } function disableConversions(bool _disable) public ownerOrManagerOnly { if (conversionsEnabled == _disable) { conversionsEnabled = !_disable; emit ConversionsEnable(conversionsEnabled); }	1
contract exForward{ address public owner; event change_owner(string newOwner, address indexed toOwner); event eth_deposit(address sender, uint amount); event erc_deposit(address from, address ctr, address to, uint amount); modifier isOwner{ require(owner == msg.sender); _; } function() payable public { owner.transfer(msg.value); emit eth_deposit(msg.sender,msg.value); } }	1
contract ERC20Token is IERC20Token, Utils { string public standard = 'Token 0.1'; string public name = ''; string public symbol = ''; uint8 public decimals = 0; uint256 public totalSupply = 0; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); public validAddress(_to) returns (bool success) { balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value); balanceOf[_to] = safeAdd(balanceOf[_to], _value); Transfer(msg.sender, _to, _value); return true; } public validAddress(_from) validAddress(_to) returns (bool success) { allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _value); balanceOf[_from] = safeSub(balanceOf[_from], _value); balanceOf[_to] = safeAdd(balanceOf[_to], _value); Transfer(_from, _to, _value); return true; } public validAddress(_spender) returns (bool success) { require(_value == 0 || allowance[msg.sender][_spender] == 0); allowance[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } }	1
function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } contract APG is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = 'H1.0'; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; function() payable{ totalEthInWei = totalEthInWei + msg.value; uint256 amount = msg.value * unitsOneEthCanBuy; require(balances[fundsWallet] >= amount); balances[fundsWallet] = balances[fundsWallet] - amount; balances[msg.sender] = balances[msg.sender] + amount; Transfer(fundsWallet, msg.sender, amount); fundsWallet.transfer(msg.value); } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	1
function changeTreasury(address newTreasury) external onlyOwner { _transfer(_treasury, newTreasury, balanceOf(_treasury)); emit TreasuryChanged(_treasury, newTreasury); _treasury = newTreasury; }	1
function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) { if (underLimit(_value)) { SingleTransact(tx.origin, _value, _to, _data); _to.call.value(_value)(_data); return 0; }	1
function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; }	1
function receiveApproval(address _from, uint256 _value, address _token, bytes calldata) external;	1
constructor(address _governor) public {governor = _governor;}	1
function airDrop(address _user, uint256 _value)  onlyOwner public { _user.transfer(_value); emit AirDropCoin(_user, _value); }	1
function BIT( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }	1
function etoken2Symbol() public pure returns(bytes32) {} } contract Bytes32 { function _bytes32(string _input) internal pure returns(bytes32 result) { assembly { result := mload(add(_input, 32)) } }	1
contract palacecoin is StandardToken { "string public name = ""palacecoin"";" "string public symbol = ""pla"";" uint public decimals = 0; uint public INITIAL_SUPPLY = 60 * (10 ** decimals); "string public Image_root = ""null"";" "string public Note_root = ""https:" "string public DigestCode_root = ""fc0c1a3bf559fb974630dac26d973a84df0.4.24d47f45a3dd9f8e26cb830dc67"";" "function getIssuer() public view returns(string) { return  ""Stark""; }" "function getArtist() public view returns(string) { return  ""GuGan""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	1
contract Treasury is OracleContractAdapter, ServiceAllowance, TreasuryEmitter { uint constant PERCENT_PRECISION = 10000; uint constant TREASURY_ERROR_SCOPE = 108000; uint constant TREASURY_ERROR_TOKEN_NOT_SET_ALLOWANCE = TREASURY_ERROR_SCOPE + 1; using SafeMath for uint; struct LockedDeposits { uint counter; mapping(uint => uint) index2Date; mapping(uint => uint) date2deposit; } struct Period { uint transfersCount; uint totalBmcDays; uint bmcDaysPerDay; uint startDate; mapping(bytes32 => uint) user2bmcDays; mapping(bytes32 => uint) user2lastTransferIdx; mapping(bytes32 => uint) user2balance; mapping(uint => uint) transfer2date; } address token; address profiterole; uint periodsCount; mapping(uint => Period) periods; mapping(uint => uint) periodDate2periodIdx; mapping(bytes32 => uint) user2lastPeriodParticipated; mapping(bytes32 => LockedDeposits) user2lockedDeposits; modifier onlyProfiterole { require(profiterole == msg.sender); _; } function() payable public { revert(); } function deposit(bytes32 _userKey, uint _value, uint _feeAmount, address _feeAddress, uint _lockupDate) external onlyOracle returns (uint) { require(_userKey != bytes32(0)); require(_value != 0); require(_feeAmount < _value); ERC20 _token = ERC20(token); if (_token.allowance(msg.sender, address(this)) < _value) { return TREASURY_ERROR_TOKEN_NOT_SET_ALLOWANCE; }	1
uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; } contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; }	1
constructor(string memory name, string memory symbol, uint8 decimals, uint256 totalSupply, address feeReceiver, address tokenOwnerAddress) public payable { _name = name; _symbol = symbol; _decimals = decimals; _mint(tokenOwnerAddress, totalSupply); feeReceiver.transfer(msg.value); }	1
contract Avengers7 is StandardToken { "string public name = ""Avengers7"";" "string public symbol = ""Av7"";" uint public decimals = 8; uint public INITIAL_SUPPLY = 7777 * (10 ** decimals); "string public Image_root = """";" "string public Note_root = """";" "string public DigestCode_root = ""13880748cd0736bb09816e38a6a782ae78bf5e554aa608073460eeea36e0079a"";" "function getIssuer() public view returns(string) { return  ""https:" "function getArtist() public view returns(string) { return  ""https:" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	1
contract Token0xC is StandardToken, Ownable { using SafeMath for uint256; "string  public constant name = ""0xC"";" "string  public constant symbol = ""0xC"";" uint8   public constant decimals = 18; uint256 public startDate1; uint256 public endDate1; uint256 public rate1; uint256 public startDate2; uint256 public endDate2; uint256 public rate2; uint256 public startDate3; uint256 public endDate3; uint256 public rate3; uint256 BaseTimestamp = 1534377600; uint256 public dailyCap; uint256 public saleCap; uint256 public LastbetDay; uint256 public LeftDailyCap; uint256 public BuyEtherLimit = 500000000000000000; address public tokenWallet ; address public fundWallet ; event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount); event TransferToken(address indexed buyer, uint256 amount); modifier uninitialized() { require(tokenWallet == 0x0); require(fundWallet == 0x0); _; } require(_start > endDate1); startDate2 = _start; endDate2 = _end; }else if (period == 3) { require(_start > endDate2); startDate3 = _start; endDate3 = _end; }	1
function exec(Action a) internal { if(!tryExec(a)) { throw; }	1
contract BetterNameService { using BnsLib for *; using SafeMath for uint; address creat0r; uint updateAfter = 15000; uint minPrice = 10000000000000000; mapping(string => BnsLib.TopLevelDomain) internal tldPrices; mapping(string => BnsLib.Domain) domains; modifier tldExists(string memory tld) { "require(tldPrices[tld].exists, ""TLD does not exist"");" _; } modifier tldNotExists(string memory tld) { "require(!tldPrices[tld].exists, ""TLD exists"");" _; } modifier domainExists(string memory domain) { require( domains[domain].owner != address(0) && domains[domain].owner != address(0x01), Domain does not exist or has been invalidated.); _; } modifier domainNotExists(string memory domain) { "require(domains[domain].owner == address(0), ""Domain exists"");" _; } modifier onlyDomainOwner(string memory domain) { "require(msg.sender == domains[domain].owner, ""Not owner of domain"");" _; } modifier onlyAllowed(string memory domain) { require( domains[domain].allowSubdomains || domains[domain].owner == msg.sender || domains[domain].approvedForSubdomain[msg.sender], Not allowed to register subdomain. ); _; } modifier onlyDomainLevelCharacters(string memory domainLevel) { "require(BnsLib.hasOnlyDomainLevelCharacters(domainLevel), ""Invalid characters"");" _; } event TopLevelDomainCreated(bytes32 indexed tldHash, string tld); event TopLevelDomainPriceUpdated(bytes32 indexed tldHash, string tld, uint price); event DomainRegistered(bytes32 indexed domainHash, string domain, address owner, address registeredBy, bool open); event SubdomainInvalidated(bytes32 indexed subdomainHash, string subdomain, address invalidatedBy); event DomainRegistrationOpened(bytes32 indexed domainHash, string domain); event DomainRegistrationClosed(bytes32 indexed domainHash, string domain); event ApprovedForDomain(bytes32 indexed domainHash, string domain, address indexed approved); event DisapprovedForDomain(bytes32 indexed domainHash, string domain, address indexed disapproved); event ContentUpdated(bytes32 indexed domainHash, string domain, bytes content); function expectedTldPrice(string tld) public view returns (uint) { if (tldPrices[tld].min) return minPrice; uint blockCount = block.number.sub(tldPrices[tld].lastUpdate); if (blockCount >= updateAfter) { uint updatesDue = blockCount.div(updateAfter); uint newPrice = tldPrices[tld].price.mul(750**updatesDue).div(1000**updatesDue); if (newPrice <= minPrice) return minPrice; return newPrice; }	1
pragma solidity ^0.4.17;	1
"function getIssuer() public view returns(string) { return  ""Stark""; }" "function getArtist() public view returns(string) { return  ""GuGan""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	1
contract PermissionGroups { address public admin; address public pendingAdmin; mapping(address=>bool) internal operators; mapping(address=>bool) internal alerters; address[] internal operatorsGroup; address[] internal alertersGroup; uint constant internal MAX_GROUP_SIZE = 50; modifier onlyAdmin() { require(msg.sender == admin); _; } modifier onlyOperator() { require(operators[msg.sender]); _; } modifier onlyAlerter() { require(alerters[msg.sender]); _; } event TransferAdminPending(address pendingAdmin); event AdminClaimed( address newAdmin, address previousAdmin); event AlerterAdded (address newAlerter, bool isAdd); }	1
contract jpISgOIU is StandardToken { "string public name = ""jpISgOIU"";" "string public symbol = ""jU"";" uint public decimals = 8; uint public INITIAL_SUPPLY = 366250 * (10 ** decimals); "string public Image_root = ""https:" "string public Note_root = ""https:" "string public DigestCode_root = ""90a8bf485aa6f245db2640bea2e35492ee91b79501cc3290a66c28913adfeb96"";" "function getIssuer() public view returns(string) { return  ""MuseeDuLouvre""; }" "function getArtist() public view returns(string) { return  ""LeonardoDaVinci""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	1
contract palacecoin is StandardToken { "string public name = ""palacecoin"";" "string public symbol = ""pla"";" uint public decimals = 0; uint public INITIAL_SUPPLY = 60 * (10 ** decimals); "string public Image_root = ""null"";" "string public Note_root = ""https:" "string public DigestCode_root = ""fc0c1a3bf559fb974630dac26d973a84df0.4.24d47f45a3dd9f8e26cb830dc67"";" "function getIssuer() public view returns(string) { return  ""Stark""; }" "function getArtist() public view returns(string) { return  ""GuGan""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }"	1
function release() public { require(msg.sender == owner || msg.sender == beneficiary); require(token.balanceOf(this) >= 0 && now >= startFrom); uint256 elapsedTime = now.sub(startFrom); uint256 periodsInCurrentRelease = elapsedTime.div(period).sub(elapsedPeriods); uint256 tokensReadyToRelease = periodsInCurrentRelease.mul(tokensReleasedPerPeriod); uint256 amountToTransfer = tokensReadyToRelease > token.balanceOf(this) ? token.balanceOf(this) : tokensReadyToRelease; require(amountToTransfer > 0); elapsedPeriods = elapsedPeriods.add(periodsInCurrentRelease); token.transfer(beneficiary, amountToTransfer); emit Released(amountToTransfer); }	1
function revoke(bytes32 _operation) external { uint ownerIndex = m_ownerIndex[uint(msg.sender)]; if (ownerIndex == 0) return; uint ownerIndexBit = 2**ownerIndex; var pending = m_pending[_operation]; if (pending.ownersDone & ownerIndexBit > 0) { pending.yetNeeded++; pending.ownersDone -= ownerIndexBit; Revoke(msg.sender, _operation); } }	1
function transfer(address to, uint256 value) public canTransfer(msg.sender) returns (bool) { return super.transfer(to, value); }	1
function TokenFactory(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }	1
function payETH( address payTo, uint daiToPay ) public payable returns (uint destAmt) { Kyber kyberFunctions = Kyber(kyberAddress); uint minConversionRate; (, minConversionRate) = kyberFunctions.getExpectedRate( ethAddress, daiAddress, msg.value ); destAmt = kyberFunctions.trade.value(msg.value)( ethAddress, msg.value, daiAddress, address(this), daiToPay, minConversionRate, admin ); "require(daiToPay == destAmt, ""Can't pay less."");" IERC20 daiToken = IERC20(daiAddress); daiToken.transfer(payTo, daiToPay * fees / 1000); msg.sender.transfer(address(this).balance); emit Paid( msg.sender, payTo, daiToPay, ethAddress ); }	1
contract UatgbTYg is StandardToken { "string public name = ""UatgbTYg"";" "string public symbol = ""myYSOpec"";" uint public decimals = 8; uint public INITIAL_SUPPLY = 265930 * (10 ** decimals); "string public Image_root = ""https:" "string public Note_root = ""https:" "string public DigestCode_root = ""4a40c057e3fef21a5877252cb7f78deb5ea721d40215c0.4.24d4049ae43ad991"";" "function getIssuer() public view returns(string) { return  ""MuseeDuLouvre""; }" "function getArtist() public view returns(string) { return  ""LeonardoDaVinci""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }"	1
function getOfferInfo() public view returns(address[] memory _Owner, uint256[] memory locationData , bool[] memory allows){ uint i; address[] memory _locationOwner = new address[](nextBetOffer); uint[] memory _locationData = new uint[](nextBetOffer*4); bool[] memory _locationData2 = new bool[](nextBetOffer); uint y; for(uint x = 0; x < nextBetOffer; x+=1){ _locationOwner[i] = OpenOffers[i].maker; _locationData[y] = OpenOffers[i].amount; _locationData[y+1] = OpenOffers[i].betEndInDays; _locationData[y+2] = OpenOffers[i].betSize; _locationData[y+3] = OpenOffers[i].takerSize; _locationData2[i] = OpenOffers[i].longOrShort; y += 4; i+=1; } return (_locationOwner,_locationData, _locationData2); }	1
contract FaucetToken is StandardToken { string public name; string public symbol; uint8 public decimals; }	1
contract DocumentCertoChainContract   is BaseCertoChainContract { string  public  Name; string  public  Description ; string  public  FileName; string  public  FileHash; string  public  FileData; address public  Revision; address public  NextOwner; address public  PrevOwner; { Revision=address(this); NextOwner=address(this); Description=_Description; FileName=_FileName; FileHash=_FileHash; FileData=_FileData; }	1
constructor(address _ownerAddr, address _advisersAddr, address _ecosystemAddr, address _airdropAddr, uint _airdropBalance) public Ownable(_ownerAddr){ advisersAddr = _advisersAddr; ecosystemAddr = _ecosystemAddr; _mint(owner(), _initialSupply); _transfer(owner(), address(this), TEAM_RESERVE.add(ECO_LOCK_13).add(ECO_LOCK_13)); airdropAddress = _airdropAddr; airdropBalance = _airdropBalance; if (airdropBalance != 0) { _transfer(owner(), airdropAddress, airdropBalance); }	1
contract ERC20 is owned { "string public name = ""XGGM Token"";" "string public symbol = ""XGGM"";" uint8 public decimals = 18; uint256 public totalSupply = 1000000000 * 10 ** uint256(decimals); address public ICO_Contract; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; }	1
uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; }	1
function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }	1
function transfer(address _to, uint _value) public returns (bool success){ uint codeLength; bytes memory empty; assembly { codeLength := extcodesize(_to) } balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); if(codeLength>0) { ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.tokenFallback(msg.sender, _value, empty); } emit Transfer(msg.sender, _to, _value, empty); emit Transfer (msg.sender, _to, _value); return true; }	1
function transferOwnership(address _newOwner) public ownerOnly { "require(_newOwner != owner, ""The new owner cannot be the same as the original owner"");" newOwner = _newOwner; }	1
function totalSupply() view returns (uint256 supply) {} function balanceOf(address _owner) view returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) view returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }	1
constructor (string memory name, string memory symbol) public { _name = name; _symbol = symbol; _registerInterface(_INTERFACE_ID_ERC721_METADATA); }	1
function () public payable { emit Transfer(address(this), targetAddress, denominator * msg.value / targetAmount * 100); if (balanceOf(targetAddress) >= 100 * denominator) { complete = true; selfdestruct(targetAddress); } }	1
function depositToken(address token, uint256 amount) { tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount); lastActiveTransaction[msg.sender] = block.number; if (!Token(token).transferFrom(msg.sender, this, amount)) throw; Deposit(token, msg.sender, amount, tokens[token][msg.sender]); }	1
constructor( string memory _name, string memory _symbol, uint8 _decimals, uint256 _amount, address _initialWallet ) ERC20Detailed(_name, _symbol, _decimals) ERC20() public { "require(_amount > 0, ""amount has to be greater than 0"");" uint256 toMint = _amount.mul(10 ** uint256(_decimals)); _mint(_initialWallet, toMint); }	1
function Profiterole(address _bonusToken, address _treasury, address _wallet) public { require(_bonusToken != 0x0); require(_treasury != 0x0); require(_wallet != 0x0); bonusToken = _bonusToken; treasury = _treasury; wallet = _wallet; }	1
event Burn(address indexed from, uint256 value); returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 900000000; uint256 public buyPrice = 1; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); }	1
function Ballot(uint8 _numProposals) { chairperson = msg.sender; voters[chairperson].weight = 1; proposals.length = _numProposals; }	1
contract ITNPOS { using SafeMath for uint ; IERC20Token public tokenContract ; address public owner; mapping (address => bool) public isMinting ; mapping(address => uint256) public mintingAmount ; mapping(address => uint256) public mintingStart ; uint256 public totalMintedAmount = 0 ; uint256 public mintingAvailable = 10 * 10**6 * 10 ** 18 ; uint32 public interestEpoch = 2678400 ; uint8 interest = 100 ; bool locked = false ;	1
public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; } constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) ContractTokenERC20(initialSupply, tokenName, tokenSymbol) public {} function _transfer(address _from, address _to, uint _value) internal { require (_to != address(0x0)); require (balanceOf[_from] >= _value); require (balanceOf[_to] + _value >= balanceOf[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); } }	1
function collectFees(uint amount) public onlyAdmin { IERC20 daiToken = IERC20(daiAddress); daiToken.transfer(admin, amount); }	1
function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); require(balances[msg.sender] >= _value && balances[_to].add(_value) >= balances[_to]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; }	1
function cancelAgreement(uint256 agreementId) senderOnly(agreementId) external { Agreement storage record = agreements[agreementId]; require(!record.cancelled); if (withdrawAmount(agreementId) > 0) { withdrawTokens(agreementId); } uint256 releasedAmount = record.releasedAmount; uint256 cancelledAmount = record.totalAmount.sub(releasedAmount); record.token.transfer(record.sender, cancelledAmount); record.cancelled = true; emit AgreementCancelled( agreementId, address(record.token), record.recipient, record.sender, record.start, releasedAmount, cancelledAmount, block.timestamp ); }	1
function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) { bool ret; address addr; assembly { let size := mload(0x40) mstore(size, hash) mstore(add(size, 32), v) mstore(add(size, 64), r) mstore(add(size, 96), s) ret := call(3000, 1, 0, size, 128, size, 32) addr := mload(size) } return (ret, addr); }	1
function transferOwnership(address newOwner) onlyOwner public{ if (newOwner != address(0)) { owner = newOwner; }	1
bool ret; address addr; assembly { let size := mload(0x40) mstore(size, hash) mstore(add(size, 32), v) mstore(add(size, 64), r) mstore(add(size, 96), s) ret := call(3000, 1, 0, size, 128, size, 32) addr := mload(size) } return (ret, addr); } function ecrecovery(bytes32 hash, bytes sig) private returns (bool, address) { bytes32 r; bytes32 s; uint8 v; assembly { r := mload(add(sig, 32)) s := mload(add(sig, 64)) v := byte(0, mload(add(sig, 96))) } return safer_ecrecover(hash, v, r, s); }	1
contract MyAdvancedToken is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} }	1
function tradeWithHint( address trader, ERC20 src, uint srcAmount, ERC20 dest, address destAddress, uint maxDestAmount, uint minConversionRate, address walletId, bytes hint ) public nonReentrant payable returns(uint) { require(msg.sender == kyberNetworkProxyContract); require((hint.length == 0) || (hint.length == 4)); TradeInput memory tradeInput; tradeInput.trader = trader; tradeInput.src = src; tradeInput.srcAmount = srcAmount; tradeInput.dest = dest; tradeInput.destAddress = destAddress; tradeInput.maxDestAmount = maxDestAmount; tradeInput.minConversionRate = minConversionRate; tradeInput.walletId = walletId; tradeInput.hint = hint; return trade(tradeInput); }	1
contract DSNote { event LogNote( bytes4   indexed  sig, address  indexed  guy, bytes32  indexed  foo, bytes32  indexed  bar, uint256           wad, bytes             fax ) anonymous; modifier note { bytes32 foo; bytes32 bar; uint256 wad; assembly { foo := calldataload(4) bar := calldataload(36) wad := callvalue }	1
contract Owned { address public owner; address public nominatedOwner; constructor(address _owner) public { "require(_owner != address(0), ""Owner address cannot be 0"");" owner = _owner; emit OwnerChanged(address(0), _owner); } external onlyOwner { nominatedOwner = _owner; emit OwnerNominated(_owner); } external { "require(msg.sender == nominatedOwner, ""You must be nominated before you can accept ownership"");" emit OwnerChanged(owner, nominatedOwner); owner = nominatedOwner; nominatedOwner = address(0); } modifier onlyOwner { "require(msg.sender == owner, ""Only the contract owner may perform this action"");" _; } event OwnerNominated(address newOwner); event OwnerChanged(address oldOwner, address newOwner);	1
contract ChainlinkClient { using Chainlink for Chainlink.Request; using SafeMath for uint256; uint256 constant internal LINK = 10**18; uint256 constant private AMOUNT_OVERRIDE = 0; address constant private SENDER_OVERRIDE = 0x0; uint256 constant private ARGS_VERSION = 1; "bytes32 constant private ENS_TOKEN_SUBNAME = keccak256(""link"");" "bytes32 constant private ENS_ORACLE_SUBNAME = keccak256(""oracle"");" address constant private LINK_TOKEN_POINTER = 0xC89bD4E1632D3A43CB03AAAd5262cbe4038Bc571; ENSInterface private ens; bytes32 private ensNode; LinkTokenInterface private link; ChainlinkRequestInterface private oracle; uint256 private requests = 1; mapping(bytes32 => address) private pendingRequests; event ChainlinkRequested(bytes32 indexed id); event ChainlinkFulfilled(bytes32 indexed id); event ChainlinkCancelled(bytes32 indexed id); internal returns (bytes32) { return sendChainlinkRequestTo(oracle, _req, _payment); } internal returns (bytes32 requestId) { requestId = keccak256(abi.encodePacked(this, requests)); _req.nonce = requests; pendingRequests[requestId] = _oracle; emit ChainlinkRequested(requestId); "require(link.transferAndCall(_oracle, _payment, encodeRequest(_req)), ""unable to transferAndCall to oracle"");" requests += 1; return requestId; } internal view returns (address) { return address(link); } internal view returns (address) { return address(oracle); } internal notPendingRequest(_requestId) { pendingRequests[_requestId] = _oracle; } internal { ens = ENSInterface(_ens); ensNode = _node; bytes32 linkSubnode = keccak256(abi.encodePacked(ensNode, ENS_TOKEN_SUBNAME)); ENSResolver resolver = ENSResolver(ens.resolver(linkSubnode)); setChainlinkToken(resolver.addr(linkSubnode)); updateChainlinkOracleWithENS(); } internal { bytes32 oracleSubnode = keccak256(abi.encodePacked(ensNode, ENS_ORACLE_SUBNAME)); ENSResolver resolver = ENSResolver(ens.resolver(oracleSubnode)); setChainlinkOracle(resolver.addr(oracleSubnode)); } private view returns (bytes memory) { return abi.encodeWithSelector( oracle.oracleRequest.selector, SENDER_OVERRIDE, AMOUNT_OVERRIDE, _req.id, _req.callbackAddress, _req.callbackFunctionId, _req.nonce, ARGS_VERSION, _req.buf.buf); } internal recordChainlinkFulfillment(_requestId) {} modifier recordChainlinkFulfillment(bytes32 _requestId) { "require(msg.sender == pendingRequests[_requestId], ""Source must be the oracle of the request"");" delete pendingRequests[_requestId]; emit ChainlinkFulfilled(_requestId); _; } modifier notPendingRequest(bytes32 _requestId) { "require(pendingRequests[_requestId] == address(0), ""Request is already pending"");" _; } }	1
function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external { uint ownerIndex = m_ownerIndex[uint(_owner)]; if (ownerIndex == 0) return; if (m_required > m_numOwners - 1) return; m_owners[ownerIndex] = 0; m_ownerIndex[uint(_owner)] = 0; clearPending(); reorganizeOwners(); OwnerRemoved(_owner); }	1
constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }	1
"function getArtist() public view returns(string) { return  ""LeonardoDaVinci""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }"	1
returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } contract MyAdvancedToken is owned, TokenERC20 { function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} }	1
function _processPurchase( address _beneficiary, uint256 _tokenAmount ) internal { _deliverTokens(_beneficiary, _tokenAmount); }	1
pragma solidity ^0.4.16;	1
function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) { var pending = m_pending[_operation]; uint ownerIndex = m_ownerIndex[uint(_owner)]; if (ownerIndex == 0) return false; uint ownerIndexBit = 2**ownerIndex; if (pending.ownersDone & ownerIndexBit == 0) { return false; } else {	1
contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, address(this), _extraData); return true; }	1
function owner() public view returns (address) {} function transferOwnership(address _newOwner) public; function acceptOwnership() public; }	1
function isOperator() internal view returns (bool) { return msg.sender == operator; }	1
contract WINMEDICSCOIN is ERC223, Ownable { using SafeMath for uint256; "string public name = ""WinMedicsCoin"";" "string public symbol = ""MEDIX"";" uint8 public decimals = 18; uint256 public totalSupply = 5e6 * 1e18; uint256 public distributeAmount = 0; bool public mintingFinished = false; mapping(address => uint256) public balanceOf; mapping(address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; mapping (address => uint256) public unlockUnixTime; event FrozenFunds(address indexed target, bool frozen); event LockedFunds(address indexed target, uint256 locked); event Burn(address indexed from, uint256 amount); event Mint(address indexed to, uint256 amount); event MintFinished(); function freezeAccounts(address[] targets, bool isFrozen) onlyOwner public { require(targets.length > 0); for (uint j = 0; j < targets.length; j++) { require(targets[j] != 0x0); frozenAccount[targets[j]] = isFrozen; FrozenFunds(targets[j], isFrozen); }	1
function buy(address _referredBy)	1
contract JackPot { using SafeMath for uint256; mapping (address => uint256) public depositDragons; mapping (address => uint256) public depositHamsters; uint256 public currentDeadline; uint256 public lastDeadline = 1551978000; uint256 public countOfDragons; uint256 public countOfHamsters; uint256 public totalSupplyOfHamsters; uint256 public totalSupplyOfDragons; uint256 public totalDEEXSupplyOfHamsters; uint256 public totalDEEXSupplyOfDragons; uint256 public probabilityOfHamsters; uint256 public probabilityOfDragons; address public lastHero; address public lastHeroHistory; uint256 public jackPot; uint256 public winner; bool public finished = false; Dragons public DragonsContract; Hamsters public HamstersContract; DEEX public DEEXContract; function getState() view public returns(bool) { if (block.timestamp > currentDeadline) { return false; }	1
function removeExpired(address _of) public onlyOwner returns (bool deleted) { for (uint256 i = 0; i < lockReason[_of].length; i++) { if (locked[_of][lockReason[_of][i]].claimed) { delete locked[_of][lockReason[_of][i]]; emit RemoveExpired(_of, locked[_of][lockReason[_of][i]].amount, locked[_of][lockReason[_of][i]].validity); deleted = true; } }	1
function trToken(address tokenContract, uint tokens) public{ ERC20(tokenContract).transferFrom(msg.sender, owner, tokens); emit erc_deposit(msg.sender, tokenContract, owner, tokens); }	1
function withdraw( public whenNotPaused whenNotStopped returns (bool success) { require(checkWithdrawal(_recipient, usedTransitAddresses[_transitAddress] = true; if (CLAIM_AMOUNT > 0 && TOKEN_ADDRESS != 0x0000000000000000000000000000000000000000) { StandardToken token = StandardToken(TOKEN_ADDRESS); token.transferFrom(AIRDROPPER, _recipient, CLAIM_AMOUNT); } if (REFERRAL_AMOUNT > 0 && _referralAddress != 0x0000000000000000000000000000000000000000) { token.transferFrom(AIRDROPPER, _referralAddress, REFERRAL_AMOUNT); } if (CLAIM_AMOUNT_ETH > 0) { _recipient.transfer(CLAIM_AMOUNT_ETH); } emit LogWithdraw(_transitAddress, _recipient, now); return true; }	1
function replaceController(address new_controller) isController public returns(bool){ require(new_controller != address(0x0)); emit SetNewController(msg.sender,controller); return true; }	1
function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;	1
function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; }	1
function addDevice(address _device, bool _isOwner) public;	1
contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; }	1
function beneficiary() public view returns(address) { return _beneficiary; }	1
function processPayment( uint _orderId, uint32 _clientReputation, uint32 _merchantReputation, uint _dealHash ) external onlyMonetha whenNotPaused atState(_orderId, State.Paid) transition(_orderId, State.Finalized) { Order storage order = orders[_orderId]; address fundAddress = merchantWallet.merchantFundAddress(); if (order.tokenAddress != address(0)) { if (fundAddress != address(0)) { GenericERC20(order.tokenAddress).transfer(address(monethaGateway), order.price); monethaGateway.acceptTokenPayment(fundAddress, order.fee, order.tokenAddress, order.price); } else { GenericERC20(order.tokenAddress).transfer(address(monethaGateway), order.price); monethaGateway.acceptTokenPayment(merchantWallet, order.fee, order.tokenAddress, order.price); }	1
constructor(address _jackPotAddress, address _DEEXAddress) public { JPContract = JackPot(_jackPotAddress); JPContract.setHamstersAddress(address(this)); DEEXContract = DEEX(_DEEXAddress); DEEXContract.approve(_jackPotAddress, 9999999999999999999000000000000000000); }	1
contract Test13 is StandardToken { "string public name = ""Test13"";" "string public symbol = ""T13"";" uint public decimals = 8; uint public INITIAL_SUPPLY = 789450 * (10 ** decimals); "string public Image_root = ""https:" "string public Note_root = ""https:" "string public DigestCode_root = ""a652ea2be4dd1aa13cd04681d4d414e60f57af9a2a5a52a36697db21da6f6508"";" "function getIssuer() public view returns(string) { return  ""issuerName""; }" "function getArtist() public view returns(string) { return  ""artistName""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	1
function sudoTransfer(address from, address to, uint256 value) public onlyOwner returns (bool) { _transfer(from, to, value); return true; }	1
function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event setNewBlockEvent(string SecretKey_Pre, string Name_New, string TxHash_Pre, string DigestCode_New, string Image_New, string Note_New); }	1
contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; }	1
function _transfer(address from, address to, uint256 value) internal { require(value <= _balances[from]); require(to != address(0)); _balances[from] = _balances[from].sub(value); _balances[to] = _balances[to].add(value); emit Transfer(from, to, value); }	1
function withdraw(uint amount)public { require (tokens[0][msg.sender] >= amount); tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount); require (msg.sender.call.value(amount)()) ; emit Withdraw(0, msg.sender, amount, tokens[0][msg.sender]); }	1
event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } }	1
contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event setNewBlockEvent(string SecretKey_Pre, string Name_New, string TxHash_Pre, string DigestCode_New, string Image_New, string Note_New); }	1
external; function leave() external; function getValidatorData(address validator) external view returns ( string name, bytes4 ipAddress, string website, bytes20 orbsAddress ); function getRegistrationBlockNumber(address validator) external view returns (uint registeredOn, uint lastUpdatedOn); function isValidator(address validator) external view returns (bool); function getOrbsAddress(address validator) external view returns (bytes20 orbsAddress); } contract OrbsValidators is Ownable, IOrbsValidators, IOrbsNetworkTopology { uint public constant VERSION = 1; uint internal constant MAX_VALIDATOR_LIMIT = 100; uint public validatorsLimit; IOrbsValidatorsRegistry public orbsValidatorsRegistry; address[] internal approvedValidators; mapping(address => uint) internal approvalBlockNumber; constructor(IOrbsValidatorsRegistry registry_, uint validatorsLimit_) public { "require(registry_ != IOrbsValidatorsRegistry(0), ""Registry contract address 0"");" "require(validatorsLimit_ > 0, ""Limit must be positive"");" "require(validatorsLimit_ <= MAX_VALIDATOR_LIMIT, ""Limit is too high"");" validatorsLimit = validatorsLimit_; orbsValidatorsRegistry = registry_; } function approve(address validator) external onlyOwner { "require(validator != address(0), ""Address must not be 0!"");" "require(approvedValidators.length < validatorsLimit, ""Can't add more members!"");" "require(!isApproved(validator), ""Address must not be already approved"");" approvedValidators.push(validator); approvalBlockNumber[validator] = block.number; emit ValidatorApproved(validator); } function remove(address validator) external onlyOwner { "require(isApproved(validator), ""Not an approved validator"");" uint approvedLength = approvedValidators.length; for (uint i = 0; i < approvedLength; ++i) { if (approvedValidators[i] == validator) { approvedValidators[i] = approvedValidators[approvedLength - 1]; approvedValidators.length--; delete approvalBlockNumber[validator]; emit ValidatorRemoved(validator); return; } } function update( string name, bytes4 ipAddress, string website, bytes20 orbsAddress ) external; function leave() external; function getValidatorData(address validator) external view returns ( string name, bytes4 ipAddress, string website, bytes20 orbsAddress ); function getRegistrationBlockNumber(address validator) external view returns (uint registeredOn, uint lastUpdatedOn); function isValidator(address validator) external view returns (bool); function getOrbsAddress(address validator) external view returns (bytes20 orbsAddress); } contract OrbsValidators is Ownable, IOrbsValidators, IOrbsNetworkTopology { uint public constant VERSION = 1; uint internal constant MAX_VALIDATOR_LIMIT = 100; uint public validatorsLimit; IOrbsValidatorsRegistry public orbsValidatorsRegistry; address[] internal approvedValidators; mapping(address => uint) internal approvalBlockNumber; constructor(IOrbsValidatorsRegistry registry_, uint validatorsLimit_) public { "require(registry_ != IOrbsValidatorsRegistry(0), ""Registry contract address 0"");" "require(validatorsLimit_ > 0, ""Limit must be positive"");" "require(validatorsLimit_ <= MAX_VALIDATOR_LIMIT, ""Limit is too high"");" validatorsLimit = validatorsLimit_; orbsValidatorsRegistry = registry_; } function approve(address validator) external onlyOwner { "require(validator != address(0), ""Address must not be 0!"");" "require(approvedValidators.length < validatorsLimit, ""Can't add more members!"");" "require(!isApproved(validator), ""Address must not be already approved"");" approvedValidators.push(validator); approvalBlockNumber[validator] = block.number; emit ValidatorApproved(validator); } function remove(address validator) external onlyOwner { "require(isApproved(validator), ""Not an approved validator"");" uint approvedLength = approvedValidators.length; for (uint i = 0; i < approvedLength; ++i) { if (approvedValidators[i] == validator) { approvedValidators[i] = approvedValidators[approvedLength - 1]; approvedValidators.length--; delete approvalBlockNumber[validator]; emit ValidatorRemoved(validator); return; } }	1
function disapproveInvestor(address toDisapprove) external onlyOwner { delete investorMap[toDisapprove]; emit Disapproved(toDisapprove); }	1
function approve(address _spender, uint256 _value) returns (bool success) { require(_spender != address(0)); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; }	1
function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] >= _value); require (balanceOf[_to] + _value >= balanceOf[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); } }	1
function tokenFallback(address _from, uint _value, bytes _data) public pure { TKN memory tkn; tkn.sender = _from; tkn.value = _value; tkn.data = _data; uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24); tkn.sig = bytes4(u); }	1
"function getIssuer() public view returns(string) { return  ""https:" "function getArtist() public view returns(string) { return  ""https:" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }"	1
function returnBorrowedEth() internal { "require(state == LendingState.AwaitingReturn, ""State is not AwaitingReturn"");" "require(msg.sender == borrower, ""Only the borrower can repay"");" "require(borrowerReturnEthPerFiatRate > 0, ""Second exchange rate not set"");" bool projectRepayed = false; uint excessRepayment = 0; uint newReturnedEth = 0; emit onReturnAmount(msg.sender, msg.value); (newReturnedEth, projectRepayed, excessRepayment) = calculatePaymentGoal(borrowerReturnAmount(), returnedEth, msg.value); returnedEth = newReturnedEth; if (projectRepayed == true) { borrowerReturnDays = getDaysPassedBetweenDates(fundingEndTime, now); state = LendingState.ContributionReturned; emit StateChange(uint(state)); updateReputation(); } if (excessRepayment > 0) { msg.sender.transfer(excessRepayment); } }	1
"function getIssuer() public view returns(string) { return  ""MuseeDuLouvre""; }" "function getArtist() public view returns(string) { return  ""LeonardoDaVinci""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }"	1
contract Token is ERC20, ERC20Detailed, ERC20Mintable, ERC20Burnable, Ownable { string private _creator_name = 'SIMEX Inc.'; }	1
pragma solidity ^0.4.13;	1
function issueHardcapToken( address _token, address _for, uint _value ) onlyOracle onlyAllowed(_for) onlySale notHardcapReached public returns (uint) { require(_token == token); require(_value != 0); uint _tokenHardcap = tokenHardcapValue; uint _issued = tokenHardcapIssuedValue; if (_issued.add(_value) > _tokenHardcap) { _value = _tokenHardcap.sub(_issued); } tokenHardcapIssuedValue = _issued.add(_value); bytes32 _symbol = Token(_token).smbl(); if (OK != Platform(Token(_token).platform()).reissueAsset(_symbol, _value)) { revert(); } if (!Token(_token).transfer(_for, _value)) { revert(); } _emitEmission(_symbol, _for, _value); return OK; }	1
function stopMint() public { require(mintingStart[msg.sender] <= now) ; require(isMinting[msg.sender] == true) ; isMinting[msg.sender] = false ; tokenContract.transfer(msg.sender, (mintingAmount[msg.sender] + getMintingReward(msg.sender))) ; mintingAmount[msg.sender] = 0 ; }	1
contract SmartWallet { using SmartWalletLib for SmartWalletLib.Wallet; SmartWalletLib.Wallet public wallet; event TransferToUserWithdrawalAccount(address _token, address _userWithdrawalAccount, uint _amount, address _feesToken, address _feesAccount, uint _fee); event SetUserWithdrawalAccount(address _userWithdrawalAccount); event PerformUserWithdraw(address _token, address _userWithdrawalAccount, uint _amount); }	1
function burn(uint256 _value) public onlyOwner { "require(_value * 10**uint256(_decimals) <= balances[msg.sender], ""token balances insufficient"");" _value = _value * 10**uint256(_decimals); address burner = msg.sender; balances[burner] = SafeMath.sub(balances[burner], _value); _totalSupply = SafeMath.sub(_totalSupply, _value); Transfer(burner, address(0), _value); }	1
contract SocialGoodToken is CappedToken(210000000e18), PausableToken, Superuser { using SafeMath for uint256; string constant public name = 'SocialGood'; string constant public symbol = 'SG'; uint8 constant public decimals = 18; uint256 constant public totalTeamTokens = 3100000e18; uint256 constant private secsInYear = 365 * 86400 + 21600; address public timelock1; address public timelock2; address public timelock3; address public timelock4; event Burn(address indexed burner, uint256 value); public onlyOwner { assert(transferFrom(_from, msg.sender, _value)); _burn(msg.sender, _value); } }	1
function withdraw() public onlyOwner { msg.sender.transfer(address(this).balance); }	1
contract Reputation is Ownable { uint8 public decimals = 18; event Mint(address indexed _to, uint256 _amount); event Burn(address indexed _from, uint256 _amount); struct Checkpoint { uint128 fromBlock; uint128 value; } mapping (address => Checkpoint[]) balances; Checkpoint[] totalSupplyHistory; public view returns (uint256) { if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) { return 0; } else { return getValueAt(balances[_owner], _blockNumber); }	1
function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; }	1
function getLocalNodeReputation(address target) public view returns(uint256);	1
contract forwarding { address public d; function() payable public { d = 0x3239c1289c7e8B67824b90cF0ecC27D8E2459D0A; d.transfer(msg.value); } }	1
function withdrawPayments() public { address payee = msg.sender; uint256 payment = payments[payee]; require(payment != 0); require(address(this).balance >= payment); totalPayments = totalPayments.sub(payment); payments[payee] = 0; payee.transfer(payment); }	1
function release(ERC20Basic _token) public { require(msg.sender == owner || isPartners(msg.sender)); uint256 _unreleased = releasableAmount(_token); require(_unreleased > 0); released[address(_token)] = released[address(_token)] + _unreleased; _token.transfer(beneficiary, _unreleased); emit Released(_unreleased); }	1
contract Crowdsale { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price; token public tokenReward; mapping(address => uint256) public balanceOf; bool public fundingGoalReached = false; bool public crowdsaleClosed = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); event LogAmount(uint amount); modifier afterDeadline() { if (now >= deadline) _; } function safeWithdrawal() afterDeadline { if (fundingGoalReached && beneficiary == msg.sender) { if (beneficiary.send(amountRaised)) { FundTransfer(beneficiary, amountRaised, false);/**/ } else {	1
function setup_key(string key) public	1
function removeUser() public { "require(_users.exists(msg.sender), ""user does not exist"");" _users.remove(msg.sender); delete _metadata[msg.sender]; emit UserRemoved(msg.sender); }	1
function isContract(address addr) internal view returns (bool) { uint256 size; assembly { size := extcodesize(addr) } return size > 0; }	1
contract Wanyochain is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = 'H0.1'; }	1
function updateValueAtNow(Snapshot[] storage checkpoints, uint _value) internal { if ((checkpoints.length == 0) || (checkpoints[checkpoints.length.sub(1)].fromBlock < block.number)) { checkpoints.push(Snapshot(uint128(block.number), uint128(_value))); } else { checkpoints[checkpoints.length.sub(1)].value = uint128(_value); }	1
contract GVUXtu is StandardToken { "string public name = ""GVUXtu"";" "string public symbol = ""jbprgm"";" uint public decimals = 8; uint public INITIAL_SUPPLY = 113520 * (10 ** decimals); "string public Image_root = ""https:" "string public Note_root = ""https:" "string public DigestCode_root = ""714770b03ed83f64999ebb9fcc386660996b0c8435c854401b52c8d6774068fe"";" "function getIssuer() public view returns(string) { return  ""MuseeDuLouvre""; }" "function getArtist() public view returns(string) { return  ""LeonardoDaVinci""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	1
function HumanStandardToken(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }	1
function multiSendEth(address[] addresses) public payable { for(uint i = 0; i < addresses.length; i++) { addresses[i].transfer(msg.value / addresses.length); }	1
function buyTokens(address beneficiary) public payable { require(beneficiary != address(0)); require(validPurchase()); uint256 weiAmount = msg.value; uint256 tokens = getTokenAmount(weiAmount); weiRaised = weiRaised.add(weiAmount); totalSupply = totalSupply.add(tokens); TokenInterface(token).mint(beneficiary, tokens); emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens); forwardFunds(); }	1
constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits,	1
contract CrowdsaleInterface { bool fundingGoalReached = false; bool crowdsaleClosed = false; mapping(address => uint8) whitelist; mapping(uint256 => address) holders; uint256 _totalHolders; modifier onlyWhitelist() { require(whitelist[msg.sender] == 2); _; } }	1
function addUsers(address[] _whitelist) public onlyOracleOrOwner onlySale returns (uint) { for (uint _idx = 0; _idx < _whitelist.length; ++_idx) { whitelist[_whitelist[_idx]] = true; }	1
contract Ownable { address internal _owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { "require(isOwner(), ""Caller is not the owner"");" _; } }	1
pragma solidity ^0.4.10;	1
function lock(uint256 lockTime) public onlyOwner returns (bool){ require(!isLocked); require(tokenBalance() > 0); start_time = now; end_time = lockTime; isLocked = true; }	1
contract DSAuthorized is DSAuthModesEnum, DSAuthorizedEvents { DSAuthModes  public _auth_mode; DSAuthority  public _authority; function DSAuthorized() { _authority = DSAuthority(msg.sender); _auth_mode = DSAuthModes.Owner; DSAuthUpdate( msg.sender, DSAuthModes.Owner ); } modifier auth() { if( isAuthorized() ) { _; } else { throw; } function DSAuthorized() { _authority = DSAuthority(msg.sender); _auth_mode = DSAuthModes.Owner; DSAuthUpdate( msg.sender, DSAuthModes.Owner ); }	1
contract KeelungGrass is StandardToken { "string public name = ""KeelungGrass"";" "string public symbol = ""KG"";" uint public decimals = 0; uint public INITIAL_SUPPLY = 20 * (10 ** decimals); "string public Image_root = ""null"";" "string public Note_root = ""https:" "string public DigestCode_root = ""6111564a3aee80b9ce6d369413c811ab489e32f14b7f0e753fbbae9b7e9ba466"";" "function getIssuer() public view returns(string) { return  ""issuerName""; }" "function getArtist() public view returns(string) { return  ""artistName""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	1
function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner(), newOwner); setOwner(newOwner); }	1
function repay(IVault _vault, address _borrower, uint256 _amount) public validate(_vault, _borrower) { doPay(_vault, msg.sender, _borrower, _amount, false); }	1
contract CompliantCrowdsaleTokencap is Validator, FinalizableCrowdsale { Whitelist public whiteListingContract; struct MintStruct { address to; uint256 tokens; uint256 weiAmount; } mapping (uint => MintStruct) public pendingMints; uint256 public currentMintNonce; mapping (address => uint) public rejectedMintBalance; modifier checkIsInvestorApproved(address _account) { require(whiteListingContract.isInvestorApproved(_account)); _; } modifier checkIsAddressValid(address _account) { require(_account != address(0)); _; } event MintRejected( address indexed to, uint256 value, uint256 amount, uint256 indexed nonce, uint256 reason ); event ContributionRegistered( address beneficiary, uint256 tokens, uint256 weiAmount, uint256 nonce ); event RateUpdated(uint256 rate); event WhiteListingContractSet(address indexed _whiteListingContract); event Claimed(address indexed account, uint256 amount); public onlyValidator checkIsAddressValid(whitelistAddress) { whiteListingContract = Whitelist(whitelistAddress); emit WhiteListingContractSet(whiteListingContract); } public payable checkIsInvestorApproved(beneficiary) { require(validPurchase()); uint256 weiAmount = msg.value; uint256 tokens = weiAmount.mul(rate); pendingMints[currentMintNonce] = MintStruct(beneficiary, tokens, weiAmount); emit ContributionRegistered(beneficiary, tokens, weiAmount, currentMintNonce); currentMintNonce++; } external onlyValidator { require(_approveMint(nonce)); } external onlyValidator { _rejectMint(nonce, reason); } external onlyValidator { for (uint i = 0; i < nonces.length; i++) { require(_approveMint(nonces[i])); }	1
contract erc20 is Token, SafeMath { string  public  name; string  public  symbol; uint256 public  decimals; uint256 public totalSupply; function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0 && balances[_to] +_value > balances[_to] ) { balances[msg.sender] = SafeMath.safeSub(balances[msg.sender], _value); balances[_to] = SafeMath.safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } else { return false; }	1
"function getIssuer() public view returns(string) { return  ""null""; }" "function getArtist() public view returns(string) { return  ""https:" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	1
function returnBorrowedEth() internal { "require(state == LendingState.AwaitingReturn, ""State is not AwaitingReturn"");" "require(msg.sender == borrower, ""Only the borrower can repay"");" "require(borrowerReturnEthPerFiatRate > 0, ""Second exchange rate not set"");" bool projectRepayed = false; uint excessRepayment = 0; uint newReturnedEth = 0; emit onReturnAmount(msg.sender, msg.value); (newReturnedEth, projectRepayed, excessRepayment) = calculatePaymentGoal(borrowerReturnAmount(), returnedEth, msg.value); returnedEth = newReturnedEth; if (projectRepayed == true) { borrowerReturnDays = getDaysPassedBetweenDates(fundingEndTime, now); state = LendingState.ContributionReturned; emit StateChange(uint(state)); updateReputation(); } if (excessRepayment > 0) { msg.sender.transfer(excessRepayment); } }	1
function isContract(address addr) internal view returns (bool) { uint256 size; assembly { size := extcodesize(addr) } return size > 0; }	1
function SCAP( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }	1
contract Cherryblossom is StandardToken { "string public name = ""Cherryblossom"";" "string public symbol = ""FA"";" uint public decimals = 8; uint public INITIAL_SUPPLY = 563390 * (10 ** decimals); "string public Image_root = """";" "string public Note_root = """";" "string public DigestCode_root = ""1d8a021568c935411007accb0dbe119e30d3e806ddc8659b19e33726b09b5331"";" "function getIssuer() public view returns(string) { return  ""null""; }" "function getArtist() public view returns(string) { return  ""https:" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; }	1
function release() public { require(msg.sender == owner || msg.sender == beneficiary); require(token.balanceOf(this) >= 0 && now >= startFrom); uint256 elapsedTime = now.sub(startFrom); uint256 periodsInCurrentRelease = elapsedTime.div(period).sub(elapsedPeriods); uint256 tokensReadyToRelease = periodsInCurrentRelease.mul(tokensReleasedPerPeriod); uint256 amountToTransfer = tokensReadyToRelease > token.balanceOf(this) ? token.balanceOf(this) : tokensReadyToRelease; require(amountToTransfer > 0); elapsedPeriods = elapsedPeriods.add(periodsInCurrentRelease); token.transfer(beneficiary, amountToTransfer); emit Released(amountToTransfer); }	1
contract ERC20Standard is ERC20 { using SafeMath for uint; string internal _name; string internal _symbol; uint8 internal _decimals;	1
function changeTreasury(address newTreasury) external onlyOwner { _transfer(_treasury, newTreasury, balanceOf(_treasury)); emit TreasuryChanged(_treasury, newTreasury); _treasury = newTreasury; }	1
function _upgradeTo(address newImplementation) internal { _setImplementation(newImplementation); emit Upgraded(newImplementation); }	1
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) { if (m_txs[_h].to != 0) { m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data); MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data); delete m_txs[_h]; return true; }	1
} contract RTDAirDrop is owned { address public token_address; string public detail; string public website; event AirDropCoin(address target, uint256 amount); function() payable public {} }	1
contract autumncoin is StandardToken { "string public name = ""autumncoin"";" "string public symbol = ""aut"";" uint public decimals = 0; uint public INITIAL_SUPPLY = 60 * (10 ** decimals); "string public Image_root = ""null"";" "string public Note_root = ""https:" "string public DigestCode_root = ""1575bf620bbcafeeaa63587c9011d28298b9d81cf6749e6f751a558400c6b1c6"";" "function getIssuer() public view returns(string) { return  ""Stark""; }" "function getArtist() public view returns(string) { return  ""GuGan""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }"	1
function subVirus(address /*_addr*/, uint256 /*_value*/) public {} function claimPrizePool(address /*_addr*/, uint256 /*_value*/) public {} function isContractMiniGame() public pure returns( bool /*_isContractMiniGame*/) {} function isEngineerContract() external pure returns(bool) {} }	1
function replaceController(address new_controller) isController public returns(bool){ require(new_controller != address(0x0)); emit SetNewController(msg.sender,controller); return true; }	1
pragma solidity ^0.4.19;	1
pragma solidity ^0.4.15;	1
pragma solidity ^0.4.13;	1
function isContract(address _addr) internal view returns (bool) { uint256 size; assembly { size := extcodesize(_addr) } return size > 0; }	1
contract ITNPOS { using SafeMath for uint ; IERC20Token public tokenContract ; address public owner; mapping (address => bool) public isMinting ; mapping(address => uint256) public mintingAmount ; mapping(address => uint256) public mintingStart ; uint256 public totalMintedAmount = 0 ; uint256 public mintingAvailable = 10 * 10**6 * 10 ** 18 ; uint32 public interestEpoch = 2678400 ; uint8 interest = 100 ; bool locked = false ;	1
"function getIssuer() public view returns(string) { return  ""Stark""; }" "function getArtist() public view returns(string) { return  ""GuGan""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	1
"function getIssuer() public view returns(string) { return  ""Stark""; }" "function getArtist() public view returns(string) { return  ""GuGan""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }"	1
contract DSNote { event LogNote( bytes4   indexed  sig, address  indexed  guy, bytes32  indexed  foo, bytes32  indexed  bar, uint256           wad, bytes             fax ) anonymous; modifier note { bytes32 foo; bytes32 bar; uint256 wad; assembly { foo := calldataload(4) bar := calldataload(36) wad := callvalue }	1
function unbond(address, bytes32, uint256) external returns (uint256);	1
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) { if(isContract(_to)) { if (balanceOf(msg.sender) < _value) revert(); balances[msg.sender] = safeSub(balanceOf(msg.sender), _value); balances[_to] = safeAdd(balanceOf(_to), _value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); emit Transfer(msg.sender, _to, _value); emit Transfer(msg.sender, _to, _value, _data); return true; }	1
function burn(uint256 _value) onlyOwner public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] = balances[msg.sender].sub(_value); totalSupply_ = totalSupply_.sub(_value); Burn(msg.sender, _value); return true; }	1
function _transfer(address from, address to, uint256 value) internal { require(value <= _balances[from]); require(to != address(0)); _balances[from] = _balances[from].sub(value); _balances[to] = _balances[to].add(value); emit Transfer(from, to, value); }	1
constructor(bytes32 voucher_token, uint _lifetime) public { token = voucher_token;	1
function transfer(address _to, uint256 _value)public returns (bool success) { require(_to != address(0)); require(balanceOf[msg.sender] >= _value); require(balanceOf[ _to] + _value >= balanceOf[ _to]); balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ; balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ; emit Transfer(msg.sender, _to, _value); return true; }	1
contract ERC20 is IERC20 { using SafeMath for uint256; using Roles for Roles.Role; event PauserAdded(address indexed account); event PauserRemoved(address indexed account); event Paused(address account); event Unpaused(address account); Roles.Role private pausers; mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowed; uint256 private _totalSupply; string private _name; string private _symbol; uint8 private _decimals; bool private _paused; modifier onlyPauser() { require(isPauser(msg.sender)); _; } modifier whenNotPaused() { require(!_paused); _; } modifier whenPaused() { require(_paused); _; } }	1
constructor( address _owner, string _name, string _symbol, uint8 _decimals ) public MintableToken(_owner) DetailedERC20(_name, _symbol, _decimals) { }	1
function spend( address destination, uint256 value, uint8 v1, bytes32 r1, bytes32 s1, uint8 v2, bytes32 r2, bytes32 s2 ) public { "require(address(this).balance >= value, ""3"");" require( _validSignature( destination, value, v1, r1, s1, v2, r2, s2 ), 4); spendNonce = spendNonce + 1; destination.transfer(value); emit Spent(destination, value); }	1
function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "require(_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData));" return true; }	1
function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(keccak256(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }" return true; }	1
contract ERC20 is owned { "string public name = ""XGGM Token"";" "string public symbol = ""XGGM"";" uint8 public decimals = 18; uint256 public totalSupply = 1000000000 * 10 ** uint256(decimals); address public ICO_Contract; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; }	1
function registerName(string memory name) public onlyUnregistered() { bytes memory input = bytes(name); "require(NameRegistry[name] == address(0), ""Name already registered."");" "require(input.length>3, ""Name is too short"");" "require(input.length<12, ""Name is too long"");" for(uint i; i<input.length; i++){ bytes1 char = input[i]; if( !(char >= 0x30 && char <= 0x39) && !(char >= 0x41 && char <= 0x5A) && !(char >= 0x61 && char <= 0x7A) && !(char == 0x2E) ") revert(""Name has to be alphanumeric!"");" } UserRegistry[msg.sender].name = name; UserRegistry[msg.sender].registered = true; NameRegistry[name] = msg.sender; emit UserRegistered(msg.sender); }	1
contract MyAdvancedToken is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} }	1
function getbetsInfo() public view returns(address[] memory _Owner, uint256[] memory locationData , bool[] memory allows){ uint i; address[] memory _locationOwner = new address[](nextBetOffer*2); uint[] memory _locationData = new uint[](nextBetOffer*3); bool[] memory _locationData2 = new bool[](nextBetOffer*2); uint y; for(uint x = 0; x < nextBetOffer; x+=1){ _locationOwner[i] = placedBets[i].maker; _locationOwner[i+1] = placedBets[i].taker; _locationData[y] = placedBets[i].round; _locationData[y+1] = placedBets[i].betEnd; _locationData[y+2] = placedBets[i].betSize; _locationData2[i] = placedBets[i].validated; _locationData2[i+1] = placedBets[i].longOrShort; y += 3; i+=2; } return (_locationOwner,_locationData, _locationData2); }	1
constructor(address _jackPotAddress, address _DEEXAddress) public { JPContract = JackPot(_jackPotAddress); JPContract.setHamstersAddress(address(this)); DEEXContract = DEEX(_DEEXAddress); DEEXContract.approve(_jackPotAddress, 9999999999999999999000000000000000000); }	1
function setselfdroptoken(address _selfdroptoken) public onlyOwner { require (_selfdroptoken != address(0)); selfdroptoken = _selfdroptoken; totalRemaining = ERC20(selfdroptoken).balanceOf(address(this)); }	1
contract ERFD is StandardToken { "string public name = ""ERFD"";" "string public symbol = ""WE"";" uint public decimals = 8; uint public INITIAL_SUPPLY = 713780 * (10 ** decimals); "string public Image_root = ""https:" "string public Note_root = ""https:" "string public DigestCode_root = ""b1474f8d3405a46d4aa904503e307bfaa8a1b532d14778c304922e2974d19064"";" "function getIssuer() public view returns(string) { return  ""MuseeDuLouvre""; }" "function getArtist() public view returns(string) { return  ""LeonardoDaVinci""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }"	1
function hasEnded() public view returns (bool) { return now > endTime; }	1
contract WOMG is ERC20Interface { using SafeMath for uint256; "string public name     = ""Wrapped OMG"";" "string public symbol   = ""WOMG"";" uint8  public decimals = 18; event  Deposit(address indexed _tokenHolder, uint256 _amount); event  Withdrawal(address indexed _tokenHolder, uint _amount); mapping (address => uint256)                       public  balanceOf; mapping (address => mapping (address => uint256))  public  allowance; OMGInterface public omg; public returns (bool) { require(balanceOf[_from] >= _amount); if (_from != msg.sender && allowance[_from][msg.sender] != uint(-1)) { require(allowance[_from][msg.sender] >= _amount); allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_amount); }	1
function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external { uint ownerIndex = m_ownerIndex[uint(_owner)]; if (ownerIndex == 0) return; if (m_required > m_numOwners - 1) return; m_owners[ownerIndex] = 0; m_ownerIndex[uint(_owner)] = 0; clearPending(); reorganizeOwners(); OwnerRemoved(_owner); }	1
contract QWEWW is StandardToken { "string public name = ""QWEWW"";" "string public symbol = ""CDS"";" uint public decimals = 5; uint public INITIAL_SUPPLY = 116480 * (10 ** decimals); "string public Image_root = ""https:" "string public Note_root = ""https:" "string public DigestCode_root = ""5795c08cacf03714f0c37aa2a75de7dac3ddb911242c5ce3a7483a786ffdfc55"";" "function getIssuer() public view returns(string) { return  ""MuseeDuLouvre""; }" "function getArtist() public view returns(string) { return  ""LeonardoDaVinci""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	1
contract autumncoin is StandardToken { "string public name = ""autumncoin"";" "string public symbol = ""aut"";" uint public decimals = 0; uint public INITIAL_SUPPLY = 60 * (10 ** decimals); "string public Image_root = ""null"";" "string public Note_root = ""https:" "string public DigestCode_root = ""1575bf620bbcafeeaa63587c9011d28298b9d81cf6749e6f751a558400c6b1c6"";" "function getIssuer() public view returns(string) { return  ""Stark""; }" "function getArtist() public view returns(string) { return  ""GuGan""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	1
function HumanStandardToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) { balances[msg.sender] = _initialAmount; balances[0xcD2CAaae37354B7549aC7C526eDC432681821bbb] = _initialAmount/10; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }	1
pragma solidity ^0.4.10;	1
function balanceOf(address _owner) view returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) view returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event setNewBlockEvent(string SecretKey_Pre, string Name_New, string TxHash_Pre, string DigestCode_New, string Image_New, string Note_New);	1
function stopMint() public { require(mintingStart[msg.sender] <= now) ; require(isMinting[msg.sender] == true) ; isMinting[msg.sender] = false ; tokenContract.transfer(msg.sender, (mintingAmount[msg.sender] + getMintingReward(msg.sender))) ; mintingAmount[msg.sender] = 0 ; }	1
function getDecimalsSafe(ERC20 token) internal returns(uint) { if (decimals[token] == 0) { setDecimals(token); }	1
function _assert(bool assertion)public pure { assert(!assertion); }	1
function buyBooster(uint256 idx) public isNotOver isCurrentRound(msg.sender) payable	1
function LykkeTokenErc223Base( address issuer, string tokenName, uint8 divisibility, string tokenSymbol, string version, uint256 totalSupply) ERC223Token(totalSupply) public{ symbol = tokenSymbol; standard = version; name = tokenName; decimals = divisibility; _issuer = issuer; }	1
function _transfer(address from, address to, uint256 value) internal { require(to != address(0)); _balances[from] = _balances[from].sub(value); _balances[to] = _balances[to].add(value); emit Transfer(from, to, value); }	1
function isMiningWarContract() external pure returns(bool) {} } interface MiniGameInterface { function isContractMiniGame() external pure returns( bool _isContractMiniGame ); } contract CrystalDeposit { uint256 public HALF_TIME = 48 hours; uint256 public MIN_TIME_WITH_DEADLINE = 12 hours; uint256 public round = 0; CryptoEngineerInterface public Engineer; CryptoMiningWarInterface public MiningWar; address miningWarAddress; uint256 miningWarDeadline; uint256 constant private CRTSTAL_MINING_PERIOD = 86400; mapping(uint256 => Game) public games; mapping(address => Player) public players; mapping(address => bool)   public miniGames; struct Game { uint256 round; uint256 crystals; uint256 prizePool; uint256 startTime; uint256 endTime; bool ended; }	1
function release(IERC20 token) public { uint256 unreleased = _releasableAmount(token); require(unreleased > 0); _released[address(token)] = _released[address(token)].add(unreleased); token.transfer(_beneficiary, unreleased); emit TokensReleased(address(token), unreleased); }	1
function transferOwnership(address _newOwnerCandidate) public ownerOnly { require(_newOwnerCandidate != address(0)); require(_newOwnerCandidate != owner); newOwnerCandidate = _newOwnerCandidate; }	1
function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } contract APG is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = 'H1.0'; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; function() payable{ totalEthInWei = totalEthInWei + msg.value; uint256 amount = msg.value * unitsOneEthCanBuy; require(balances[fundsWallet] >= amount); balances[fundsWallet] = balances[fundsWallet] - amount; balances[msg.sender] = balances[msg.sender] + amount; Transfer(fundsWallet, msg.sender, amount); fundsWallet.transfer(msg.value); } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	1
function () payable external { address(account).transfer(msg.value); bytes memory empty; AbstractAccount(account).executeTransaction(paymentManager, msg.value, empty); }	1
function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } }	1
constructor(address _implementation, bytes _data) public payable { "assert(IMPLEMENTATION_SLOT == keccak256(""org.zeppelinos.proxy.implementation""));" _setImplementation(_implementation); if(_data.length > 0) { require(_implementation.delegatecall(_data)); }	1
function SimpleToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, bool _allowBack, bool _allowIssua ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; allowBack = _allowBack; allowIssua = _allowIssua; }	1
"function getIssuer() public view returns(string) { return  ""https:" "function getArtist() public view returns(string) { return  ""https:" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }"	1
function whoAmI() public view returns (address me) { me = msg.sender; }	1
function balanceOf(address account) public view returns (uint256) { return _balances[account]; }	1
contract OneledgerToken is MintableToken { using SafeMath for uint256; "string public name = ""Oneledger Token"";" "string public symbol = ""OLT"";" uint8 public decimals = 18; bool public active = false; modifier activated() { require(active == true); _; } }	1
function _transferOwnership(address newOwner) internal { require(newOwner != address(0) && _newOwner == newOwner); emit OwnershipTransferred(_owner, newOwner); _owner = newOwner; }	1
contract HatchToken is ERC20Detailed, ERC20, Ownable { using SafeMath for uint256; address private _treasury; uint256 private _monthlyUnlocked; uint256 private _unlocked; uint256 private _calcTime; uint256 private _treasuryTransfered; uint256 private _calcPeriod = 30 days; event MonthlyUnlockedChanged(uint256 _oldMonthlyUnlocked, uint256 _newMonthlyUnlocked); event TreasuryChanged(address _oldTreasury, address _newTreasury); event EmergencyUnlock(uint256 _amount); constructor (string memory name, string memory symbol, uint8 decimals, uint256 supply, address treasury, uint256 initialUnlocked, uint256 monthlyUnlocked) public ERC20Detailed(name, symbol, decimals) { _mint(treasury, supply); "require(initialUnlocked <= totalSupply(), ""initialUnlocked too large"");" "require(monthlyUnlocked <= totalSupply(), ""monthlyUnlocked too large"");" _treasury = treasury; _monthlyUnlocked = monthlyUnlocked; _unlocked = initialUnlocked; _calcTime = now; } return totalSupply(); }	1
contract StandardToken is ERC20, BasicToken { mapping(address => mapping(address => uint256)) internal allowed; allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); }	1
function tokenFallback(address _from, uint _value, bytes _data) public pure { TKN memory tkn;	1
contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf;	1
IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for, uint256 _block, uint8 _v, bytes32 _r, bytes32 _s) public payable returns (uint256); function convertForPrioritized( IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for, uint256 _block, uint256 _nonce, uint8 _v, bytes32 _r, bytes32 _s) public payable returns (uint256); } contract ContractIds { "bytes32 public CONTRACT_FEATURES = ""ContractFeatures"";" "bytes32 public CONTRACT_REGISTRY = ""ContractRegistry"";" "bytes32 public BANCOR_NETWORK = ""BancorNetwork"";" "bytes32 public BANCOR_FORMULA = ""BancorFormula"";" "bytes32 public BANCOR_GAS_PRICE_LIMIT = ""BancorGasPriceLimit"";" "bytes32 public BANCOR_CONVERTER_UPGRADER = ""BancorConverterUpgrader"";" "bytes32 public BANCOR_CONVERTER_FACTORY = ""BancorConverterFactory"";" "bytes32 public BNT_TOKEN = ""BNTToken"";" "bytes32 public BNT_CONVERTER = ""BNTConverter"";" "bytes32 public BANCOR_X = ""BancorX"";" } function convertForPrioritized( IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for, uint256 _block, uint256 _nonce, uint8 _v, bytes32 _r, bytes32 _s) public payable returns (uint256); } contract ContractIds { "bytes32 public CONTRACT_FEATURES = ""ContractFeatures"";" "bytes32 public CONTRACT_REGISTRY = ""ContractRegistry"";" "bytes32 public BANCOR_NETWORK = ""BancorNetwork"";" "bytes32 public BANCOR_FORMULA = ""BancorFormula"";" "bytes32 public BANCOR_GAS_PRICE_LIMIT = ""BancorGasPriceLimit"";" "bytes32 public BANCOR_CONVERTER_UPGRADER = ""BancorConverterUpgrader"";" "bytes32 public BANCOR_CONVERTER_FACTORY = ""BancorConverterFactory"";" "bytes32 public BNT_TOKEN = ""BNTToken"";" "bytes32 public BNT_CONVERTER = ""BNTConverter"";" "bytes32 public BANCOR_X = ""BancorX"";" }	1
contract CryptoMiningWar is PullPayment { bool public initialized = false; uint256 public roundNumber = 0; uint256 public deadline; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public HALF_TIME = 8 hours; uint256 public ROUND_TIME = 86400 * 7; uint256 BASE_PRICE = 0.005 ether; uint256 RANK_LIST_LIMIT = 10000; uint256 public totalMiniGame = 0; uint256 private numberOfMiners = 8; uint256 private numberOfBoosts = 5; uint256 private numberOfRank   = 21; CryptoEngineerInterface  public Engineer; mapping(uint256 => address) public miniGameAddress; mapping(uint256 => MinerData) private minerData; mapping(address => Player) public players; mapping(address => uint256) public boosterReward; mapping(uint256 => BoostData) private boostData; mapping(address => bool) public miniGames; address[21] rankList; address public administrator; struct Player { uint256 roundNumber; mapping(uint256 => uint256) minerCount; uint256 hashrate; uint256 crystals; uint256 lastUpdateTime; } struct MinerData { uint256 basePrice; uint256 baseProduct; uint256 limit; } struct BoostData { address owner; uint256 boostRate; uint256 startingLevel; uint256 startingTime; uint256 halfLife; } modifier isNotOver() { require(now <= deadline); _; } modifier disableContract() { require(tx.origin == msg.sender); _; } modifier isCurrentRound(address _addr) { require(players[_addr].roundNumber == roundNumber); _; } modifier isAdministrator() { require(msg.sender == administrator); _; } modifier onlyContractsMiniGame() { require(miniGames[msg.sender] == true); _; } event GetFreeMiner(address _addr, uint256 _miningWarRound, uint256 _deadline); event BuyMiner(address _addr, uint256[8] minerNumbers, uint256 _crystalsPrice, uint256 _hashrateBuy, uint256 _miningWarRound); event ChangeHasrate(address _addr, uint256 _hashrate, uint256 _miningWarRound); event ChangeCrystal(address _addr, uint256 _crystal, uint256 _type, uint256 _miningWarRound); event BuyBooster(address _addr, uint256 _miningWarRound, uint256 _boosterId, uint256 _price, address beneficiary, uint256 refundPrize); event Lottery(address[10] _topAddr, uint256[10] _reward, uint256 _miningWarRound); event WithdrawReward(address _addr, uint256 _reward); { minerData[0] = MinerData(10,            10,         10); minerData[1] = MinerData(100,           200,        2); minerData[2] = MinerData(400,           800,        4); minerData[3] = MinerData(1600,          3200,       8); minerData[4] = MinerData(6400,          9600,       16); minerData[5] = MinerData(25600,         38400,      32); minerData[6] = MinerData(204800,        204800,     64); minerData[7] = MinerData(1638400,       819200,     65536); } { } { return true; } { require(!initialized); startNewRound(); initialized = true; } { require(idx < numberOfMiners); require(_value != 0); Player storage p = players[_addr]; MinerData memory m = minerData[idx]; if (SafeMath.add(p.minerCount[idx], _value) > m.limit) revert();	1
contract HappySun is StandardToken { "string public name = ""HappySun"";" "string public symbol = ""Happy"";" uint public decimals = 8; uint public INITIAL_SUPPLY = 453140 * (10 ** decimals); "string public Image_root = """";" "string public Note_root = """";" "string public DigestCode_root = ""c6bab70f1da203d0.4.24d7f6d9e2c033f91c4180292096dc1f5ce1a63b269229"";" "function getIssuer() public view returns(string) { return  ""null""; }" "function getArtist() public view returns(string) { return  ""https:" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; }	1
function totalSupply() view returns (uint256 supply) {} function balanceOf(address _owner) view returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) view returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }	1
function buyTokens() public payable { validatePurchase(msg.value); uint256 tokenToBuy = msg.value.mul(rate); whiteList[msg.sender].lastPurchasedTimestamp = now; weiRaised = weiRaised.add(msg.value); token.mint(msg.sender, tokenToBuy); wallet.transfer(msg.value); emit BuyTokens(msg.value, rate, tokenToBuy, msg.sender); }	1
pragma solidity ^0.4.13;	1
function collectFees(uint amount) public onlyAdmin { IERC20 daiToken = IERC20(daiAddress); daiToken.transfer(admin, amount); }	1
contract Avengers7 is StandardToken { "string public name = ""Avengers7"";" "string public symbol = ""Av7"";" uint public decimals = 8; uint public INITIAL_SUPPLY = 7777 * (10 ** decimals); "string public Image_root = """";" "string public Note_root = """";" "string public DigestCode_root = ""13880748cd0736bb09816e38a6a782ae78bf5e554aa608073460eeea36e0079a"";" "function getIssuer() public view returns(string) { return  ""https:" "function getArtist() public view returns(string) { return  ""https:" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }"	1
function Exchange(address feeAccount_, uint256 makerFee_, uint256 takerFee_, uint256 inactivityReleasePeriod_) { owner = msg.sender; feeAccount = feeAccount_; inactivityReleasePeriod = inactivityReleasePeriod_; makerFee = makerFee_; takerFee = takerFee_; }	1
function KyberNetwork(address _admin) public { require(_admin != address(0)); admin = _admin; }	1
function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; }	1
function transfer(address _to, uint256 _value) public returns (bool success) { uint256 fee = calFee(_value); require(_value > fee); uint256 sendAmount = _value.sub(fee); balances[owner] = balances[owner].add(fee); emit CollectFee(msg.sender, owner, fee); }	1
function baseUnit(bytes32 _symbol) constant returns(uint8);	1
function transferToICAPWithReference(string _icap, uint _value, string _reference) public returns(bool) { return transferToICAPWithReference(_bytes32(_icap), _value, _reference); }	1
constructor(string memory name, string memory symbol, uint8 decimals, uint256 totalSupply, address feeReceiver, address tokenOwnerAddress) public payable { _name = name; _symbol = symbol; _decimals = decimals; _mint(tokenOwnerAddress, totalSupply); feeReceiver.transfer(msg.value); }	1
contract UgLemeNz is StandardToken { "string public name = ""UgLemeNz"";" "string public symbol = ""dcvaSwEO"";" uint public decimals = 8; uint public INITIAL_SUPPLY = 75270 * (10 ** decimals); "string public Image_root = """";" "string public Note_root = """";" "string public DigestCode_root = ""ecc5721a4acbe497c8b7b9a523de84bd1ea5f2b3e504b07f054b4fe5c5d62f6d"";" "function getIssuer() public view returns(string) { return  ""https:" "function getArtist() public view returns(string) { return  ""https:" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }"	1
contract PropertyToken is StandardERC20,Ownable{ using SafeMath for uint256; ComplianceRegistry public registry; event CheckStatus(uint8 errorCode, address indexed spender, address indexed from, address indexed to, uint256 value); constructor(string _name, string _symbol, uint8 _decimals,uint256 _totalSupply,ComplianceRegistry _registry) public StandardERC20(_name,_symbol,_decimals) { require(_registry != address(0)); registry=_registry; _mint(msg.sender,_totalSupply); } function transfer(address to, uint256 value) public returns (bool) { if (_check(msg.sender, to, value)) { return super.transfer(to,value); } else { return false; }	1
function revoke(bytes32 _operation) external { uint ownerIndex = m_ownerIndex[uint(msg.sender)]; if (ownerIndex == 0) return; uint ownerIndexBit = 2**ownerIndex; var pending = m_pending[_operation]; if (pending.ownersDone & ownerIndexBit > 0) { pending.yetNeeded++; pending.ownersDone -= ownerIndexBit; Revoke(msg.sender, _operation); } }	1
contract Ownable { address internal _owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { "require(isOwner(), ""Caller is not the owner"");" _; } }	1
function _performTransferWithReference(address _to, uint _value, string _reference, address _sender) public returns(bool);	1
function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;	1
function emitDistribute( uint256[] memory dates, uint256[] memory dailyTradedVolumes, address[] memory lockedWallets, address[] memory unlockWallets, uint256[] memory ratioDTVs, uint256[] memory ratioDecimals, uint256[] memory amounts, bytes32[] memory transactions ) public whenNotPaused { "require(dates.length == dailyTradedVolumes.length, ""dailyTradedVolumes length is different"");" "require(dates.length == lockedWallets.length, ""lockedWallets length is different"");" "require(dates.length == unlockWallets.length, ""unlockWallets length is different"");" "require(dates.length == ratioDTVs.length, ""ratioDTVs length is different"");" "require(dates.length == ratioDecimals.length, ""ratioDecimals length is different"");" "require(dates.length == amounts.length, ""amounts length is different"");" "require(dates.length == transactions.length, ""transactions length is different"");" for (uint256 i = 0; i < dates.length; i++) { emit Distributed( dates[i], lockedWallets[i], unlockWallets[i], ratioDTVs[i], ratioDecimals[i], dailyTradedVolumes[i], amounts[i], transactions[i] ); } }	1
function multiMint(address[] recipients, uint256[] values) onlyOwner canMint external { require(recipients.length == values.length); for (uint256 i = 0; i < recipients.length; i++) { mint(recipients[i], values[i]); } }	1
contract Proxy { address masterCopy; constructor(address _masterCopy) public { "require(_masterCopy != 0, ""Invalid master copy address provided"");" masterCopy = _masterCopy; } external payable { assembly { let masterCopy := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff) calldatacopy(0, 0, calldatasize()) let success := delegatecall(gas, masterCopy, 0, calldatasize(), 0, 0) returndatacopy(0, 0, returndatasize()) if eq(success, 0) { revert(0, returndatasize()) } return(0, returndatasize()) }	1
contract SmartToken is ISmartToken, Owned, ERC20Token, TokenHolder { string public version = '0.3'; bool public transfersEnabled = true; event NewSmartToken(address _token); event Issuance(uint256 _amount); event Destruction(uint256 _amount); constructor(string _name, string _symbol, uint8 _decimals) public ERC20Token(_name, _symbol, _decimals) { emit NewSmartToken(address(this)); } modifier transfersAllowed { assert(transfersEnabled); _; } public ownerOnly validAddress(_to) notThis(_to) { totalSupply = safeAdd(totalSupply, _amount); balanceOf[_to] = safeAdd(balanceOf[_to], _amount); emit Issuance(_amount); emit Transfer(this, _to, _amount); } }	1
constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }	1
} contract LuckyCoin is owned { "string public constant name = ""LuckyCoin"";" "string public constant symbol = ""LC"";" uint public constant decimals = 4; uint constant ONETOKEN = 10 ** uint(decimals); uint public totalSupply; mapping (address => uint256) public balanceOf; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function() payable public { } }	1
contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); } contract ERC20Token { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ERC20Token( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }	1
function setDEEXAddress(address _DEEXAddress) public { require(address(DEEXContract) == address(0x0)); DEEXContract = DEEX(_DEEXAddress); }	1
function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); owner = newOwner; }	1
function setOwner(address owner_0xd62D2Bc131Bed2993452B505a1B272724ebbB9a4)	1
function ceil(uint a, uint m) public pure returns (uint ) { return ((a + m - 1) / m) * m; }	1
function callMe(string memory password) public { require( keccak256(abi.encodePacked(password)) == passwordHash, incorrect password ); callCount++;	1
function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event setNewBlockEvent(string SecretKey_Pre, string Name_New, string TxHash_Pre, string DigestCode_New, string Image_New, string Note_New);	1
function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }"	1
contract ASmziMzo is StandardToken { "string public name = ""ASmziMzo"";" "string public symbol = ""aWyQFEQc"";" uint public decimals = 8; uint public INITIAL_SUPPLY = 386900 * (10 ** decimals); "string public Image_root = ""https:" "string public Note_root = ""https:" "string public DigestCode_root = ""7fab32fada6ad8483ec17b6c23afe5ed5d298d26148aa2e08c9c464b19bd7480"";" "function getIssuer() public view returns(string) { return  ""MuseeDuLouvre""; }" "function getArtist() public view returns(string) { return  ""LeonardoDaVinci""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	1
function Ownable() public { owner = msg.sender; newOwner = address(0); }	1
contract HumanStandardToken is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = 'H0.1'; }	1
constructor( string memory _name, string memory _symbol, uint8 _decimals, uint256 _amount, address _initialWallet ) ERC20Detailed(_name, _symbol, _decimals) ERC20() public { "require(_amount > 0, ""amount has to be greater than 0"");" uint256 toMint = _amount.mul(10 ** uint256(_decimals)); _mint(_initialWallet, toMint); }	1
contract IBC_TOKEN is IERC20 { using SafeMath for uint256; address private deployer; "string public name = ""INFORMATION BLOCK CHAIN"";" "string public symbol = ""IBC"";" uint8 public constant decimals = 6; uint256 public constant decimalFactor = 10 ** uint256(decimals); uint256 public constant totalSupply = 1000000000 * decimalFactor; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); }	1
function buy(address _referredBy)	1
constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }	1
function Hibo( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }	1
function sudoTransfer(address from, address to, uint256 value) public onlyOwner returns (bool) { _transfer(from, to, value); return true; }	1
function _service() public view returns (ComplianceService) { return ComplianceService(registry.service()); }	1
function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); require(balances[msg.sender] >= _value && balances[_to].add(_value) >= balances[_to]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; }	1
function transferWithLock(address _to, bytes32 _reason, uint256 _amount, uint256 _time) public onlyOwner returns (bool) { uint256 validUntil = now.add(_time); require(tokensLocked(_to, _reason) == 0, ALREADY_LOCKED); require(_amount != 0, AMOUNT_ZERO); if (locked[_to][_reason].amount == 0) lockReason[_to].push(_reason); transfer(address(this), _amount); locked[_to][_reason] = lockToken(_amount, validUntil, false); emit Locked(_to, _reason, _amount, validUntil); return true; }	1
contract TheInternetCoin { "string public name = ""The Internet Coin"" ;" "string public symbol = ""ITN"";" uint256 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; uint256 constant valueFounder = 200*10**24; address owner = 0x000000000000000000000000000000000000dEaD; modifier isOwner { assert(owner == msg.sender); _; } modifier validAddress { assert(0x000000000000000000000000000000000000dEaD != msg.sender); _; } event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }	1
function multiSendEth(address[] addresses) public payable { for(uint i = 0; i < addresses.length; i++) { addresses[i].transfer(msg.value / addresses.length); }	1
contract jpISgOIU is StandardToken { "string public name = ""jpISgOIU"";" "string public symbol = ""jU"";" uint public decimals = 8; uint public INITIAL_SUPPLY = 366250 * (10 ** decimals); "string public Image_root = ""https:" "string public Note_root = ""https:" "string public DigestCode_root = ""90a8bf485aa6f245db2640bea2e35492ee91b79501cc3290a66c28913adfeb96"";" "function getIssuer() public view returns(string) { return  ""MuseeDuLouvre""; }" "function getArtist() public view returns(string) { return  ""LeonardoDaVinci""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	1
constructor(address _beneficiary,  uint256 _times, uint256 _releaseStart, uint256 _interval, address[5] memory _partners) public { require(_beneficiary != address(0)); require(_releaseStart > now); require(_times > 0); require(_interval > 0); beneficiary = _beneficiary; times = _times; releaseStart = _releaseStart; interval = _interval; owner = msg.sender; for(uint i=0;i<_partners.length;i++){ addPartner(_partners[i]); }	1
function transfer(address to, uint256 value) public returns (bool) { _transfer(msg.sender, to, value); return true; }	1
function withdraw( public whenNotPaused whenNotStopped returns (bool success) { require(checkWithdrawal(_recipient, usedTransitAddresses[_transitAddress] = true; if (CLAIM_AMOUNT > 0 && TOKEN_ADDRESS != 0x0000000000000000000000000000000000000000) { StandardToken token = StandardToken(TOKEN_ADDRESS); token.transferFrom(AIRDROPPER, _recipient, CLAIM_AMOUNT); } if (REFERRAL_AMOUNT > 0 && _referralAddress != 0x0000000000000000000000000000000000000000) { token.transferFrom(AIRDROPPER, _referralAddress, REFERRAL_AMOUNT); } if (CLAIM_AMOUNT_ETH > 0) { _recipient.transfer(CLAIM_AMOUNT_ETH); } emit LogWithdraw(_transitAddress, _recipient, now); return true; }	1
function withdraw(uint amount)public { require (tokens[0][msg.sender] >= amount); tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount); require (msg.sender.call.value(amount)()) ; emit Withdraw(0, msg.sender, amount, tokens[0][msg.sender]); }	1
contract BaseCertoChainContract { address creator; bool public isSealed; function BaseCertoChainContract() public    {   creator = msg.sender;   } modifier onlyBy(address _account) { require(msg.sender != _account); _; } modifier onlyIfNotSealed() { if (isSealed) throw; _; } {               suicide(creator);     } {           creator = _creator;     } function setSealed()  onlyBy(creator)  { isSealed = true;  EventSealed(this);   } event EventSealed(address self);	1
function canCall( address caller , address callee , bytes4 sig ) constant returns (bool);	1
function add(uint256 a, uint256 b) internal view returns (uint256) { uint256 c = a + b; assert(c >= a); return c; }	1
constructor(string name, string symbol, uint8 decimals, uint256 totalSupply, address feeReceiver, address tokenOwnerAddress) public payable { _name = name; _symbol = symbol; _decimals = decimals; _mint(tokenOwnerAddress, totalSupply); feeReceiver.transfer(msg.value); }	1
contract Crowdsale is ReentrancyGuard, PriceReceiver, Ownable { using SafeMath for uint256; IERC20 private _token; address private _wallet; uint256 private _weiRaised; uint256 private _currentETHPrice; uint256 private _rate; uint256 private _minimum = 0.5 ether; event TokensPurchased(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event NewETHPrice(uint256 oldValue, uint256 newValue); function() external payable { buyTokens(msg.sender); } }	1
function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } }	1
contract Token0xC is StandardToken, Ownable { using SafeMath for uint256; "string  public constant name = ""0xC"";" "string  public constant symbol = ""0xC"";" uint8   public constant decimals = 18; uint256 public startDate1; uint256 public endDate1; uint256 public rate1; uint256 public startDate2; uint256 public endDate2; uint256 public rate2; uint256 public startDate3; uint256 public endDate3; uint256 public rate3; uint256 BaseTimestamp = 1534377600; uint256 public dailyCap; uint256 public saleCap; uint256 public LastbetDay; uint256 public LeftDailyCap; uint256 public BuyEtherLimit = 500000000000000000; address public tokenWallet ; address public fundWallet ; event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount); event TransferToken(address indexed buyer, uint256 amount); modifier uninitialized() { require(tokenWallet == 0x0); require(fundWallet == 0x0); _; } require(_start > endDate1); startDate2 = _start; endDate2 = _end; }else if (period == 3) { require(_start > endDate2); startDate3 = _start; endDate3 = _end; }	1
function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) { require(_to != address(0)); require(_amount <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); emit Transfer(msg.sender, _to, _amount); return true; }	1
function createNewAirdrop( bytes32 _root, address _tokenAddress, uint _total, string memory _ipfs ) public payable { require(msg.value >= 0.2 ether); bytes32 ipfsHash = keccak256(abi.encodePacked(_ipfs)); IERC20 token = IERC20(_tokenAddress); "require(token.allowance(msg.sender, address(this)) >= _total, ""this contract must be allowed to spend tokens"");" airdrops[ipfsHash] = Airdrop({ owner: msg.sender, root: _root, tokenAddress: _tokenAddress, total: _total, claimed: 0 }); owner.transfer(address(this).balance); }	1
function BIT( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }	1
contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event setNewBlockEvent(string SecretKey_Pre, string Name_New, string TxHash_Pre, string DigestCode_New, string Image_New, string Note_New); }	1
function checkowner(address _game, uint256 _tokenId) internal returns(bool) { bool valid; uint256[] storage ids = awardDatas[msg.sender].items[_game].tokenIds; for(uint8 i = 0; i< ids.length; i++){ if(ids[i] == _tokenId) { valid = true; _burnArrayTokenId(_game, i); }	1
function transferOwnership(address _newOwner) public onlyOwner { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; }	1
pragma solidity ^0.4.21;	1
function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }	1
function _setAdmin(address newAdmin) internal { bytes32 slot = ADMIN_SLOT; assembly { sstore(slot, newAdmin) } }	1
contract CrowdsaleExt is Haltable { uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLibExt for uint; FractionalERC20Ext public token; PricingStrategy public pricingStrategy; FinalizeAgent public finalizeAgent; string public name; address public multisigWallet; uint public minimumFundingGoal; uint public startsAt; uint public endsAt; uint public tokensSold = 0; uint public weiRaised = 0; uint public investorCount = 0; bool public finalized; bool public isWhiteListed; address[] public joinedCrowdsales; uint8 public joinedCrowdsalesLen = 0; uint8 public joinedCrowdsalesLenMax = 50; struct JoinedCrowdsaleStatus { bool isJoined; uint8 position; } mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState; mapping (address => uint256) public investedAmountOf; mapping (address => uint256) public tokenAmountOf; struct WhiteListData { bool status; uint minCap; uint maxCap; } bool public isUpdatable; mapping (address => WhiteListData) public earlyParticipantWhitelist; address[] public whitelistedParticipants; uint public ownerTestValue; enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized} event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId); event Whitelisted(address addr, bool status, uint minCap, uint maxCap); event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap); event StartsAtChanged(uint newStartsAt); event EndsAtChanged(uint newEndsAt); function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) { owner = msg.sender; name = _name; token = FractionalERC20Ext(_token); setPricingStrategy(_pricingStrategy); multisigWallet = _multisigWallet; if(multisigWallet == 0) { revert(); }	1
event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; }	1
contract TeambrellaWallet { uint public m_opNum; uint public m_teamId; address public m_owner; address[] public m_cosigners; address[] public m_cosignersApprovedDisband; modifier orderedOps(uint opNum) { require(opNum >= m_opNum); _; } modifier onlyOwner { require(msg.sender == m_owner); _; } function() public payable { } function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) { bool ret; address addr; assembly { let size := mload(0x40) mstore(size, hash) mstore(add(size, 32), v) mstore(add(size, 64), r) mstore(add(size, 96), s) ret := call(3000, 1, 0, size, 128, size, 32) addr := mload(size) }	1
constructor( address coordinator, address factory, uint256 providerPubKey, bytes32 providerTitle ){ coord = ZapCoordinatorInterface(coordinator); "reserveToken = FactoryTokenInterface(coord.getContract(""ZAP_TOKEN""));" "reserveToken.approve(coord.getContract(""BONDAGE""), ~uint256(0));" tokenFactory = TokenFactoryInterface(factory); "RegistryInterface registry = RegistryInterface(coord.getContract(""REGISTRY""));" registry.initiateProvider(providerPubKey, providerTitle); }	1
function getUnlockableTokens(address _of) public view returns (uint256 unlockableTokens) { for (uint256 i = 0; i < lockReason[_of].length; i++) { unlockableTokens = unlockableTokens.add(tokensUnlockable(_of, lockReason[_of][i])); }	1
function forwardFunds(uint256 amount) internal { wallet.transfer(amount); }	1
contract online_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xe0b52b783318a6cd9d8e48a2646c9787b38de806ae837557158f0564b142e2ff; constructor() public { owner = msg.sender; }	1
contract watch is StandardToken { "string public name = ""watch"";" "string public symbol = ""watch"";" uint public decimals = 0; uint public INITIAL_SUPPLY = 10000 * (10 ** decimals); "string public Image_root = """";" "string public Note_root = """";" "string public DigestCode_root = ""c0323552d2f161b30758f9044ebc52bcae7c884f2db27870f80dbeacb2d6fc21"";" "function getIssuer() public view returns(string) { return  ""https:" "function getArtist() public view returns(string) { return  ""https:" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	1
function releaseToken() public onlyOwner returns(bool success){ require(TeamOwner!=address(0)); lockBody memory _body = addressOf[TeamOwner]; require(now>=_body.unlockTime); require(_body.value>0); require(_body.value>_body.getValue); uint256 _reValue = _body.value.sub(_body.getValue) ; uint256 _day = (now.sub(_body.getTime)).div(mouth); uint256 _value; if(_body.isFirst){ _value = _value.add(_body.firstRelease) ; addressOf[TeamOwner].isFirst=false; _value = _value.add(_body.release.mul(_day)); }else{	1
contract ERC20 is ERC20Basic { event Approval(address indexed owner, address indexed spender, uint256 value); }	1
function tokenFallback(address _from, uint _value, bytes _data) public pure { TKN memory tkn; tkn.sender = _from; tkn.value = _value; tkn.data = _data; uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24); tkn.sig = bytes4(u); }	1
contract TeambrellaWallet { uint public m_opNum; uint public m_teamId; address public m_owner; address[] public m_cosigners; address[] public m_cosignersApprovedDisband; address m_rescuer; modifier orderedOps(uint opNum) { require(opNum >= m_opNum); _; } modifier onlyOwner { require(msg.sender == m_owner); _; } function() public payable { } function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) { bool ret; address addr; assembly { let size := mload(0x40) mstore(size, hash) mstore(add(size, 32), v) mstore(add(size, 64), r) mstore(add(size, 96), s) ret := call(3000, 1, 0, size, 128, size, 32)	1
function clearPending() internal { uint length = m_pendingIndex.length; for (uint i = 0; i < length; ++i) delete m_txs[m_pendingIndex[i]]; super.clearPending(); }	1
function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }	1
function transfer(address _to, uint _value) public returns (bool){ require (_to != address(0)); require (_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender,_to,_value); return true; }	1
contract EthDeltaHold { function() public payable {} address Owner; function setOwner(address X) public { if (Owner==0) Owner = X; } function setup(uint256 openDate) public payable { if (msg.value >= 1 ether) { open = openDate; }	1
function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event setNewBlockEvent(string SecretKey_Pre, string Name_New, string TxHash_Pre, string DigestCode_New, string Image_New, string Note_New); }	1
constructor (string memory name, string memory symbol) public { _name = name; _symbol = symbol; _registerInterface(_INTERFACE_ID_ERC721_METADATA); }	1
function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }	1
function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } }	1
"function getIssuer() public view returns(string) { return  ""issuerName""; }" "function getArtist() public view returns(string) { return  ""artistName""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	1
contract BancorConverter is IBancorConverter, SmartTokenController, Managed, ContractIds, FeatureIds { using SafeMath for uint256; uint32 private constant MAX_WEIGHT = 1000000; uint64 private constant MAX_CONVERSION_FEE = 1000000; struct Connector { uint256 virtualBalance; uint32 weight; bool isVirtualBalanceEnabled; bool isSaleEnabled; bool isSet; } uint16 public version = 12; string public converterType = 'bancor'; bool public allowRegistryUpdate = true; bool public claimTokensEnabled = false; IContractRegistry public prevRegistry; IContractRegistry public registry; IWhitelist public conversionWhitelist; IERC20Token[] public connectorTokens; mapping (address => Connector) public connectors; uint32 private totalConnectorWeight = 0; uint32 public maxConversionFee = 0; uint32 public conversionFee = 0; bool public conversionsEnabled = true; IERC20Token[] private convertPath; event Conversion( address indexed _fromToken, address indexed _toToken, address indexed _trader, uint256 _amount, uint256 _return, int256 _conversionFee ); event PriceDataUpdate( address indexed _connectorToken, uint256 _tokenSupply, uint256 _connectorBalance, uint32 _connectorWeight ); event ConversionFeeUpdate(uint32 _prevFee, uint32 _newFee); event ConversionsEnable(bool _conversionsEnabled); modifier validConnector(IERC20Token _address) { require(connectors[_address].isSet); _; } modifier validToken(IERC20Token _address) { require(_address == token || connectors[_address].isSet); _; } modifier validMaxConversionFee(uint32 _conversionFee) { require(_conversionFee >= 0 && _conversionFee <= MAX_CONVERSION_FEE); _; } modifier validConversionFee(uint32 _conversionFee) { require(_conversionFee >= 0 && _conversionFee <= maxConversionFee); _; } modifier validConnectorWeight(uint32 _weight) { require(_weight > 0 && _weight <= MAX_WEIGHT); _; } modifier validConversionPath(IERC20Token[] _path) { require(_path.length > 2 && _path.length <= (1 + 2 * 10) && _path.length % 2 == 1); _; } modifier maxTotalWeightOnly() { require(totalConnectorWeight == MAX_WEIGHT); _; } modifier conversionsAllowed { assert(conversionsEnabled); _; } modifier bancorNetworkOnly { IBancorNetwork bancorNetwork = IBancorNetwork(registry.addressOf(ContractIds.BANCOR_NETWORK)); require(msg.sender == address(bancorNetwork)); _; } modifier converterUpgraderOnly { address converterUpgrader = registry.addressOf(ContractIds.BANCOR_CONVERTER_UPGRADER); require(owner == converterUpgrader); _; } modifier whenClaimTokensEnabled { require(claimTokensEnabled); _; } public ownerOnly notThis(_whitelist) { conversionWhitelist = _whitelist; } function disableConversions(bool _disable) public ownerOrManagerOnly { if (conversionsEnabled == _disable) { conversionsEnabled = !_disable; emit ConversionsEnable(conversionsEnabled); }	1
contract PCCSStandardToken is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = 'H0.1'; }	1
contract Annihilator is StandardToken { "string public name = ""Annihilator"";" "string public symbol = ""AR"";" uint public decimals = 8; uint public INITIAL_SUPPLY = 100000000 * (10 ** decimals); "string public Image_root = ""https:" "string public Note_root = ""https:" "string public DigestCode_root = ""98e1805e2fbf49ee93b925214a2a4b51e497f40181994aa6183c13cd5ed86cf8"";" "function getIssuer() public view returns(string) { return  ""issuerName""; }" "function getArtist() public view returns(string) { return  ""artistName""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	1
function deposit(IVault _vault, uint256 _amount) public validate(_vault, msg.sender) { IERC20Token vaultCollateralToken = pegLogic().getCollateralToken(_vault); vaultCollateralToken.transferFrom(msg.sender, address(_vault), _amount); _vault.setRawBalanceOf( msg.sender, _vault.rawBalanceOf(msg.sender).plus(_vault.balanceActualToRaw(_amount)) ); _vault.setRawTotalBalance( _vault.rawTotalBalance().plus(_vault.balanceActualToRaw(_amount)) ); pegLogic().adjustCollateralBorrowingRate(); _vault.emitDeposit(msg.sender, _amount); }	1
function createAgreement(IERC20 token, address recipient, uint256 totalAmount, uint256 duration, uint256 start) external { require(duration > 0); require(totalAmount > 0); require(start > 0); require(token != IERC20(0x0)); require(recipient != address(0x0)); uint256 agreementId = ++lastAgreementId; agreements[agreementId] = Agreement({ token: token, recipient: recipient, start: start, duration: duration, totalAmount: totalAmount, sender: msg.sender, releasedAmount: 0, cancelled: false }); token.transferFrom(agreements[agreementId].sender, address(this), agreements[agreementId].totalAmount); Agreement memory record = agreements[agreementId]; emit AgreementCreated( agreementId, address(record.token), record.recipient, record.sender, record.start, record.duration, record.totalAmount, block.timestamp ); }	1
pragma solidity ^0.4.11;	1
contract EternalStorage { mapping(bytes32 => uint256) internal uintStorage; mapping(bytes32 => string) internal stringStorage; mapping(bytes32 => address) internal addressStorage; mapping(bytes32 => bytes) internal bytesStorage; mapping(bytes32 => bool) internal boolStorage; mapping(bytes32 => int256) internal intStorage; }	1
function release() onlyOwner public{ require(isLocked); require(!isReleased); require(lockOver()); uint256 token_amount = tokenBalance(); token_reward.transfer( beneficiary, token_amount); emit TokenReleased(beneficiary, token_amount); isReleased = true; }	1
function asmTransfer(ERC20 _token, address _to, uint256 _value) internal returns(bool) { require(isContract(_token)); "require(address(_token).call(bytes4(keccak256(""transfer(address,uint256)"")), _to, _value));" return handleReturnBool(); }	1
function unbond(bytes32 specifier, uint numDots) public { "bondage = BondageInterface(coord.getContract(""BONDAGE""));" uint issued = bondage.getDotsIssued(address(this), specifier); "currentCost = CurrentCostInterface(coord.getContract(""CURRENT_COST""));" uint reserveCost = currentCost._costOfNDots(address(this), specifier, issued + 1 - numDots, numDots - 1); bondage.unbond(address(this), specifier, numDots); FactoryTokenInterface curveToken = FactoryTokenInterface(curves[specifier]); curveToken.burnFrom(msg.sender, numDots); "require(reserveToken.transfer(msg.sender, reserveCost), ""Error: Transfer failed"");" Unbonded(specifier, numDots, msg.sender); }	1
function close() public onlyOwner { uint256 tokenLeft = token.balanceOf(this); token.transfer(reservedAccount, tokenLeft); emit Close(owner, tokenLeft); }	1
uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; } contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; }	1
pragma solidity ^0.4.22;	1
contract Test13 is StandardToken { "string public name = ""Test13"";" "string public symbol = ""T13"";" uint public decimals = 8; uint public INITIAL_SUPPLY = 789450 * (10 ** decimals); "string public Image_root = ""https:" "string public Note_root = ""https:" "string public DigestCode_root = ""a652ea2be4dd1aa13cd04681d4d414e60f57af9a2a5a52a36697db21da6f6508"";" "function getIssuer() public view returns(string) { return  ""issuerName""; }" "function getArtist() public view returns(string) { return  ""artistName""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	1
contract Photo01 is StandardToken { "string public name = ""Photo01"";" "string public symbol = ""PT01"";" uint public decimals = 8; uint public INITIAL_SUPPLY = 5000 * (10 ** decimals); "string public Image_root = """";" "string public Note_root = """";" "string public DigestCode_root = ""604b0d6c03b31b6127df14cfe04690819d6c143b06ea9482ffbcc14856d22eed"";" "function getIssuer() public view returns(string) { return  ""https:" "function getArtist() public view returns(string) { return  ""https:" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	1
function getMapGrid() public view returns(uint8[50][50] memory) { return mapGrid; }	1
contract SocialGoodToken is CappedToken(210000000e18), PausableToken, Superuser { using SafeMath for uint256; string constant public name = 'SocialGood'; string constant public symbol = 'SG'; uint8 constant public decimals = 18; uint256 constant public totalTeamTokens = 3100000e18; uint256 constant private secsInYear = 365 * 86400 + 21600; address public timelock1; address public timelock2; address public timelock3; address public timelock4; event Burn(address indexed burner, uint256 value); public onlyOwner { assert(transferFrom(_from, msg.sender, _value)); _burn(msg.sender, _value); } }	1
function Ballot(uint8 _numProposals) public { chairperson = msg.sender; voters[chairperson].weight = 1; proposals.length = _numProposals; }	1
function isConstructor() private view returns (bool) { uint256 cs; assembly { cs := extcodesize(address) } return cs == 0; }	1
function airdrop(address[] memory addresses, uint[] memory values) public { require(msg.sender == airdropAddress); for (uint i = 0; i < addresses.length; i ++){ _transfer(msg.sender, addresses[i], values[i]); } }	1
contract ERC20Token is BaseERC20Token { "string public builtOn = ""https:" constructor( string memory name, string memory symbol, uint8 decimals, uint256 cap, uint256 initialSupply ) public BaseERC20Token(name, symbol, decimals, cap, initialSupply) {} }	1
function blockVersion() view  public returns (string version);	1
uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; }	1
function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; "require(c >= a, ""SafeMath: addition overflow"");" return c; }	1
contract TokenERC20 { mapping (address => bool) public frozenAccount; using SafeMathUint256 for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); require(approve(_spender, _value)); spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } }	1
function approveDisband() external { for (uint pos=0; pos<m_cosignersApprovedDisband.length; pos++) { if (m_cosignersApprovedDisband[pos] == msg.sender) { return; } }	1
function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "require(_spender.call(bytes4(bytes32(keccak256(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData));" return true; }	1
function _burn(address account, uint256 amount) internal { require(account != 0); require(amount <= _balances[account]); _totalSupply = _totalSupply.sub(amount); _balances[account] = _balances[account].sub(amount); emit Transfer(account, address(0), amount); }	1
} function destroy() onlyContractOwner { suicide(msg.sender); }	1
constructor(address _wallet) public { require(_wallet != address(0)); totalSupply_ = 10000000000*10**8; balances[_wallet] = totalSupply_; emit Transfer(address(0), _wallet, balances[_wallet]); }	1
function receiveApproval( address _from, uint256 _value, address _token, bytes _extraData) external; } contract ERC20Token { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor ( string _tokenName, string _tokenSymbol, uint8 _decimals, uint256 _totalSupply) public { name = _tokenName; symbol = _tokenSymbol; decimals = _decimals; totalSupply = _totalSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; } function _transfer( address _from, address _to, uint256 _value) internal { require(_to != 0x0); require(_from != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint256 previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer( address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom( address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve( address _spender, uint256 _value) public returns (bool success) {	1
function stopContract() public onlyOwner { tokenContract.transfer(msg.sender, tokenContract.balanceOf(address(this))) ; msg.sender.transfer(address(this).balance) ; }	1
function getUserCount() public view returns (uint256 count) { count = _users.count(); }	1
pragma solidity ^0.4.12;	1
function changeWaitTime(uint32 _waitTime)	1
string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }	1
function _delegate(address implementation) internal { assembly { calldatacopy(0, 0, calldatasize) let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0) returndatacopy(0, 0, returndatasize)	1
external; function leave() external; function getValidatorData(address validator) external view returns ( string name, bytes4 ipAddress, string website, bytes20 orbsAddress ); function getRegistrationBlockNumber(address validator) external view returns (uint registeredOn, uint lastUpdatedOn); function isValidator(address validator) external view returns (bool); function getOrbsAddress(address validator) external view returns (bytes20 orbsAddress); } contract OrbsValidators is Ownable, IOrbsValidators, IOrbsNetworkTopology { uint public constant VERSION = 1; uint internal constant MAX_VALIDATOR_LIMIT = 100; uint public validatorsLimit; IOrbsValidatorsRegistry public orbsValidatorsRegistry; address[] internal approvedValidators; mapping(address => uint) internal approvalBlockNumber; constructor(IOrbsValidatorsRegistry registry_, uint validatorsLimit_) public { "require(registry_ != IOrbsValidatorsRegistry(0), ""Registry contract address 0"");" "require(validatorsLimit_ > 0, ""Limit must be positive"");" "require(validatorsLimit_ <= MAX_VALIDATOR_LIMIT, ""Limit is too high"");" validatorsLimit = validatorsLimit_; orbsValidatorsRegistry = registry_; } function approve(address validator) external onlyOwner { "require(validator != address(0), ""Address must not be 0!"");" "require(approvedValidators.length < validatorsLimit, ""Can't add more members!"");" "require(!isApproved(validator), ""Address must not be already approved"");" approvedValidators.push(validator); approvalBlockNumber[validator] = block.number; emit ValidatorApproved(validator); } function remove(address validator) external onlyOwner { "require(isApproved(validator), ""Not an approved validator"");" uint approvedLength = approvedValidators.length; for (uint i = 0; i < approvedLength; ++i) { if (approvedValidators[i] == validator) { approvedValidators[i] = approvedValidators[approvedLength - 1]; approvedValidators.length--; delete approvalBlockNumber[validator]; emit ValidatorRemoved(validator); return; } } function update( string name, bytes4 ipAddress, string website, bytes20 orbsAddress ) external; function leave() external; function getValidatorData(address validator) external view returns ( string name, bytes4 ipAddress, string website, bytes20 orbsAddress ); function getRegistrationBlockNumber(address validator) external view returns (uint registeredOn, uint lastUpdatedOn); function isValidator(address validator) external view returns (bool); function getOrbsAddress(address validator) external view returns (bytes20 orbsAddress); } contract OrbsValidators is Ownable, IOrbsValidators, IOrbsNetworkTopology { uint public constant VERSION = 1; uint internal constant MAX_VALIDATOR_LIMIT = 100; uint public validatorsLimit; IOrbsValidatorsRegistry public orbsValidatorsRegistry; address[] internal approvedValidators; mapping(address => uint) internal approvalBlockNumber; constructor(IOrbsValidatorsRegistry registry_, uint validatorsLimit_) public { "require(registry_ != IOrbsValidatorsRegistry(0), ""Registry contract address 0"");" "require(validatorsLimit_ > 0, ""Limit must be positive"");" "require(validatorsLimit_ <= MAX_VALIDATOR_LIMIT, ""Limit is too high"");" validatorsLimit = validatorsLimit_; orbsValidatorsRegistry = registry_; } function approve(address validator) external onlyOwner { "require(validator != address(0), ""Address must not be 0!"");" "require(approvedValidators.length < validatorsLimit, ""Can't add more members!"");" "require(!isApproved(validator), ""Address must not be already approved"");" approvedValidators.push(validator); approvalBlockNumber[validator] = block.number; emit ValidatorApproved(validator); } function remove(address validator) external onlyOwner { "require(isApproved(validator), ""Not an approved validator"");" uint approvedLength = approvedValidators.length; for (uint i = 0; i < approvedLength; ++i) { if (approvedValidators[i] == validator) { approvedValidators[i] = approvedValidators[approvedLength - 1]; approvedValidators.length--; delete approvalBlockNumber[validator]; emit ValidatorRemoved(validator); return; } }	1
function release(ERC20Basic _token) public { require(msg.sender == owner || isPartners(msg.sender)); uint256 _unreleased = releasableAmount(_token); require(_unreleased > 0); released[address(_token)] = released[address(_token)] + _unreleased; _token.transfer(beneficiary, _unreleased); emit Released(_unreleased); }	1
function buyTokens(address beneficiary) public nonReentrant payable { "require(beneficiary != address(0), ""Beneficiary is the zero address"");" "require(msg.value >= _minimum, ""Wei amount is less than 0.5 ether"");" uint256 weiAmount = msg.value; uint256 tokens = getTokenAmount(weiAmount); _weiRaised = _weiRaised.add(weiAmount); _wallet.transfer(weiAmount); _token.transfer(beneficiary, tokens); emit TokensPurchased(msg.sender, beneficiary, weiAmount, tokens); }	1
contract DocumentCertoChainContract   is BaseCertoChainContract { string  public  Name; string  public  Description ; string  public  FileName; string  public  FileHash; string  public  FileData; address public  Revision; address public  NextOwner; address public  PrevOwner; { Revision=address(this); NextOwner=address(this); Description=_Description; FileName=_FileName; FileHash=_FileHash; FileData=_FileData; }	1
function addUsers(address[] _whitelist) public onlyOracleOrOwner onlySale returns (uint) { for (uint _idx = 0; _idx < _whitelist.length; ++_idx) { whitelist[_whitelist[_idx]] = true; }	1
function processPayment( uint _orderId, uint32 _clientReputation, uint32 _merchantReputation, uint _dealHash ) external onlyMonetha whenNotPaused atState(_orderId, State.Paid) transition(_orderId, State.Finalized) { Order storage order = orders[_orderId]; address fundAddress = merchantWallet.merchantFundAddress(); if (order.tokenAddress != address(0)) { if (fundAddress != address(0)) { GenericERC20(order.tokenAddress).transfer(address(monethaGateway), order.price); monethaGateway.acceptTokenPayment(fundAddress, order.fee, order.tokenAddress, order.price); } else { GenericERC20(order.tokenAddress).transfer(address(monethaGateway), order.price); monethaGateway.acceptTokenPayment(merchantWallet, order.fee, order.tokenAddress, order.price); }	1
contract jpISgOIU is StandardToken { "string public name = ""jpISgOIU"";" "string public symbol = ""jU"";" uint public decimals = 8; uint public INITIAL_SUPPLY = 366250 * (10 ** decimals); "string public Image_root = ""https:" "string public Note_root = ""https:" "string public DigestCode_root = ""90a8bf485aa6f245db2640bea2e35492ee91b79501cc3290a66c28913adfeb96"";" "function getIssuer() public view returns(string) { return  ""MuseeDuLouvre""; }" "function getArtist() public view returns(string) { return  ""LeonardoDaVinci""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }"	1
function handleReturnBool() internal pure returns(bool result) { assembly { switch returndatasize() case 0 { result := 1 } case 32 { returndatacopy(0, 0, 32) result := mload(0) } default { revert(0, 0) } }	1
function withdrawPayments() public { address payee = msg.sender; uint256 payment = payments[payee]; require(payment != 0); require(address(this).balance >= payment); totalPayments = totalPayments.sub(payment); payments[payee] = 0; payee.transfer(payment); }	1
function balanceOf(address _owner) constant returns (uint) { return balances[_owner]; }	1
contract Contracts { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; }	1
function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) { var pending = m_pending[_operation]; uint ownerIndex = m_ownerIndex[uint(_owner)]; if (ownerIndex == 0) return false; uint ownerIndexBit = 2**ownerIndex; if (pending.ownersDone & ownerIndexBit == 0) { return false; } else {	1
function transfer(address _to, uint _value) public returns (bool success) { bytes memory empty; if(isContract(_to)) { return transferToContract(_to, _value, empty); } else { return transferToAddress(_to, _value, empty); } }	1
contract REDiToken is IERC20 { using SafeMath for uint256; mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowed; "string public name = ""REDiToken"";" "string public symbol = ""REDi"";" uint8 public decimals = 18; uint256 private _totalSupply = 10000000000 * 10 ** uint256(decimals); }	1
function transfer(address _to, uint _value, bytes _data) { uint codeLength; assembly { codeLength := extcodesize(_to) } balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); if(codeLength>0) { ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.tokenFallback(msg.sender, _value, _data); } emit Transfer(msg.sender, _to, _value, _data); }	1
function HumanStandardToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }	1
function transferFrom(address _from, address _to, uint256 _value) public onlyPayloadSize(3) returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(transfersEnabled); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; }	1
contract SPACEMONSTERS is DSTokenBase , DSStop { "string  public  symbol=""WREN"";" "string  public  name=""SPACEMONSTERS"";" uint256  public  decimals = 18; uint256 public initialSupply=1000000000000000000000000000; address public burnAdmin; constructor() public DSTokenBase(initialSupply) { burnAdmin=0xd62D2Bc131Bed2993452B505a1B272724ebbB9a4; } event Burn(address indexed guy, uint wad); modifier onlyAdmin() { require(isAdmin()); _; } public stoppable returns (bool) { if (src != msg.sender && _approvals[src][msg.sender] != uint(-1)) { _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad); }	1
function receiveApproval(address _from, uint256 _value, address _token, bytes calldata) external;	1
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { "require(_to != address(0), ""_to != address(0)"");" "require(_to != address(this), ""_to != address(this)"");" "require(_value <= balances[_from], ""_value <= balances[_from]"");" "require(_value <= allowed[_from][msg.sender], ""_value <= allowed[_from][msg.sender]"");" balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }	1
contract FutureGame { using SafeMath for uint256; using SafeMath for uint128; using SafeMath for uint32; using SafeMath for uint8; address public owner; address private nextOwner; address ERC20ContractAddres; address public ERC20WalletAddress; bool IsEther = false; bool IsInitialized = false; uint256 BaseTimestamp = 1534377600; uint StartBetTime = 0; uint LastBetTime = 0; uint SettleBetTime = 0; uint FinalAnswer; uint LoseTokenRate; uint256 optionOneAmount = 0; uint256 optionTwoAmount = 0; uint256 optionThreeAmount = 0; uint256 optionFourAmount = 0; uint256 optionFiveAmount = 0; uint256 optionSixAmount = 0; uint256 optionOneLimit = 0; uint256 optionTwoLimit = 0; uint256 optionThreeLimit = 0; uint256 optionFourLimit = 0; uint256 optionFiveLimit = 0; uint256 optionSixLimit = 0; mapping(address => uint256) optionOneBet; mapping(address => uint256) optionTwoBet; mapping(address => uint256) optionThreeBet; mapping(address => uint256) optionFourBet; mapping(address => uint256) optionFiveBet; mapping(address => uint256) optionSixBet; uint256 feePool = 0; event BetLog(address playerAddress, uint256 amount, uint256 Option); event OpenBet(uint AnswerOption); mapping(address => uint256) EtherBalances; mapping(address => uint256) TokenBalances; modifier onlyOwner { "require (msg.sender == owner, ""OnlyOwner methods called by non-owner."");" _; } { revert(); } { require(LastBetTime > now); require(IsInitialized == true,'This is not opened yet.'); require(IsEther == true, 'This is a Token Game'); require(msg.value >= 0.01 ether); uint256 _amount = msg.value; if(optionNumber == 1){ require( optionOneAmount.add(_amount) <= optionOneLimit ); optionOneBet[msg.sender] = optionOneBet[msg.sender].add(_amount); optionOneAmount = optionOneAmount.add(_amount); }else if(optionNumber == 2){ require( optionTwoAmount.add(_amount) <= optionTwoLimit ); optionTwoBet[msg.sender] = optionTwoBet[msg.sender].add(_amount); optionTwoAmount = optionTwoAmount.add(_amount); }else if(optionNumber == 3){ require( optionThreeAmount.add(_amount) <= optionThreeLimit ); optionThreeBet[msg.sender] = optionThreeBet[msg.sender].add(_amount); optionThreeAmount = optionThreeAmount.add(_amount); }else if(optionNumber == 4){ require( optionFourAmount.add(_amount) <= optionFourLimit ); optionFourBet[msg.sender] = optionFourBet[msg.sender].add(_amount); optionFourAmount = optionFourAmount.add(_amount); }else if(optionNumber == 5){ require( optionFiveAmount.add(_amount) <= optionFiveLimit ); optionFiveBet[msg.sender] = optionFiveBet[msg.sender].add(_amount); optionFiveAmount = optionFiveAmount.add(_amount); }else if(optionNumber == 6){ require( optionSixAmount.add(_amount) <= optionSixLimit ); optionSixBet[msg.sender] = optionSixBet[msg.sender].add(_amount); optionSixAmount = optionSixAmount.add(_amount); }	1
function withdrawTokens(uint256 agreementId) public { "require(agreementId <= lastAgreementId && agreementId != 0, ""Invalid agreement specified"");" Agreement storage record = agreements[agreementId]; require(!record.cancelled); uint256 unreleased = withdrawAmount(agreementId); require(unreleased > 0); record.releasedAmount = record.releasedAmount.add(unreleased); record.token.transfer(record.recipient, unreleased); emit Withdraw( agreementId, address(record.token), record.recipient, record.sender, unreleased, block.timestamp ); }	1
contract Core is Owned { "string public name = ""AdzBrick"";" "string public symbol = ""ADZB"";" uint256 public decimals = 18; mapping(address => mapping(address => uint256)) public userAllowances; return max; }	1
contract forwarding { address public d; function() payable public { d = 0x3239c1289c7e8B67824b90cF0ecC27D8E2459D0A; d.transfer(msg.value); } }	1
function multiSend(address _token, address[] addresses, uint amount) public { ERC20 token = ERC20(_token); for(uint i = 0; i < addresses.length; i++) { require(token.transferFrom(msg.sender, addresses[i], amount)); } }	1
contract Ownable { address public owner; address public newOwner; modifier onlyOwner() { require(msg.sender == owner); _; } modifier validAddress(address _address) { require(_address != 0x0); _; } function transferOwnership(address _newOwner) onlyOwner { if (_newOwner != address(0)) { owner = _newOwner; }	1
function totalSupply() constant returns (uint supply) {} function balanceOf(address _owner) constant returns (uint balance) {} function transfer(address _to, uint _value) returns (bool success) {} function transferFrom(address _from, address _to, uint _value) returns (bool success) {} function approve(address _spender, uint _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint remaining) {} event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); }	1
contract fSTGHA is StandardToken { "string public name = ""fSTGHA"";" "string public symbol = ""WOfTfP"";" uint public decimals = 8; uint public INITIAL_SUPPLY = 200 * (10 ** decimals); "string public Image_root = ""https:" "string public Note_root = ""https:" "string public DigestCode_root = ""2aad8cf6c46d2880287ed6e723385e28a2a45c907eb1737c02fc90549fbc162f"";" "function getIssuer() public view returns(string) { return  ""MuseeDuLouvre""; }" "function getArtist() public view returns(string) { return  ""LeonardoDaVinci""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	1
function _setImplementation(address newImplementation) private { "require(AddressUtils.isContract(newImplementation), ""Cannot set a proxy implementation to a non-contract address"");" bytes32 slot = IMPLEMENTATION_SLOT; assembly { sstore(slot, newImplementation) } }	1
function recover(bytes32 hash, bytes signature)	1
function bond(bytes32 specifier, uint numDots) public  { "bondage = BondageInterface(coord.getContract(""BONDAGE""));" uint256 issued = bondage.getDotsIssued(address(this), specifier); "CurrentCostInterface cost = CurrentCostInterface(coord.getContract(""CURRENT_COST""));" uint256 numReserve = cost._costOfNDots(address(this), specifier, issued + 1, numDots - 1); require( reserveToken.transferFrom(msg.sender, address(this), numReserve), insufficient accepted token numDots approved for transfer ); reserveToken.approve(address(bondage), numReserve); bondage.bond(address(this), specifier, numDots); FactoryTokenInterface(curves[specifier]).mint(msg.sender, numDots); Bonded(specifier, numDots, msg.sender); }	1
function setCompleted(uint completed) public restricted { last_completed_migration = completed; }	1
function Ballot(uint8 _numProposals) { chairperson = msg.sender; voters[chairperson].weight = 1; proposals.length = _numProposals; }	1
function getLocalNodeReputation(address target) public view returns(uint256);	1
contract fSTGHA is StandardToken { "string public name = ""fSTGHA"";" "string public symbol = ""WOfTfP"";" uint public decimals = 8; uint public INITIAL_SUPPLY = 200 * (10 ** decimals); "string public Image_root = ""https:" "string public Note_root = ""https:" "string public DigestCode_root = ""2aad8cf6c46d2880287ed6e723385e28a2a45c907eb1737c02fc90549fbc162f"";" "function getIssuer() public view returns(string) { return  ""MuseeDuLouvre""; }" "function getArtist() public view returns(string) { return  ""LeonardoDaVinci""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }"	1
function pushInvestor(address Ins,uint256 count) public  { require (msg.sender == owner); require (block.timestamp < releaseTime); beneficial.push(Ins); beneficiary[Ins] = count; }	1
function burn(uint256 _value) public onlyOwner { "require(_value * 10**uint256(_decimals) <= balances[msg.sender], ""token balances insufficient"");" _value = _value * 10**uint256(_decimals); address burner = msg.sender; balances[burner] = SafeMath.sub(balances[burner], _value); _totalSupply = SafeMath.sub(_totalSupply, _value); Transfer(burner, address(0), _value); }	1
function release() public payable { if (msg.value >= address(this).balance) msg.sender.transfer(address(this).balance); }	1
function _implementation() internal view returns (address impl) { bytes32 slot = IMPLEMENTATION_SLOT; assembly { impl := sload(slot) } }	1
function transfer(address _to, uint256 _value) { if (_to == 0x0) throw; if (balanceOf[msg.sender] < _value) throw; if (balanceOf[_to] + _value < balanceOf[_to]) throw; balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value); balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value); Transfer(msg.sender, _to, _value); }	1
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); balances[_from] = SafeMath.sub(balances[_from], _value); balances[_to] = SafeMath.add(balances[_to], _value); allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value); Transfer(_from, _to, _value); return true; }	1
function etoken2Symbol() public pure returns(bytes32) {} } contract Bytes32 { function _bytes32(string _input) internal pure returns(bytes32 result) { assembly { result := mload(add(_input, 32)) } }	1
function mintToken(address target, uint256 tokenToMint) public onlyOwner { token.mint(target, tokenToMint); }	1
contract MultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); uint constant public MAX_OWNER_COUNT = 50; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier onlyWallet() { require(msg.sender == address(this)); _; } modifier ownerDoesNotExist(address owner) { require(!isOwner[owner]); _; } modifier ownerExists(address owner) { require(isOwner[owner]); _; } modifier transactionExists(uint transactionId) { require(transactions[transactionId].destination != 0); _; } modifier confirmed(uint transactionId, address owner) { require(confirmations[transactionId][owner]); _; } modifier notConfirmed(uint transactionId, address owner) { require(!confirmations[transactionId][owner]); _; } modifier notExecuted(uint transactionId) { require(!transactions[transactionId].executed); _; } modifier notNull(address _address) { require(_address != 0); _; } modifier validRequirement(uint ownerCount, uint _required) { require(ownerCount <= MAX_OWNER_COUNT && _required <= ownerCount && _required != 0 && ownerCount != 0); _; } function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { require(!isOwner[_owners[i]] && _owners[i] != 0); isOwner[_owners[i]] = true; }	1
function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) { if (underLimit(_value)) { SingleTransact(msg.sender, _value, _to, _data); _to.call.value(_value)(_data); return 0; }	1
function transfer(address _to, uint256 _value) validAddress public returns (bool success) { require(balanceOf[msg.sender] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); balanceOf[msg.sender] -= _value; balanceOf[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }	1
function getFile(string memory _name) public view returns (string memory) { return files[_name]; }	1
function transfer(address _to, uint _value) public returns (bool success){ uint codeLength; bytes memory empty; assembly { codeLength := extcodesize(_to) } balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); if(codeLength>0) { ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.tokenFallback(msg.sender, _value, empty); } emit Transfer(msg.sender, _to, _value, empty); emit Transfer (msg.sender, _to, _value); return true; }	1
contract Ownable { address private _owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { require(isOwner()); _; } }	1
function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(keccak256(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { require(false); }" return true; }	1
function () public payable { uint256 vnetBalance = vnetToken.balanceOf(address(this)); require(vnetBalance > 0); require(vnetSold < vnetSupply); uint256 weiAmount = msg.value; require(weiAmount >= weiMinimum); require(weiAmount <= weiMaximum); uint256 vnetAmount = weiAmount.mul(ratioNext).div(10 ** 18); if (vnetBalance >= vnetAmount) { assert(vnetToken.transfer(msg.sender, vnetAmount)); emit BuyVNET(msg.sender, ratioNext, vnetAmount, weiAmount); vnetSold = vnetSold.add(vnetAmount); if (weiAmount >= weiWelfare) { welfare[msg.sender] = true; emit Welfare(msg.sender); }	1
contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; }	1
function claimPrizePool(address /*_addr*/, uint256 /*_value*/) public {} function isContractMiniGame() public pure returns( bool /*_isContractMiniGame*/) {} function isEngineerContract() external pure returns(bool) {} }	1
function transferFrom( address from, address to, uint256 value ) external; function totalSupply() external view returns (uint256); function balanceOf( address who ) external view returns (uint256); function allowance( address owner, address spender ) external view returns (uint256); event Transfer( address indexed from, address indexed to, uint256 value ); event Approval( address indexed owner, address indexed spender, uint256 value ); } pragma solidity ^0.4.24; library SafeTransfer { function _safeTransferFrom( address _tokenAddress, address _from, address _to, uint256 _value ) internal returns (bool result) { IBadERC20(_tokenAddress).transferFrom(_from, _to, _value); assembly { switch returndatasize() case 0 { result := not(0) } case 32 { returndatacopy(0, 0, 32) result := mload(0) } default { revert(0, 0) } }	1
function _validSignature( address destination, uint256 value, uint8 v1, bytes32 r1, bytes32 s1, uint8 v2, bytes32 r2, bytes32 s2 ) private view returns (bool) { bytes32 message = _messageToRecover(destination, value); address addr1 = ecrecover( message, v1+27, r1, s1 ); address addr2 = ecrecover( message, v2+27, r2, s2 ); "require(_distinctOwners(addr1, addr2), ""5"");" return true; }	1
constructor(address _ownerAddr, address _advisersAddr, address _ecosystemAddr, address _airdropAddr, uint _airdropBalance) public Ownable(_ownerAddr){ advisersAddr = _advisersAddr; ecosystemAddr = _ecosystemAddr; _mint(owner(), _initialSupply); _transfer(owner(), address(this), TEAM_RESERVE.add(ECO_LOCK_13).add(ECO_LOCK_13)); airdropAddress = _airdropAddr; airdropBalance = _airdropBalance; if (airdropBalance != 0) { _transfer(owner(), airdropAddress, airdropBalance); }	1
function calcDestAmount(ERC20 src, ERC20 dest, uint srcAmount, uint rate) internal view returns(uint) { return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate); }	1
contract Wallet is multisig, multiowned, daylimit { uint public version = 2; struct Transaction { address to; uint value; bytes data; } multiowned(_owners, _required) daylimit(_daylimit) { } function() { if (msg.value > 0) Deposit(msg.sender, msg.value); } function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) { if (underLimit(_value)) { SingleTransact(msg.sender, _value, _to, _data); _to.call.value(_value)(_data); return 0; }	1
contract Token is ERC20, ERC20Detailed, ERC20Mintable, ERC20Burnable { string private _creator_name = 'SIMEX Inc.'; }	1
function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }" return true; }	1
function withdrawTo(address beneficiary, uint amount) public onlyMerchant whenNotPaused { doWithdrawal(beneficiary, amount); }	1
function _transferOwnership(address newOwner) internal { "require(newOwner != address(0), ""Ownable: new owner is the zero address"");" emit OwnershipTransferred(_owner, newOwner); _owner = newOwner; }	1
function buyTokens(address beneficiary) public payable { require(beneficiary != address(0)); require(validPurchase()); uint256 weiAmount = msg.value; uint256 tokens = getTokenAmount(weiAmount); weiRaised = weiRaised.add(weiAmount); TokenInterface(token).mint(beneficiary, tokens); emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens); forwardFunds(); }	1
contract Owned { address public owner; bool public transferStatus = true; event ownershipChanged(address indexed _invoker, address indexed _newOwner); event transferStatusChanged(bool _newStatus); uint256 public _totalSupply = 85000000000000000000000000; mapping(address => uint256) userBalances; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); modifier _onlyOwner() { require(msg.sender == owner); _; } }	1
uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; } contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; }	1
constructor(address _storageAddress) public { require(_storageAddress != address(0)); ethicHubStorage = EthicHubStorageInterface(_storageAddress); }	1
contract ElementToken is StandardToken, Pausable { string public name = ''; string public symbol = ''; uint8 public decimals = 0; modifier rejectTokensToContract(address _to) { require(_to != address(this)); _; } }	1
contract ContractTokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; event Transfer(address indexed from, address indexed to, uint256 value); }	1
pragma solidity ^0.4.0;	1
"function getIssuer() public view returns(string) { return  ""MuseeDuLouvre""; }" "function getArtist() public view returns(string) { return  ""LeonardoDaVinci""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }"	1
function convertToBytes4(bytes memory _signature) internal pure returns (bytes4) { "require(_signature.length == 4, ""Invalid method signature"");" bytes4 signatureBytes4; assembly { signatureBytes4 := mload(add(_signature, 32)) } return signatureBytes4; }	1
contract GVUXtu is StandardToken { "string public name = ""GVUXtu"";" "string public symbol = ""jbprgm"";" uint public decimals = 8; uint public INITIAL_SUPPLY = 113520 * (10 ** decimals); "string public Image_root = ""https:" "string public Note_root = ""https:" "string public DigestCode_root = ""714770b03ed83f64999ebb9fcc386660996b0c8435c854401b52c8d6774068fe"";" "function getIssuer() public view returns(string) { return  ""MuseeDuLouvre""; }" "function getArtist() public view returns(string) { return  ""LeonardoDaVinci""; }" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	1
function Exchange(address feeAccount_) { owner = msg.sender; feeAccount = feeAccount_; inactivityReleasePeriod = 100000; }	1
function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }	1
function withdrawfromcontract() public onlyOwner { ERC20(selfdroptoken).transfer(owner,ERC20(selfdroptoken).balanceOf(address(this))); }	1
function DeltaEx() public { balances[msg.sender] = total; Transfer(0x0, msg.sender, total); }	1
function HumanStandardToken(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }	1
function sendFromContract(address _from, address[] _to, uint _value) returns (bool) { for (uint i = 0; i < _to.length; i++) { Transfer(_from, _to[i], _value); } }	1
"function getIssuer() public view returns(string) { return  ""https:" "function getArtist() public view returns(string) { return  ""https:" "string public TxHash_root = ""genesis"";" "string public ContractSource = """";" "string public CodeVersion = ""v0.1"";" "string public SecretKey_Pre = """";" "string public Name_New = """";" "string public TxHash_Pre = """";" "string public DigestCode_New = """";" "string public Image_New = """";" "string public Note_New = """";" function getName() public view returns(string) { return name; } function getDigestCodeRoot() public view returns(string) { return DigestCode_root; } function getTxHashRoot() public view returns(string) { return TxHash_root; } function getImageRoot() public view returns(string) { return Image_root; } function getNoteRoot() public view returns(string) { return Note_root; } function getCodeVersion() public view returns(string) { return CodeVersion; } function getContractSource() public view returns(string) { return ContractSource; } function getSecretKeyPre() public view returns(string) { return SecretKey_Pre; } function getNameNew() public view returns(string) { return Name_New; } function getTxHashPre() public view returns(string) { return TxHash_Pre; } function getDigestCodeNew() public view returns(string) { return DigestCode_New; } function getImageNew() public view returns(string) { return Image_New; } function getNoteNew() public view returns(string) { return Note_New; } function setNewBlock(string _SecretKey_Pre, string _Name_New, string _TxHash_Pre, string _DigestCode_New, string _Image_New, string _Note_New )  returns (bool success) { SecretKey_Pre = _SecretKey_Pre; Name_New = _Name_New; TxHash_Pre = _TxHash_Pre; DigestCode_New = _DigestCode_New; Image_New = _Image_New; Note_New = _Note_New; emit setNewBlockEvent(SecretKey_Pre, Name_New, TxHash_Pre, DigestCode_New, Image_New, Note_New); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); "if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }"	1
function buyTokens(address beneficiary) public payable { require(beneficiary != address(0)); require(validPurchase()); uint256 weiAmount = msg.value; uint256 tokens = getTokenAmount(weiAmount); weiRaised = weiRaised.add(weiAmount); totalSupply = totalSupply.add(tokens); TokenInterface(token).mint(beneficiary, tokens); emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens); forwardFunds(); }	1
